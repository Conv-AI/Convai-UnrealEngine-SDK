#ifdef __APPLE__
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_service_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_service_2eproto;
namespace service {
class ActionConfig;
struct ActionConfigDefaultTypeInternal;
extern ActionConfigDefaultTypeInternal _ActionConfig_default_instance_;
class ActionConfig_Character;
struct ActionConfig_CharacterDefaultTypeInternal;
extern ActionConfig_CharacterDefaultTypeInternal _ActionConfig_Character_default_instance_;
class ActionConfig_Object;
struct ActionConfig_ObjectDefaultTypeInternal;
extern ActionConfig_ObjectDefaultTypeInternal _ActionConfig_Object_default_instance_;
class AudioConfig;
struct AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class BlendShapesData;
struct BlendShapesDataDefaultTypeInternal;
extern BlendShapesDataDefaultTypeInternal _BlendShapesData_default_instance_;
class FeedbackRequest;
struct FeedbackRequestDefaultTypeInternal;
extern FeedbackRequestDefaultTypeInternal _FeedbackRequest_default_instance_;
class FeedbackRequest_Feedback;
struct FeedbackRequest_FeedbackDefaultTypeInternal;
extern FeedbackRequest_FeedbackDefaultTypeInternal _FeedbackRequest_Feedback_default_instance_;
class FeedbackResponse;
struct FeedbackResponseDefaultTypeInternal;
extern FeedbackResponseDefaultTypeInternal _FeedbackResponse_default_instance_;
class GetResponseRequest;
struct GetResponseRequestDefaultTypeInternal;
extern GetResponseRequestDefaultTypeInternal _GetResponseRequest_default_instance_;
class GetResponseRequestSingle;
struct GetResponseRequestSingleDefaultTypeInternal;
extern GetResponseRequestSingleDefaultTypeInternal _GetResponseRequestSingle_default_instance_;
class GetResponseRequest_GetResponseConfig;
struct GetResponseRequest_GetResponseConfigDefaultTypeInternal;
extern GetResponseRequest_GetResponseConfigDefaultTypeInternal _GetResponseRequest_GetResponseConfig_default_instance_;
class GetResponseRequest_GetResponseData;
struct GetResponseRequest_GetResponseDataDefaultTypeInternal;
extern GetResponseRequest_GetResponseDataDefaultTypeInternal _GetResponseRequest_GetResponseData_default_instance_;
class GetResponseResponse;
struct GetResponseResponseDefaultTypeInternal;
extern GetResponseResponseDefaultTypeInternal _GetResponseResponse_default_instance_;
class GetResponseResponse_ActionResponse;
struct GetResponseResponse_ActionResponseDefaultTypeInternal;
extern GetResponseResponse_ActionResponseDefaultTypeInternal _GetResponseResponse_ActionResponse_default_instance_;
class GetResponseResponse_AudioResponse;
struct GetResponseResponse_AudioResponseDefaultTypeInternal;
extern GetResponseResponse_AudioResponseDefaultTypeInternal _GetResponseResponse_AudioResponse_default_instance_;
class GetResponseResponse_BehaviorTreeResponse;
struct GetResponseResponse_BehaviorTreeResponseDefaultTypeInternal;
extern GetResponseResponse_BehaviorTreeResponseDefaultTypeInternal _GetResponseResponse_BehaviorTreeResponse_default_instance_;
class GetResponseResponse_UserTranscript;
struct GetResponseResponse_UserTranscriptDefaultTypeInternal;
extern GetResponseResponse_UserTranscriptDefaultTypeInternal _GetResponseResponse_UserTranscript_default_instance_;
class HelloRequest;
struct HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class HelloResponse;
struct HelloResponseDefaultTypeInternal;
extern HelloResponseDefaultTypeInternal _HelloResponse_default_instance_;
class STTRequest;
struct STTRequestDefaultTypeInternal;
extern STTRequestDefaultTypeInternal _STTRequest_default_instance_;
class STTResponse;
struct STTResponseDefaultTypeInternal;
extern STTResponseDefaultTypeInternal _STTResponse_default_instance_;
class TriggerConfig;
struct TriggerConfigDefaultTypeInternal;
extern TriggerConfigDefaultTypeInternal _TriggerConfig_default_instance_;
class Viseme;
struct VisemeDefaultTypeInternal;
extern VisemeDefaultTypeInternal _Viseme_default_instance_;
class VisemesData;
struct VisemesDataDefaultTypeInternal;
extern VisemesDataDefaultTypeInternal _VisemesData_default_instance_;
}  // namespace service
PROTOBUF_NAMESPACE_OPEN
template<> ::service::ActionConfig* Arena::CreateMaybeMessage<::service::ActionConfig>(Arena*);
template<> ::service::ActionConfig_Character* Arena::CreateMaybeMessage<::service::ActionConfig_Character>(Arena*);
template<> ::service::ActionConfig_Object* Arena::CreateMaybeMessage<::service::ActionConfig_Object>(Arena*);
template<> ::service::AudioConfig* Arena::CreateMaybeMessage<::service::AudioConfig>(Arena*);
template<> ::service::BlendShapesData* Arena::CreateMaybeMessage<::service::BlendShapesData>(Arena*);
template<> ::service::FeedbackRequest* Arena::CreateMaybeMessage<::service::FeedbackRequest>(Arena*);
template<> ::service::FeedbackRequest_Feedback* Arena::CreateMaybeMessage<::service::FeedbackRequest_Feedback>(Arena*);
template<> ::service::FeedbackResponse* Arena::CreateMaybeMessage<::service::FeedbackResponse>(Arena*);
template<> ::service::GetResponseRequest* Arena::CreateMaybeMessage<::service::GetResponseRequest>(Arena*);
template<> ::service::GetResponseRequestSingle* Arena::CreateMaybeMessage<::service::GetResponseRequestSingle>(Arena*);
template<> ::service::GetResponseRequest_GetResponseConfig* Arena::CreateMaybeMessage<::service::GetResponseRequest_GetResponseConfig>(Arena*);
template<> ::service::GetResponseRequest_GetResponseData* Arena::CreateMaybeMessage<::service::GetResponseRequest_GetResponseData>(Arena*);
template<> ::service::GetResponseResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse>(Arena*);
template<> ::service::GetResponseResponse_ActionResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse_ActionResponse>(Arena*);
template<> ::service::GetResponseResponse_AudioResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse_AudioResponse>(Arena*);
template<> ::service::GetResponseResponse_BehaviorTreeResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse_BehaviorTreeResponse>(Arena*);
template<> ::service::GetResponseResponse_UserTranscript* Arena::CreateMaybeMessage<::service::GetResponseResponse_UserTranscript>(Arena*);
template<> ::service::HelloRequest* Arena::CreateMaybeMessage<::service::HelloRequest>(Arena*);
template<> ::service::HelloResponse* Arena::CreateMaybeMessage<::service::HelloResponse>(Arena*);
template<> ::service::STTRequest* Arena::CreateMaybeMessage<::service::STTRequest>(Arena*);
template<> ::service::STTResponse* Arena::CreateMaybeMessage<::service::STTResponse>(Arena*);
template<> ::service::TriggerConfig* Arena::CreateMaybeMessage<::service::TriggerConfig>(Arena*);
template<> ::service::Viseme* Arena::CreateMaybeMessage<::service::Viseme>(Arena*);
template<> ::service::VisemesData* Arena::CreateMaybeMessage<::service::VisemesData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service {

enum FaceModel : int {
  FACE_MODEL_UNSPECIFIED = 0,
  FACE_MODEL_A_2F_MODEL_NAME = 1,
  FACE_MODEL_PHONEMES_MODEL_NAME = 2,
  FACE_MODEL_OVR_MODEL_NAME = 3,
  FaceModel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FaceModel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FaceModel_IsValid(int value);
constexpr FaceModel FaceModel_MIN = FACE_MODEL_UNSPECIFIED;
constexpr FaceModel FaceModel_MAX = FACE_MODEL_OVR_MODEL_NAME;
constexpr int FaceModel_ARRAYSIZE = FaceModel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FaceModel_descriptor();
template<typename T>
inline const std::string& FaceModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FaceModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FaceModel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FaceModel_descriptor(), enum_t_value);
}
inline bool FaceModel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FaceModel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FaceModel>(
    FaceModel_descriptor(), name, value);
}
// ===================================================================

class AudioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.AudioConfig) */ {
 public:
  inline AudioConfig() : AudioConfig(nullptr) {}
  ~AudioConfig() override;
  explicit PROTOBUF_CONSTEXPR AudioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioConfig(const AudioConfig& from);
  AudioConfig(AudioConfig&& from) noexcept
    : AudioConfig() {
    *this = ::std::move(from);
  }

  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
               &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AudioConfig& a, AudioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioConfig& from) {
    AudioConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.AudioConfig";
  }
  protected:
  explicit AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleRateHertzFieldNumber = 1,
    kDisableAudioFieldNumber = 2,
    kEnableFacialDataFieldNumber = 3,
    kFaceModelFieldNumber = 4,
  };
  // int32 sample_rate_hertz = 1;
  void clear_sample_rate_hertz();
  int32_t sample_rate_hertz() const;
  void set_sample_rate_hertz(int32_t value);
  private:
  int32_t _internal_sample_rate_hertz() const;
  void _internal_set_sample_rate_hertz(int32_t value);
  public:

  // bool disable_audio = 2;
  void clear_disable_audio();
  bool disable_audio() const;
  void set_disable_audio(bool value);
  private:
  bool _internal_disable_audio() const;
  void _internal_set_disable_audio(bool value);
  public:

  // bool enable_facial_data = 3;
  void clear_enable_facial_data();
  bool enable_facial_data() const;
  void set_enable_facial_data(bool value);
  private:
  bool _internal_enable_facial_data() const;
  void _internal_set_enable_facial_data(bool value);
  public:

  // .service.FaceModel face_model = 4;
  void clear_face_model();
  ::service::FaceModel face_model() const;
  void set_face_model(::service::FaceModel value);
  private:
  ::service::FaceModel _internal_face_model() const;
  void _internal_set_face_model(::service::FaceModel value);
  public:

  // @@protoc_insertion_point(class_scope:service.AudioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t sample_rate_hertz_;
    bool disable_audio_;
    bool enable_facial_data_;
    int face_model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TriggerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.TriggerConfig) */ {
 public:
  inline TriggerConfig() : TriggerConfig(nullptr) {}
  ~TriggerConfig() override;
  explicit PROTOBUF_CONSTEXPR TriggerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerConfig(const TriggerConfig& from);
  TriggerConfig(TriggerConfig&& from) noexcept
    : TriggerConfig() {
    *this = ::std::move(from);
  }

  inline TriggerConfig& operator=(const TriggerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerConfig& operator=(TriggerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TriggerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerConfig* internal_default_instance() {
    return reinterpret_cast<const TriggerConfig*>(
               &_TriggerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TriggerConfig& a, TriggerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TriggerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TriggerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TriggerConfig& from) {
    TriggerConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriggerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.TriggerConfig";
  }
  protected:
  explicit TriggerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerNameFieldNumber = 1,
    kTriggerMessageFieldNumber = 2,
  };
  // string trigger_name = 1;
  void clear_trigger_name();
  const std::string& trigger_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_name();
  PROTOBUF_NODISCARD std::string* release_trigger_name();
  void set_allocated_trigger_name(std::string* trigger_name);
  private:
  const std::string& _internal_trigger_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_name(const std::string& value);
  std::string* _internal_mutable_trigger_name();
  public:

  // string trigger_message = 2;
  void clear_trigger_message();
  const std::string& trigger_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_message();
  PROTOBUF_NODISCARD std::string* release_trigger_message();
  void set_allocated_trigger_message(std::string* trigger_message);
  private:
  const std::string& _internal_trigger_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_message(const std::string& value);
  std::string* _internal_mutable_trigger_message();
  public:

  // @@protoc_insertion_point(class_scope:service.TriggerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig_Character final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.ActionConfig.Character) */ {
 public:
  inline ActionConfig_Character() : ActionConfig_Character(nullptr) {}
  ~ActionConfig_Character() override;
  explicit PROTOBUF_CONSTEXPR ActionConfig_Character(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionConfig_Character(const ActionConfig_Character& from);
  ActionConfig_Character(ActionConfig_Character&& from) noexcept
    : ActionConfig_Character() {
    *this = ::std::move(from);
  }

  inline ActionConfig_Character& operator=(const ActionConfig_Character& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig_Character& operator=(ActionConfig_Character&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionConfig_Character& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionConfig_Character* internal_default_instance() {
    return reinterpret_cast<const ActionConfig_Character*>(
               &_ActionConfig_Character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ActionConfig_Character& a, ActionConfig_Character& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionConfig_Character* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig_Character* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionConfig_Character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionConfig_Character>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionConfig_Character& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionConfig_Character& from) {
    ActionConfig_Character::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig_Character* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.ActionConfig.Character";
  }
  protected:
  explicit ActionConfig_Character(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kBioFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string bio = 2;
  void clear_bio();
  const std::string& bio() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bio(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bio();
  PROTOBUF_NODISCARD std::string* release_bio();
  void set_allocated_bio(std::string* bio);
  private:
  const std::string& _internal_bio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bio(const std::string& value);
  std::string* _internal_mutable_bio();
  public:

  // @@protoc_insertion_point(class_scope:service.ActionConfig.Character)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bio_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig_Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.ActionConfig.Object) */ {
 public:
  inline ActionConfig_Object() : ActionConfig_Object(nullptr) {}
  ~ActionConfig_Object() override;
  explicit PROTOBUF_CONSTEXPR ActionConfig_Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionConfig_Object(const ActionConfig_Object& from);
  ActionConfig_Object(ActionConfig_Object&& from) noexcept
    : ActionConfig_Object() {
    *this = ::std::move(from);
  }

  inline ActionConfig_Object& operator=(const ActionConfig_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig_Object& operator=(ActionConfig_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionConfig_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionConfig_Object* internal_default_instance() {
    return reinterpret_cast<const ActionConfig_Object*>(
               &_ActionConfig_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ActionConfig_Object& a, ActionConfig_Object& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionConfig_Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig_Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionConfig_Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionConfig_Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionConfig_Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionConfig_Object& from) {
    ActionConfig_Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig_Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.ActionConfig.Object";
  }
  protected:
  explicit ActionConfig_Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:service.ActionConfig.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.ActionConfig) */ {
 public:
  inline ActionConfig() : ActionConfig(nullptr) {}
  ~ActionConfig() override;
  explicit PROTOBUF_CONSTEXPR ActionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionConfig(const ActionConfig& from);
  ActionConfig(ActionConfig&& from) noexcept
    : ActionConfig() {
    *this = ::std::move(from);
  }

  inline ActionConfig& operator=(const ActionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig& operator=(ActionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionConfig* internal_default_instance() {
    return reinterpret_cast<const ActionConfig*>(
               &_ActionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ActionConfig& a, ActionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionConfig& from) {
    ActionConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.ActionConfig";
  }
  protected:
  explicit ActionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionConfig_Character Character;
  typedef ActionConfig_Object Object;

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
    kCharactersFieldNumber = 2,
    kObjectsFieldNumber = 3,
    kClassificationFieldNumber = 4,
    kCurrentAttentionObjectFieldNumber = 6,
    kContextLevelFieldNumber = 5,
  };
  // repeated string actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  const std::string& actions(int index) const;
  std::string* mutable_actions(int index);
  void set_actions(int index, const std::string& value);
  void set_actions(int index, std::string&& value);
  void set_actions(int index, const char* value);
  void set_actions(int index, const char* value, size_t size);
  std::string* add_actions();
  void add_actions(const std::string& value);
  void add_actions(std::string&& value);
  void add_actions(const char* value);
  void add_actions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_actions();
  private:
  const std::string& _internal_actions(int index) const;
  std::string* _internal_add_actions();
  public:

  // repeated .service.ActionConfig.Character characters = 2;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::service::ActionConfig_Character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >*
      mutable_characters();
  private:
  const ::service::ActionConfig_Character& _internal_characters(int index) const;
  ::service::ActionConfig_Character* _internal_add_characters();
  public:
  const ::service::ActionConfig_Character& characters(int index) const;
  ::service::ActionConfig_Character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >&
      characters() const;

  // repeated .service.ActionConfig.Object objects = 3;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::service::ActionConfig_Object* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >*
      mutable_objects();
  private:
  const ::service::ActionConfig_Object& _internal_objects(int index) const;
  ::service::ActionConfig_Object* _internal_add_objects();
  public:
  const ::service::ActionConfig_Object& objects(int index) const;
  ::service::ActionConfig_Object* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >&
      objects() const;

  // string classification = 4;
  void clear_classification();
  const std::string& classification() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classification(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classification();
  PROTOBUF_NODISCARD std::string* release_classification();
  void set_allocated_classification(std::string* classification);
  private:
  const std::string& _internal_classification() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classification(const std::string& value);
  std::string* _internal_mutable_classification();
  public:

  // string current_attention_object = 6;
  void clear_current_attention_object();
  const std::string& current_attention_object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_attention_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_attention_object();
  PROTOBUF_NODISCARD std::string* release_current_attention_object();
  void set_allocated_current_attention_object(std::string* current_attention_object);
  private:
  const std::string& _internal_current_attention_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_attention_object(const std::string& value);
  std::string* _internal_mutable_current_attention_object();
  public:

  // int32 context_level = 5;
  void clear_context_level();
  int32_t context_level() const;
  void set_context_level(int32_t value);
  private:
  int32_t _internal_context_level() const;
  void _internal_set_context_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:service.ActionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> actions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character > characters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object > objects_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classification_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_attention_object_;
    int32_t context_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class STTRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.STTRequest) */ {
 public:
  inline STTRequest() : STTRequest(nullptr) {}
  ~STTRequest() override;
  explicit PROTOBUF_CONSTEXPR STTRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STTRequest(const STTRequest& from);
  STTRequest(STTRequest&& from) noexcept
    : STTRequest() {
    *this = ::std::move(from);
  }

  inline STTRequest& operator=(const STTRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTRequest& operator=(STTRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kAudioConfig = 1,
    kAudioChunk = 2,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const STTRequest* internal_default_instance() {
    return reinterpret_cast<const STTRequest*>(
               &_STTRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(STTRequest& a, STTRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(STTRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STTRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STTRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STTRequest& from) {
    STTRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.STTRequest";
  }
  protected:
  explicit STTRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioConfigFieldNumber = 1,
    kAudioChunkFieldNumber = 2,
  };
  // .service.AudioConfig audio_config = 1;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::service::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* audio_config);
  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::service::AudioConfig* audio_config);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  // bytes audio_chunk = 2;
  bool has_audio_chunk() const;
  private:
  bool _internal_has_audio_chunk() const;
  public:
  void clear_audio_chunk();
  const std::string& audio_chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_chunk();
  PROTOBUF_NODISCARD std::string* release_audio_chunk();
  void set_allocated_audio_chunk(std::string* audio_chunk);
  private:
  const std::string& _internal_audio_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_chunk(const std::string& value);
  std::string* _internal_mutable_audio_chunk();
  public:

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:service.STTRequest)
 private:
  class _Internal;
  void set_has_audio_config();
  void set_has_audio_chunk();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::service::AudioConfig* audio_config_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_chunk_;
    } request_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class STTResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.STTResponse) */ {
 public:
  inline STTResponse() : STTResponse(nullptr) {}
  ~STTResponse() override;
  explicit PROTOBUF_CONSTEXPR STTResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STTResponse(const STTResponse& from);
  STTResponse(STTResponse&& from) noexcept
    : STTResponse() {
    *this = ::std::move(from);
  }

  inline STTResponse& operator=(const STTResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTResponse& operator=(STTResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const STTResponse* internal_default_instance() {
    return reinterpret_cast<const STTResponse*>(
               &_STTResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(STTResponse& a, STTResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(STTResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STTResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STTResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STTResponse& from) {
    STTResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.STTResponse";
  }
  protected:
  explicit STTResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:service.STTResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest_GetResponseConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequest.GetResponseConfig) */ {
 public:
  inline GetResponseRequest_GetResponseConfig() : GetResponseRequest_GetResponseConfig(nullptr) {}
  ~GetResponseRequest_GetResponseConfig() override;
  explicit PROTOBUF_CONSTEXPR GetResponseRequest_GetResponseConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseRequest_GetResponseConfig(const GetResponseRequest_GetResponseConfig& from);
  GetResponseRequest_GetResponseConfig(GetResponseRequest_GetResponseConfig&& from) noexcept
    : GetResponseRequest_GetResponseConfig() {
    *this = ::std::move(from);
  }

  inline GetResponseRequest_GetResponseConfig& operator=(const GetResponseRequest_GetResponseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest_GetResponseConfig& operator=(GetResponseRequest_GetResponseConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequest_GetResponseConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseRequest_GetResponseConfig* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest_GetResponseConfig*>(
               &_GetResponseRequest_GetResponseConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetResponseRequest_GetResponseConfig& a, GetResponseRequest_GetResponseConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequest_GetResponseConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest_GetResponseConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequest_GetResponseConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseRequest_GetResponseConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseRequest_GetResponseConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseRequest_GetResponseConfig& from) {
    GetResponseRequest_GetResponseConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequest_GetResponseConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequest.GetResponseConfig";
  }
  protected:
  explicit GetResponseRequest_GetResponseConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterIdFieldNumber = 2,
    kApiKeyFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kSpeakerFieldNumber = 7,
    kLanguageCodeFieldNumber = 8,
    kAudioConfigFieldNumber = 5,
    kActionConfigFieldNumber = 6,
  };
  // string character_id = 2;
  void clear_character_id();
  const std::string& character_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_character_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* character_id);
  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const std::string& value);
  std::string* _internal_mutable_character_id();
  public:

  // string api_key = 3;
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_NODISCARD std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string session_id = 4;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string speaker = 7;
  void clear_speaker();
  const std::string& speaker() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_speaker(ArgT0&& arg0, ArgT... args);
  std::string* mutable_speaker();
  PROTOBUF_NODISCARD std::string* release_speaker();
  void set_allocated_speaker(std::string* speaker);
  private:
  const std::string& _internal_speaker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_speaker(const std::string& value);
  std::string* _internal_mutable_speaker();
  public:

  // string language_code = 8;
  void clear_language_code();
  const std::string& language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // .service.AudioConfig audio_config = 5;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::service::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* audio_config);
  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::service::AudioConfig* audio_config);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  // .service.ActionConfig action_config = 6;
  bool has_action_config() const;
  private:
  bool _internal_has_action_config() const;
  public:
  void clear_action_config();
  const ::service::ActionConfig& action_config() const;
  PROTOBUF_NODISCARD ::service::ActionConfig* release_action_config();
  ::service::ActionConfig* mutable_action_config();
  void set_allocated_action_config(::service::ActionConfig* action_config);
  private:
  const ::service::ActionConfig& _internal_action_config() const;
  ::service::ActionConfig* _internal_mutable_action_config();
  public:
  void unsafe_arena_set_allocated_action_config(
      ::service::ActionConfig* action_config);
  ::service::ActionConfig* unsafe_arena_release_action_config();

  // @@protoc_insertion_point(class_scope:service.GetResponseRequest.GetResponseConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr speaker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
    ::service::AudioConfig* audio_config_;
    ::service::ActionConfig* action_config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest_GetResponseData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequest.GetResponseData) */ {
 public:
  inline GetResponseRequest_GetResponseData() : GetResponseRequest_GetResponseData(nullptr) {}
  ~GetResponseRequest_GetResponseData() override;
  explicit PROTOBUF_CONSTEXPR GetResponseRequest_GetResponseData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseRequest_GetResponseData(const GetResponseRequest_GetResponseData& from);
  GetResponseRequest_GetResponseData(GetResponseRequest_GetResponseData&& from) noexcept
    : GetResponseRequest_GetResponseData() {
    *this = ::std::move(from);
  }

  inline GetResponseRequest_GetResponseData& operator=(const GetResponseRequest_GetResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest_GetResponseData& operator=(GetResponseRequest_GetResponseData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequest_GetResponseData& default_instance() {
    return *internal_default_instance();
  }
  enum InputTypeCase {
    kAudioData = 1,
    kTextData = 2,
    kTriggerData = 3,
    INPUT_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseRequest_GetResponseData* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest_GetResponseData*>(
               &_GetResponseRequest_GetResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetResponseRequest_GetResponseData& a, GetResponseRequest_GetResponseData& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequest_GetResponseData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest_GetResponseData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequest_GetResponseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseRequest_GetResponseData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseRequest_GetResponseData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseRequest_GetResponseData& from) {
    GetResponseRequest_GetResponseData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequest_GetResponseData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequest.GetResponseData";
  }
  protected:
  explicit GetResponseRequest_GetResponseData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDataFieldNumber = 1,
    kTextDataFieldNumber = 2,
    kTriggerDataFieldNumber = 3,
  };
  // bytes audio_data = 1;
  bool has_audio_data() const;
  private:
  bool _internal_has_audio_data() const;
  public:
  void clear_audio_data();
  const std::string& audio_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* audio_data);
  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(const std::string& value);
  std::string* _internal_mutable_audio_data();
  public:

  // string text_data = 2;
  bool has_text_data() const;
  private:
  bool _internal_has_text_data() const;
  public:
  void clear_text_data();
  const std::string& text_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // .service.TriggerConfig trigger_data = 3;
  bool has_trigger_data() const;
  private:
  bool _internal_has_trigger_data() const;
  public:
  void clear_trigger_data();
  const ::service::TriggerConfig& trigger_data() const;
  PROTOBUF_NODISCARD ::service::TriggerConfig* release_trigger_data();
  ::service::TriggerConfig* mutable_trigger_data();
  void set_allocated_trigger_data(::service::TriggerConfig* trigger_data);
  private:
  const ::service::TriggerConfig& _internal_trigger_data() const;
  ::service::TriggerConfig* _internal_mutable_trigger_data();
  public:
  void unsafe_arena_set_allocated_trigger_data(
      ::service::TriggerConfig* trigger_data);
  ::service::TriggerConfig* unsafe_arena_release_trigger_data();

  void clear_input_type();
  InputTypeCase input_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseRequest.GetResponseData)
 private:
  class _Internal;
  void set_has_audio_data();
  void set_has_text_data();
  void set_has_trigger_data();

  inline bool has_input_type() const;
  inline void clear_has_input_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union InputTypeUnion {
      constexpr InputTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_data_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
      ::service::TriggerConfig* trigger_data_;
    } input_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequest) */ {
 public:
  inline GetResponseRequest() : GetResponseRequest(nullptr) {}
  ~GetResponseRequest() override;
  explicit PROTOBUF_CONSTEXPR GetResponseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseRequest(const GetResponseRequest& from);
  GetResponseRequest(GetResponseRequest&& from) noexcept
    : GetResponseRequest() {
    *this = ::std::move(from);
  }

  inline GetResponseRequest& operator=(const GetResponseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest& operator=(GetResponseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kGetResponseConfig = 1,
    kGetResponseData = 2,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseRequest* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest*>(
               &_GetResponseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetResponseRequest& a, GetResponseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseRequest& from) {
    GetResponseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequest";
  }
  protected:
  explicit GetResponseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetResponseRequest_GetResponseConfig GetResponseConfig;
  typedef GetResponseRequest_GetResponseData GetResponseData;

  // accessors -------------------------------------------------------

  enum : int {
    kGetResponseConfigFieldNumber = 1,
    kGetResponseDataFieldNumber = 2,
  };
  // .service.GetResponseRequest.GetResponseConfig get_response_config = 1;
  bool has_get_response_config() const;
  private:
  bool _internal_has_get_response_config() const;
  public:
  void clear_get_response_config();
  const ::service::GetResponseRequest_GetResponseConfig& get_response_config() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest_GetResponseConfig* release_get_response_config();
  ::service::GetResponseRequest_GetResponseConfig* mutable_get_response_config();
  void set_allocated_get_response_config(::service::GetResponseRequest_GetResponseConfig* get_response_config);
  private:
  const ::service::GetResponseRequest_GetResponseConfig& _internal_get_response_config() const;
  ::service::GetResponseRequest_GetResponseConfig* _internal_mutable_get_response_config();
  public:
  void unsafe_arena_set_allocated_get_response_config(
      ::service::GetResponseRequest_GetResponseConfig* get_response_config);
  ::service::GetResponseRequest_GetResponseConfig* unsafe_arena_release_get_response_config();

  // .service.GetResponseRequest.GetResponseData get_response_data = 2;
  bool has_get_response_data() const;
  private:
  bool _internal_has_get_response_data() const;
  public:
  void clear_get_response_data();
  const ::service::GetResponseRequest_GetResponseData& get_response_data() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest_GetResponseData* release_get_response_data();
  ::service::GetResponseRequest_GetResponseData* mutable_get_response_data();
  void set_allocated_get_response_data(::service::GetResponseRequest_GetResponseData* get_response_data);
  private:
  const ::service::GetResponseRequest_GetResponseData& _internal_get_response_data() const;
  ::service::GetResponseRequest_GetResponseData* _internal_mutable_get_response_data();
  public:
  void unsafe_arena_set_allocated_get_response_data(
      ::service::GetResponseRequest_GetResponseData* get_response_data);
  ::service::GetResponseRequest_GetResponseData* unsafe_arena_release_get_response_data();

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseRequest)
 private:
  class _Internal;
  void set_has_get_response_config();
  void set_has_get_response_data();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::service::GetResponseRequest_GetResponseConfig* get_response_config_;
      ::service::GetResponseRequest_GetResponseData* get_response_data_;
    } request_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequestSingle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequestSingle) */ {
 public:
  inline GetResponseRequestSingle() : GetResponseRequestSingle(nullptr) {}
  ~GetResponseRequestSingle() override;
  explicit PROTOBUF_CONSTEXPR GetResponseRequestSingle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseRequestSingle(const GetResponseRequestSingle& from);
  GetResponseRequestSingle(GetResponseRequestSingle&& from) noexcept
    : GetResponseRequestSingle() {
    *this = ::std::move(from);
  }

  inline GetResponseRequestSingle& operator=(const GetResponseRequestSingle& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequestSingle& operator=(GetResponseRequestSingle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseRequestSingle& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseRequestSingle* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequestSingle*>(
               &_GetResponseRequestSingle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetResponseRequestSingle& a, GetResponseRequestSingle& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequestSingle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequestSingle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseRequestSingle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseRequestSingle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseRequestSingle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseRequestSingle& from) {
    GetResponseRequestSingle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequestSingle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequestSingle";
  }
  protected:
  explicit GetResponseRequestSingle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseConfigFieldNumber = 1,
    kResponseDataFieldNumber = 2,
  };
  // .service.GetResponseRequest response_config = 1;
  bool has_response_config() const;
  private:
  bool _internal_has_response_config() const;
  public:
  void clear_response_config();
  const ::service::GetResponseRequest& response_config() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest* release_response_config();
  ::service::GetResponseRequest* mutable_response_config();
  void set_allocated_response_config(::service::GetResponseRequest* response_config);
  private:
  const ::service::GetResponseRequest& _internal_response_config() const;
  ::service::GetResponseRequest* _internal_mutable_response_config();
  public:
  void unsafe_arena_set_allocated_response_config(
      ::service::GetResponseRequest* response_config);
  ::service::GetResponseRequest* unsafe_arena_release_response_config();

  // .service.GetResponseRequest response_data = 2;
  bool has_response_data() const;
  private:
  bool _internal_has_response_data() const;
  public:
  void clear_response_data();
  const ::service::GetResponseRequest& response_data() const;
  PROTOBUF_NODISCARD ::service::GetResponseRequest* release_response_data();
  ::service::GetResponseRequest* mutable_response_data();
  void set_allocated_response_data(::service::GetResponseRequest* response_data);
  private:
  const ::service::GetResponseRequest& _internal_response_data() const;
  ::service::GetResponseRequest* _internal_mutable_response_data();
  public:
  void unsafe_arena_set_allocated_response_data(
      ::service::GetResponseRequest* response_data);
  ::service::GetResponseRequest* unsafe_arena_release_response_data();

  // @@protoc_insertion_point(class_scope:service.GetResponseRequestSingle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::service::GetResponseRequest* response_config_;
    ::service::GetResponseRequest* response_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_AudioResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.AudioResponse) */ {
 public:
  inline GetResponseResponse_AudioResponse() : GetResponseResponse_AudioResponse(nullptr) {}
  ~GetResponseResponse_AudioResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_AudioResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse_AudioResponse(const GetResponseResponse_AudioResponse& from);
  GetResponseResponse_AudioResponse(GetResponseResponse_AudioResponse&& from) noexcept
    : GetResponseResponse_AudioResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_AudioResponse& operator=(const GetResponseResponse_AudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_AudioResponse& operator=(GetResponseResponse_AudioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_AudioResponse& default_instance() {
    return *internal_default_instance();
  }
  enum FaceDataTypeCase {
    kVisemesData = 6,
    kBlendshapesData = 7,
    FACE_DATA_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseResponse_AudioResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_AudioResponse*>(
               &_GetResponseResponse_AudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetResponseResponse_AudioResponse& a, GetResponseResponse_AudioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_AudioResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_AudioResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_AudioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse_AudioResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_AudioResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse_AudioResponse& from) {
    GetResponseResponse_AudioResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_AudioResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.AudioResponse";
  }
  protected:
  explicit GetResponseResponse_AudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDataFieldNumber = 1,
    kTextDataFieldNumber = 3,
    kFaceDataFieldNumber = 5,
    kAudioConfigFieldNumber = 2,
    kEndOfResponseFieldNumber = 4,
    kVisemesDataFieldNumber = 6,
    kBlendshapesDataFieldNumber = 7,
  };
  // bytes audio_data = 1;
  void clear_audio_data();
  const std::string& audio_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* audio_data);
  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(const std::string& value);
  std::string* _internal_mutable_audio_data();
  public:

  // string text_data = 3;
  void clear_text_data();
  const std::string& text_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // string face_data = 5;
  void clear_face_data();
  const std::string& face_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_face_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_face_data();
  PROTOBUF_NODISCARD std::string* release_face_data();
  void set_allocated_face_data(std::string* face_data);
  private:
  const std::string& _internal_face_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_face_data(const std::string& value);
  std::string* _internal_mutable_face_data();
  public:

  // .service.AudioConfig audio_config = 2;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::service::AudioConfig& audio_config() const;
  PROTOBUF_NODISCARD ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* audio_config);
  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::service::AudioConfig* audio_config);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  // bool end_of_response = 4;
  void clear_end_of_response();
  bool end_of_response() const;
  void set_end_of_response(bool value);
  private:
  bool _internal_end_of_response() const;
  void _internal_set_end_of_response(bool value);
  public:

  // .service.VisemesData visemes_data = 6;
  bool has_visemes_data() const;
  private:
  bool _internal_has_visemes_data() const;
  public:
  void clear_visemes_data();
  const ::service::VisemesData& visemes_data() const;
  PROTOBUF_NODISCARD ::service::VisemesData* release_visemes_data();
  ::service::VisemesData* mutable_visemes_data();
  void set_allocated_visemes_data(::service::VisemesData* visemes_data);
  private:
  const ::service::VisemesData& _internal_visemes_data() const;
  ::service::VisemesData* _internal_mutable_visemes_data();
  public:
  void unsafe_arena_set_allocated_visemes_data(
      ::service::VisemesData* visemes_data);
  ::service::VisemesData* unsafe_arena_release_visemes_data();

  // .service.BlendShapesData blendshapes_data = 7;
  bool has_blendshapes_data() const;
  private:
  bool _internal_has_blendshapes_data() const;
  public:
  void clear_blendshapes_data();
  const ::service::BlendShapesData& blendshapes_data() const;
  PROTOBUF_NODISCARD ::service::BlendShapesData* release_blendshapes_data();
  ::service::BlendShapesData* mutable_blendshapes_data();
  void set_allocated_blendshapes_data(::service::BlendShapesData* blendshapes_data);
  private:
  const ::service::BlendShapesData& _internal_blendshapes_data() const;
  ::service::BlendShapesData* _internal_mutable_blendshapes_data();
  public:
  void unsafe_arena_set_allocated_blendshapes_data(
      ::service::BlendShapesData* blendshapes_data);
  ::service::BlendShapesData* unsafe_arena_release_blendshapes_data();

  void clear_face_data_type();
  FaceDataTypeCase face_data_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.AudioResponse)
 private:
  class _Internal;
  void set_has_visemes_data();
  void set_has_blendshapes_data();

  inline bool has_face_data_type() const;
  inline void clear_has_face_data_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr face_data_;
    ::service::AudioConfig* audio_config_;
    bool end_of_response_;
    union FaceDataTypeUnion {
      constexpr FaceDataTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::service::VisemesData* visemes_data_;
      ::service::BlendShapesData* blendshapes_data_;
    } face_data_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_ActionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.ActionResponse) */ {
 public:
  inline GetResponseResponse_ActionResponse() : GetResponseResponse_ActionResponse(nullptr) {}
  ~GetResponseResponse_ActionResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_ActionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse_ActionResponse(const GetResponseResponse_ActionResponse& from);
  GetResponseResponse_ActionResponse(GetResponseResponse_ActionResponse&& from) noexcept
    : GetResponseResponse_ActionResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_ActionResponse& operator=(const GetResponseResponse_ActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_ActionResponse& operator=(GetResponseResponse_ActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_ActionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseResponse_ActionResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_ActionResponse*>(
               &_GetResponseResponse_ActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetResponseResponse_ActionResponse& a, GetResponseResponse_ActionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_ActionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_ActionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_ActionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse_ActionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_ActionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse_ActionResponse& from) {
    GetResponseResponse_ActionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_ActionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.ActionResponse";
  }
  protected:
  explicit GetResponseResponse_ActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // string action = 1;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.ActionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_BehaviorTreeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.BehaviorTreeResponse) */ {
 public:
  inline GetResponseResponse_BehaviorTreeResponse() : GetResponseResponse_BehaviorTreeResponse(nullptr) {}
  ~GetResponseResponse_BehaviorTreeResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_BehaviorTreeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse_BehaviorTreeResponse(const GetResponseResponse_BehaviorTreeResponse& from);
  GetResponseResponse_BehaviorTreeResponse(GetResponseResponse_BehaviorTreeResponse&& from) noexcept
    : GetResponseResponse_BehaviorTreeResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_BehaviorTreeResponse& operator=(const GetResponseResponse_BehaviorTreeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_BehaviorTreeResponse& operator=(GetResponseResponse_BehaviorTreeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_BehaviorTreeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseResponse_BehaviorTreeResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_BehaviorTreeResponse*>(
               &_GetResponseResponse_BehaviorTreeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetResponseResponse_BehaviorTreeResponse& a, GetResponseResponse_BehaviorTreeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_BehaviorTreeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_BehaviorTreeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_BehaviorTreeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse_BehaviorTreeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_BehaviorTreeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse_BehaviorTreeResponse& from) {
    GetResponseResponse_BehaviorTreeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_BehaviorTreeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.BehaviorTreeResponse";
  }
  protected:
  explicit GetResponseResponse_BehaviorTreeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBtCodeFieldNumber = 1,
    kBtConstantsFieldNumber = 2,
    kNarrativeSectionIdFieldNumber = 3,
  };
  // string bt_code = 1;
  void clear_bt_code();
  const std::string& bt_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bt_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bt_code();
  PROTOBUF_NODISCARD std::string* release_bt_code();
  void set_allocated_bt_code(std::string* bt_code);
  private:
  const std::string& _internal_bt_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bt_code(const std::string& value);
  std::string* _internal_mutable_bt_code();
  public:

  // string bt_constants = 2;
  void clear_bt_constants();
  const std::string& bt_constants() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bt_constants(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bt_constants();
  PROTOBUF_NODISCARD std::string* release_bt_constants();
  void set_allocated_bt_constants(std::string* bt_constants);
  private:
  const std::string& _internal_bt_constants() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bt_constants(const std::string& value);
  std::string* _internal_mutable_bt_constants();
  public:

  // string narrative_section_id = 3;
  void clear_narrative_section_id();
  const std::string& narrative_section_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_narrative_section_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_narrative_section_id();
  PROTOBUF_NODISCARD std::string* release_narrative_section_id();
  void set_allocated_narrative_section_id(std::string* narrative_section_id);
  private:
  const std::string& _internal_narrative_section_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_narrative_section_id(const std::string& value);
  std::string* _internal_mutable_narrative_section_id();
  public:

  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.BehaviorTreeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bt_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bt_constants_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr narrative_section_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_UserTranscript final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.UserTranscript) */ {
 public:
  inline GetResponseResponse_UserTranscript() : GetResponseResponse_UserTranscript(nullptr) {}
  ~GetResponseResponse_UserTranscript() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse_UserTranscript(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse_UserTranscript(const GetResponseResponse_UserTranscript& from);
  GetResponseResponse_UserTranscript(GetResponseResponse_UserTranscript&& from) noexcept
    : GetResponseResponse_UserTranscript() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_UserTranscript& operator=(const GetResponseResponse_UserTranscript& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_UserTranscript& operator=(GetResponseResponse_UserTranscript&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse_UserTranscript& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponseResponse_UserTranscript* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_UserTranscript*>(
               &_GetResponseResponse_UserTranscript_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetResponseResponse_UserTranscript& a, GetResponseResponse_UserTranscript& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_UserTranscript* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_UserTranscript* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse_UserTranscript* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse_UserTranscript>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse_UserTranscript& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse_UserTranscript& from) {
    GetResponseResponse_UserTranscript::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_UserTranscript* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.UserTranscript";
  }
  protected:
  explicit GetResponseResponse_UserTranscript(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextDataFieldNumber = 1,
    kIsFinalFieldNumber = 2,
    kEndOfResponseFieldNumber = 3,
  };
  // string text_data = 1;
  void clear_text_data();
  const std::string& text_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // bool is_final = 2;
  void clear_is_final();
  bool is_final() const;
  void set_is_final(bool value);
  private:
  bool _internal_is_final() const;
  void _internal_set_is_final(bool value);
  public:

  // bool end_of_response = 3;
  void clear_end_of_response();
  bool end_of_response() const;
  void set_end_of_response(bool value);
  private:
  bool _internal_end_of_response() const;
  void _internal_set_end_of_response(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.UserTranscript)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
    bool is_final_;
    bool end_of_response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse) */ {
 public:
  inline GetResponseResponse() : GetResponseResponse(nullptr) {}
  ~GetResponseResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponseResponse(const GetResponseResponse& from);
  GetResponseResponse(GetResponseResponse&& from) noexcept
    : GetResponseResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse& operator=(const GetResponseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse& operator=(GetResponseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponseResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kActionResponse = 2,
    kAudioResponse = 3,
    kDebugLog = 4,
    kUserQuery = 5,
    kBtResponse = 6,
    kEmotionResponse = 7,
    kInteractionId = 8,
    RESPONSE_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse*>(
               &_GetResponseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetResponseResponse& a, GetResponseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponseResponse& from) {
    GetResponseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse";
  }
  protected:
  explicit GetResponseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetResponseResponse_AudioResponse AudioResponse;
  typedef GetResponseResponse_ActionResponse ActionResponse;
  typedef GetResponseResponse_BehaviorTreeResponse BehaviorTreeResponse;
  typedef GetResponseResponse_UserTranscript UserTranscript;

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kActionResponseFieldNumber = 2,
    kAudioResponseFieldNumber = 3,
    kDebugLogFieldNumber = 4,
    kUserQueryFieldNumber = 5,
    kBtResponseFieldNumber = 6,
    kEmotionResponseFieldNumber = 7,
    kInteractionIdFieldNumber = 8,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .service.GetResponseResponse.ActionResponse action_response = 2;
  bool has_action_response() const;
  private:
  bool _internal_has_action_response() const;
  public:
  void clear_action_response();
  const ::service::GetResponseResponse_ActionResponse& action_response() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_ActionResponse* release_action_response();
  ::service::GetResponseResponse_ActionResponse* mutable_action_response();
  void set_allocated_action_response(::service::GetResponseResponse_ActionResponse* action_response);
  private:
  const ::service::GetResponseResponse_ActionResponse& _internal_action_response() const;
  ::service::GetResponseResponse_ActionResponse* _internal_mutable_action_response();
  public:
  void unsafe_arena_set_allocated_action_response(
      ::service::GetResponseResponse_ActionResponse* action_response);
  ::service::GetResponseResponse_ActionResponse* unsafe_arena_release_action_response();

  // .service.GetResponseResponse.AudioResponse audio_response = 3;
  bool has_audio_response() const;
  private:
  bool _internal_has_audio_response() const;
  public:
  void clear_audio_response();
  const ::service::GetResponseResponse_AudioResponse& audio_response() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_AudioResponse* release_audio_response();
  ::service::GetResponseResponse_AudioResponse* mutable_audio_response();
  void set_allocated_audio_response(::service::GetResponseResponse_AudioResponse* audio_response);
  private:
  const ::service::GetResponseResponse_AudioResponse& _internal_audio_response() const;
  ::service::GetResponseResponse_AudioResponse* _internal_mutable_audio_response();
  public:
  void unsafe_arena_set_allocated_audio_response(
      ::service::GetResponseResponse_AudioResponse* audio_response);
  ::service::GetResponseResponse_AudioResponse* unsafe_arena_release_audio_response();

  // string debug_log = 4;
  bool has_debug_log() const;
  private:
  bool _internal_has_debug_log() const;
  public:
  void clear_debug_log();
  const std::string& debug_log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debug_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debug_log();
  PROTOBUF_NODISCARD std::string* release_debug_log();
  void set_allocated_debug_log(std::string* debug_log);
  private:
  const std::string& _internal_debug_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug_log(const std::string& value);
  std::string* _internal_mutable_debug_log();
  public:

  // .service.GetResponseResponse.UserTranscript user_query = 5;
  bool has_user_query() const;
  private:
  bool _internal_has_user_query() const;
  public:
  void clear_user_query();
  const ::service::GetResponseResponse_UserTranscript& user_query() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_UserTranscript* release_user_query();
  ::service::GetResponseResponse_UserTranscript* mutable_user_query();
  void set_allocated_user_query(::service::GetResponseResponse_UserTranscript* user_query);
  private:
  const ::service::GetResponseResponse_UserTranscript& _internal_user_query() const;
  ::service::GetResponseResponse_UserTranscript* _internal_mutable_user_query();
  public:
  void unsafe_arena_set_allocated_user_query(
      ::service::GetResponseResponse_UserTranscript* user_query);
  ::service::GetResponseResponse_UserTranscript* unsafe_arena_release_user_query();

  // .service.GetResponseResponse.BehaviorTreeResponse bt_response = 6;
  bool has_bt_response() const;
  private:
  bool _internal_has_bt_response() const;
  public:
  void clear_bt_response();
  const ::service::GetResponseResponse_BehaviorTreeResponse& bt_response() const;
  PROTOBUF_NODISCARD ::service::GetResponseResponse_BehaviorTreeResponse* release_bt_response();
  ::service::GetResponseResponse_BehaviorTreeResponse* mutable_bt_response();
  void set_allocated_bt_response(::service::GetResponseResponse_BehaviorTreeResponse* bt_response);
  private:
  const ::service::GetResponseResponse_BehaviorTreeResponse& _internal_bt_response() const;
  ::service::GetResponseResponse_BehaviorTreeResponse* _internal_mutable_bt_response();
  public:
  void unsafe_arena_set_allocated_bt_response(
      ::service::GetResponseResponse_BehaviorTreeResponse* bt_response);
  ::service::GetResponseResponse_BehaviorTreeResponse* unsafe_arena_release_bt_response();

  // string emotion_response = 7;
  bool has_emotion_response() const;
  private:
  bool _internal_has_emotion_response() const;
  public:
  void clear_emotion_response();
  const std::string& emotion_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_emotion_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_emotion_response();
  PROTOBUF_NODISCARD std::string* release_emotion_response();
  void set_allocated_emotion_response(std::string* emotion_response);
  private:
  const std::string& _internal_emotion_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emotion_response(const std::string& value);
  std::string* _internal_mutable_emotion_response();
  public:

  // string interaction_id = 8;
  bool has_interaction_id() const;
  private:
  bool _internal_has_interaction_id() const;
  public:
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse)
 private:
  class _Internal;
  void set_has_action_response();
  void set_has_audio_response();
  void set_has_debug_log();
  void set_has_user_query();
  void set_has_bt_response();
  void set_has_emotion_response();
  void set_has_interaction_id();

  inline bool has_response_type() const;
  inline void clear_has_response_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::service::GetResponseResponse_ActionResponse* action_response_;
      ::service::GetResponseResponse_AudioResponse* audio_response_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_log_;
      ::service::GetResponseResponse_UserTranscript* user_query_;
      ::service::GetResponseResponse_BehaviorTreeResponse* bt_response_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emotion_response_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    } response_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class VisemesData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.VisemesData) */ {
 public:
  inline VisemesData() : VisemesData(nullptr) {}
  ~VisemesData() override;
  explicit PROTOBUF_CONSTEXPR VisemesData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisemesData(const VisemesData& from);
  VisemesData(VisemesData&& from) noexcept
    : VisemesData() {
    *this = ::std::move(from);
  }

  inline VisemesData& operator=(const VisemesData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisemesData& operator=(VisemesData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisemesData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisemesData* internal_default_instance() {
    return reinterpret_cast<const VisemesData*>(
               &_VisemesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VisemesData& a, VisemesData& b) {
    a.Swap(&b);
  }
  inline void Swap(VisemesData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisemesData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisemesData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisemesData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisemesData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisemesData& from) {
    VisemesData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisemesData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.VisemesData";
  }
  protected:
  explicit VisemesData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisemesFieldNumber = 1,
  };
  // .service.Viseme visemes = 1;
  bool has_visemes() const;
  private:
  bool _internal_has_visemes() const;
  public:
  void clear_visemes();
  const ::service::Viseme& visemes() const;
  PROTOBUF_NODISCARD ::service::Viseme* release_visemes();
  ::service::Viseme* mutable_visemes();
  void set_allocated_visemes(::service::Viseme* visemes);
  private:
  const ::service::Viseme& _internal_visemes() const;
  ::service::Viseme* _internal_mutable_visemes();
  public:
  void unsafe_arena_set_allocated_visemes(
      ::service::Viseme* visemes);
  ::service::Viseme* unsafe_arena_release_visemes();

  // @@protoc_insertion_point(class_scope:service.VisemesData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::service::Viseme* visemes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class Viseme final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.Viseme) */ {
 public:
  inline Viseme() : Viseme(nullptr) {}
  ~Viseme() override;
  explicit PROTOBUF_CONSTEXPR Viseme(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Viseme(const Viseme& from);
  Viseme(Viseme&& from) noexcept
    : Viseme() {
    *this = ::std::move(from);
  }

  inline Viseme& operator=(const Viseme& from) {
    CopyFrom(from);
    return *this;
  }
  inline Viseme& operator=(Viseme&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Viseme& default_instance() {
    return *internal_default_instance();
  }
  static inline const Viseme* internal_default_instance() {
    return reinterpret_cast<const Viseme*>(
               &_Viseme_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Viseme& a, Viseme& b) {
    a.Swap(&b);
  }
  inline void Swap(Viseme* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Viseme* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Viseme* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Viseme>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Viseme& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Viseme& from) {
    Viseme::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Viseme* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.Viseme";
  }
  protected:
  explicit Viseme(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSilFieldNumber = 1,
    kPpFieldNumber = 2,
    kFfFieldNumber = 3,
    kThFieldNumber = 4,
    kDdFieldNumber = 5,
    kKkFieldNumber = 6,
    kChFieldNumber = 7,
    kSsFieldNumber = 8,
    kNnFieldNumber = 9,
    kRrFieldNumber = 10,
    kAaFieldNumber = 11,
    kEFieldNumber = 12,
    kIhFieldNumber = 13,
    kOhFieldNumber = 14,
    kOuFieldNumber = 15,
  };
  // float sil = 1;
  void clear_sil();
  float sil() const;
  void set_sil(float value);
  private:
  float _internal_sil() const;
  void _internal_set_sil(float value);
  public:

  // float pp = 2;
  void clear_pp();
  float pp() const;
  void set_pp(float value);
  private:
  float _internal_pp() const;
  void _internal_set_pp(float value);
  public:

  // float ff = 3;
  void clear_ff();
  float ff() const;
  void set_ff(float value);
  private:
  float _internal_ff() const;
  void _internal_set_ff(float value);
  public:

  // float th = 4;
  void clear_th();
  float th() const;
  void set_th(float value);
  private:
  float _internal_th() const;
  void _internal_set_th(float value);
  public:

  // float dd = 5;
  void clear_dd();
  float dd() const;
  void set_dd(float value);
  private:
  float _internal_dd() const;
  void _internal_set_dd(float value);
  public:

  // float kk = 6;
  void clear_kk();
  float kk() const;
  void set_kk(float value);
  private:
  float _internal_kk() const;
  void _internal_set_kk(float value);
  public:

  // float ch = 7;
  void clear_ch();
  float ch() const;
  void set_ch(float value);
  private:
  float _internal_ch() const;
  void _internal_set_ch(float value);
  public:

  // float ss = 8;
  void clear_ss();
  float ss() const;
  void set_ss(float value);
  private:
  float _internal_ss() const;
  void _internal_set_ss(float value);
  public:

  // float nn = 9;
  void clear_nn();
  float nn() const;
  void set_nn(float value);
  private:
  float _internal_nn() const;
  void _internal_set_nn(float value);
  public:

  // float rr = 10;
  void clear_rr();
  float rr() const;
  void set_rr(float value);
  private:
  float _internal_rr() const;
  void _internal_set_rr(float value);
  public:

  // float aa = 11;
  void clear_aa();
  float aa() const;
  void set_aa(float value);
  private:
  float _internal_aa() const;
  void _internal_set_aa(float value);
  public:

  // float e = 12;
  void clear_e();
  float e() const;
  void set_e(float value);
  private:
  float _internal_e() const;
  void _internal_set_e(float value);
  public:

  // float ih = 13;
  void clear_ih();
  float ih() const;
  void set_ih(float value);
  private:
  float _internal_ih() const;
  void _internal_set_ih(float value);
  public:

  // float oh = 14;
  void clear_oh();
  float oh() const;
  void set_oh(float value);
  private:
  float _internal_oh() const;
  void _internal_set_oh(float value);
  public:

  // float ou = 15;
  void clear_ou();
  float ou() const;
  void set_ou(float value);
  private:
  float _internal_ou() const;
  void _internal_set_ou(float value);
  public:

  // @@protoc_insertion_point(class_scope:service.Viseme)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float sil_;
    float pp_;
    float ff_;
    float th_;
    float dd_;
    float kk_;
    float ch_;
    float ss_;
    float nn_;
    float rr_;
    float aa_;
    float e_;
    float ih_;
    float oh_;
    float ou_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class BlendShapesData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.BlendShapesData) */ {
 public:
  inline BlendShapesData() : BlendShapesData(nullptr) {}
  ~BlendShapesData() override;
  explicit PROTOBUF_CONSTEXPR BlendShapesData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlendShapesData(const BlendShapesData& from);
  BlendShapesData(BlendShapesData&& from) noexcept
    : BlendShapesData() {
    *this = ::std::move(from);
  }

  inline BlendShapesData& operator=(const BlendShapesData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlendShapesData& operator=(BlendShapesData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlendShapesData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlendShapesData* internal_default_instance() {
    return reinterpret_cast<const BlendShapesData*>(
               &_BlendShapesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BlendShapesData& a, BlendShapesData& b) {
    a.Swap(&b);
  }
  inline void Swap(BlendShapesData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlendShapesData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlendShapesData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlendShapesData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlendShapesData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlendShapesData& from) {
    BlendShapesData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlendShapesData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.BlendShapesData";
  }
  protected:
  explicit BlendShapesData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlendshapeDataFieldNumber = 1,
  };
  // string blendshape_data = 1;
  void clear_blendshape_data();
  const std::string& blendshape_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blendshape_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blendshape_data();
  PROTOBUF_NODISCARD std::string* release_blendshape_data();
  void set_allocated_blendshape_data(std::string* blendshape_data);
  private:
  const std::string& _internal_blendshape_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blendshape_data(const std::string& value);
  std::string* _internal_mutable_blendshape_data();
  public:

  // @@protoc_insertion_point(class_scope:service.BlendShapesData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blendshape_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class HelloRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  ~HelloRequest() override;
  explicit PROTOBUF_CONSTEXPR HelloRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloRequest& from) {
    HelloRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:service.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class HelloResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.HelloResponse) */ {
 public:
  inline HelloResponse() : HelloResponse(nullptr) {}
  ~HelloResponse() override;
  explicit PROTOBUF_CONSTEXPR HelloResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloResponse(const HelloResponse& from);
  HelloResponse(HelloResponse&& from) noexcept
    : HelloResponse() {
    *this = ::std::move(from);
  }

  inline HelloResponse& operator=(const HelloResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloResponse& operator=(HelloResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloResponse* internal_default_instance() {
    return reinterpret_cast<const HelloResponse*>(
               &_HelloResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(HelloResponse& a, HelloResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloResponse& from) {
    HelloResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.HelloResponse";
  }
  protected:
  explicit HelloResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:service.HelloResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackRequest_Feedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.FeedbackRequest.Feedback) */ {
 public:
  inline FeedbackRequest_Feedback() : FeedbackRequest_Feedback(nullptr) {}
  ~FeedbackRequest_Feedback() override;
  explicit PROTOBUF_CONSTEXPR FeedbackRequest_Feedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedbackRequest_Feedback(const FeedbackRequest_Feedback& from);
  FeedbackRequest_Feedback(FeedbackRequest_Feedback&& from) noexcept
    : FeedbackRequest_Feedback() {
    *this = ::std::move(from);
  }

  inline FeedbackRequest_Feedback& operator=(const FeedbackRequest_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackRequest_Feedback& operator=(FeedbackRequest_Feedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackRequest_Feedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackRequest_Feedback* internal_default_instance() {
    return reinterpret_cast<const FeedbackRequest_Feedback*>(
               &_FeedbackRequest_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(FeedbackRequest_Feedback& a, FeedbackRequest_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackRequest_Feedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackRequest_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackRequest_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedbackRequest_Feedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedbackRequest_Feedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedbackRequest_Feedback& from) {
    FeedbackRequest_Feedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackRequest_Feedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.FeedbackRequest.Feedback";
  }
  protected:
  explicit FeedbackRequest_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedbackTextFieldNumber = 2,
    kThumbsUpFieldNumber = 1,
  };
  // string feedback_text = 2;
  void clear_feedback_text();
  const std::string& feedback_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feedback_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feedback_text();
  PROTOBUF_NODISCARD std::string* release_feedback_text();
  void set_allocated_feedback_text(std::string* feedback_text);
  private:
  const std::string& _internal_feedback_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_text(const std::string& value);
  std::string* _internal_mutable_feedback_text();
  public:

  // bool thumbs_up = 1;
  void clear_thumbs_up();
  bool thumbs_up() const;
  void set_thumbs_up(bool value);
  private:
  bool _internal_thumbs_up() const;
  void _internal_set_thumbs_up(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service.FeedbackRequest.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_text_;
    bool thumbs_up_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.FeedbackRequest) */ {
 public:
  inline FeedbackRequest() : FeedbackRequest(nullptr) {}
  ~FeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR FeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedbackRequest(const FeedbackRequest& from);
  FeedbackRequest(FeedbackRequest&& from) noexcept
    : FeedbackRequest() {
    *this = ::std::move(from);
  }

  inline FeedbackRequest& operator=(const FeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackRequest& operator=(FeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const FeedbackRequest*>(
               &_FeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FeedbackRequest& a, FeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedbackRequest& from) {
    FeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.FeedbackRequest";
  }
  protected:
  explicit FeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FeedbackRequest_Feedback Feedback;

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
    kCharacterIdFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kTextFeedbackFieldNumber = 5,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string character_id = 2;
  void clear_character_id();
  const std::string& character_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_character_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* character_id);
  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(const std::string& value);
  std::string* _internal_mutable_character_id();
  public:

  // string session_id = 3;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .service.FeedbackRequest.Feedback text_feedback = 5;
  bool has_text_feedback() const;
  private:
  bool _internal_has_text_feedback() const;
  public:
  void clear_text_feedback();
  const ::service::FeedbackRequest_Feedback& text_feedback() const;
  PROTOBUF_NODISCARD ::service::FeedbackRequest_Feedback* release_text_feedback();
  ::service::FeedbackRequest_Feedback* mutable_text_feedback();
  void set_allocated_text_feedback(::service::FeedbackRequest_Feedback* text_feedback);
  private:
  const ::service::FeedbackRequest_Feedback& _internal_text_feedback() const;
  ::service::FeedbackRequest_Feedback* _internal_mutable_text_feedback();
  public:
  void unsafe_arena_set_allocated_text_feedback(
      ::service::FeedbackRequest_Feedback* text_feedback);
  ::service::FeedbackRequest_Feedback* unsafe_arena_release_text_feedback();

  // @@protoc_insertion_point(class_scope:service.FeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::service::FeedbackRequest_Feedback* text_feedback_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.FeedbackResponse) */ {
 public:
  inline FeedbackResponse() : FeedbackResponse(nullptr) {}
  ~FeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR FeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedbackResponse(const FeedbackResponse& from);
  FeedbackResponse(FeedbackResponse&& from) noexcept
    : FeedbackResponse() {
    *this = ::std::move(from);
  }

  inline FeedbackResponse& operator=(const FeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackResponse& operator=(FeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const FeedbackResponse*>(
               &_FeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(FeedbackResponse& a, FeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedbackResponse& from) {
    FeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.FeedbackResponse";
  }
  protected:
  explicit FeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedbackResponseFieldNumber = 1,
  };
  // string feedback_response = 1;
  void clear_feedback_response();
  const std::string& feedback_response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feedback_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feedback_response();
  PROTOBUF_NODISCARD std::string* release_feedback_response();
  void set_allocated_feedback_response(std::string* feedback_response);
  private:
  const std::string& _internal_feedback_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_response(const std::string& value);
  std::string* _internal_mutable_feedback_response();
  public:

  // @@protoc_insertion_point(class_scope:service.FeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AudioConfig

// int32 sample_rate_hertz = 1;
inline void AudioConfig::clear_sample_rate_hertz() {
  _impl_.sample_rate_hertz_ = 0;
}
inline int32_t AudioConfig::_internal_sample_rate_hertz() const {
  return _impl_.sample_rate_hertz_;
}
inline int32_t AudioConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.sample_rate_hertz)
  return _internal_sample_rate_hertz();
}
inline void AudioConfig::_internal_set_sample_rate_hertz(int32_t value) {
  
  _impl_.sample_rate_hertz_ = value;
}
inline void AudioConfig::set_sample_rate_hertz(int32_t value) {
  _internal_set_sample_rate_hertz(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.sample_rate_hertz)
}

// bool disable_audio = 2;
inline void AudioConfig::clear_disable_audio() {
  _impl_.disable_audio_ = false;
}
inline bool AudioConfig::_internal_disable_audio() const {
  return _impl_.disable_audio_;
}
inline bool AudioConfig::disable_audio() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.disable_audio)
  return _internal_disable_audio();
}
inline void AudioConfig::_internal_set_disable_audio(bool value) {
  
  _impl_.disable_audio_ = value;
}
inline void AudioConfig::set_disable_audio(bool value) {
  _internal_set_disable_audio(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.disable_audio)
}

// bool enable_facial_data = 3;
inline void AudioConfig::clear_enable_facial_data() {
  _impl_.enable_facial_data_ = false;
}
inline bool AudioConfig::_internal_enable_facial_data() const {
  return _impl_.enable_facial_data_;
}
inline bool AudioConfig::enable_facial_data() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.enable_facial_data)
  return _internal_enable_facial_data();
}
inline void AudioConfig::_internal_set_enable_facial_data(bool value) {
  
  _impl_.enable_facial_data_ = value;
}
inline void AudioConfig::set_enable_facial_data(bool value) {
  _internal_set_enable_facial_data(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.enable_facial_data)
}

// .service.FaceModel face_model = 4;
inline void AudioConfig::clear_face_model() {
  _impl_.face_model_ = 0;
}
inline ::service::FaceModel AudioConfig::_internal_face_model() const {
  return static_cast< ::service::FaceModel >(_impl_.face_model_);
}
inline ::service::FaceModel AudioConfig::face_model() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.face_model)
  return _internal_face_model();
}
inline void AudioConfig::_internal_set_face_model(::service::FaceModel value) {
  
  _impl_.face_model_ = value;
}
inline void AudioConfig::set_face_model(::service::FaceModel value) {
  _internal_set_face_model(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.face_model)
}

// -------------------------------------------------------------------

// TriggerConfig

// string trigger_name = 1;
inline void TriggerConfig::clear_trigger_name() {
  _impl_.trigger_name_.ClearToEmpty();
}
inline const std::string& TriggerConfig::trigger_name() const {
  // @@protoc_insertion_point(field_get:service.TriggerConfig.trigger_name)
  return _internal_trigger_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerConfig::set_trigger_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.TriggerConfig.trigger_name)
}
inline std::string* TriggerConfig::mutable_trigger_name() {
  std::string* _s = _internal_mutable_trigger_name();
  // @@protoc_insertion_point(field_mutable:service.TriggerConfig.trigger_name)
  return _s;
}
inline const std::string& TriggerConfig::_internal_trigger_name() const {
  return _impl_.trigger_name_.Get();
}
inline void TriggerConfig::_internal_set_trigger_name(const std::string& value) {
  
  _impl_.trigger_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerConfig::_internal_mutable_trigger_name() {
  
  return _impl_.trigger_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerConfig::release_trigger_name() {
  // @@protoc_insertion_point(field_release:service.TriggerConfig.trigger_name)
  return _impl_.trigger_name_.Release();
}
inline void TriggerConfig::set_allocated_trigger_name(std::string* trigger_name) {
  if (trigger_name != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_name_.SetAllocated(trigger_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_name_.IsDefault()) {
    _impl_.trigger_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.TriggerConfig.trigger_name)
}

// string trigger_message = 2;
inline void TriggerConfig::clear_trigger_message() {
  _impl_.trigger_message_.ClearToEmpty();
}
inline const std::string& TriggerConfig::trigger_message() const {
  // @@protoc_insertion_point(field_get:service.TriggerConfig.trigger_message)
  return _internal_trigger_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerConfig::set_trigger_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.TriggerConfig.trigger_message)
}
inline std::string* TriggerConfig::mutable_trigger_message() {
  std::string* _s = _internal_mutable_trigger_message();
  // @@protoc_insertion_point(field_mutable:service.TriggerConfig.trigger_message)
  return _s;
}
inline const std::string& TriggerConfig::_internal_trigger_message() const {
  return _impl_.trigger_message_.Get();
}
inline void TriggerConfig::_internal_set_trigger_message(const std::string& value) {
  
  _impl_.trigger_message_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerConfig::_internal_mutable_trigger_message() {
  
  return _impl_.trigger_message_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerConfig::release_trigger_message() {
  // @@protoc_insertion_point(field_release:service.TriggerConfig.trigger_message)
  return _impl_.trigger_message_.Release();
}
inline void TriggerConfig::set_allocated_trigger_message(std::string* trigger_message) {
  if (trigger_message != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_message_.SetAllocated(trigger_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_message_.IsDefault()) {
    _impl_.trigger_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.TriggerConfig.trigger_message)
}

// -------------------------------------------------------------------

// ActionConfig_Character

// string name = 1;
inline void ActionConfig_Character::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ActionConfig_Character::name() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Character.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig_Character::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Character.name)
}
inline std::string* ActionConfig_Character::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Character.name)
  return _s;
}
inline const std::string& ActionConfig_Character::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ActionConfig_Character::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig_Character::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig_Character::release_name() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Character.name)
  return _impl_.name_.Release();
}
inline void ActionConfig_Character::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Character.name)
}

// string bio = 2;
inline void ActionConfig_Character::clear_bio() {
  _impl_.bio_.ClearToEmpty();
}
inline const std::string& ActionConfig_Character::bio() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Character.bio)
  return _internal_bio();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig_Character::set_bio(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bio_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Character.bio)
}
inline std::string* ActionConfig_Character::mutable_bio() {
  std::string* _s = _internal_mutable_bio();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Character.bio)
  return _s;
}
inline const std::string& ActionConfig_Character::_internal_bio() const {
  return _impl_.bio_.Get();
}
inline void ActionConfig_Character::_internal_set_bio(const std::string& value) {
  
  _impl_.bio_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig_Character::_internal_mutable_bio() {
  
  return _impl_.bio_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig_Character::release_bio() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Character.bio)
  return _impl_.bio_.Release();
}
inline void ActionConfig_Character::set_allocated_bio(std::string* bio) {
  if (bio != nullptr) {
    
  } else {
    
  }
  _impl_.bio_.SetAllocated(bio, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bio_.IsDefault()) {
    _impl_.bio_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Character.bio)
}

// -------------------------------------------------------------------

// ActionConfig_Object

// string name = 1;
inline void ActionConfig_Object::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ActionConfig_Object::name() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Object.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig_Object::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Object.name)
}
inline std::string* ActionConfig_Object::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Object.name)
  return _s;
}
inline const std::string& ActionConfig_Object::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ActionConfig_Object::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig_Object::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig_Object::release_name() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Object.name)
  return _impl_.name_.Release();
}
inline void ActionConfig_Object::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Object.name)
}

// string description = 2;
inline void ActionConfig_Object::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ActionConfig_Object::description() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Object.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig_Object::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.Object.description)
}
inline std::string* ActionConfig_Object::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Object.description)
  return _s;
}
inline const std::string& ActionConfig_Object::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ActionConfig_Object::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig_Object::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig_Object::release_description() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Object.description)
  return _impl_.description_.Release();
}
inline void ActionConfig_Object::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Object.description)
}

// -------------------------------------------------------------------

// ActionConfig

// repeated string actions = 1;
inline int ActionConfig::_internal_actions_size() const {
  return _impl_.actions_.size();
}
inline int ActionConfig::actions_size() const {
  return _internal_actions_size();
}
inline void ActionConfig::clear_actions() {
  _impl_.actions_.Clear();
}
inline std::string* ActionConfig::add_actions() {
  std::string* _s = _internal_add_actions();
  // @@protoc_insertion_point(field_add_mutable:service.ActionConfig.actions)
  return _s;
}
inline const std::string& ActionConfig::_internal_actions(int index) const {
  return _impl_.actions_.Get(index);
}
inline const std::string& ActionConfig::actions(int index) const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.actions)
  return _internal_actions(index);
}
inline std::string* ActionConfig::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.actions)
  return _impl_.actions_.Mutable(index);
}
inline void ActionConfig::set_actions(int index, const std::string& value) {
  _impl_.actions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, std::string&& value) {
  _impl_.actions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.actions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, const char* value, size_t size) {
  _impl_.actions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.actions)
}
inline std::string* ActionConfig::_internal_add_actions() {
  return _impl_.actions_.Add();
}
inline void ActionConfig::add_actions(const std::string& value) {
  _impl_.actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(std::string&& value) {
  _impl_.actions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(const char* value, size_t size) {
  _impl_.actions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:service.ActionConfig.actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ActionConfig::actions() const {
  // @@protoc_insertion_point(field_list:service.ActionConfig.actions)
  return _impl_.actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ActionConfig::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.actions)
  return &_impl_.actions_;
}

// repeated .service.ActionConfig.Character characters = 2;
inline int ActionConfig::_internal_characters_size() const {
  return _impl_.characters_.size();
}
inline int ActionConfig::characters_size() const {
  return _internal_characters_size();
}
inline void ActionConfig::clear_characters() {
  _impl_.characters_.Clear();
}
inline ::service::ActionConfig_Character* ActionConfig::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.characters)
  return _impl_.characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >*
ActionConfig::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.characters)
  return &_impl_.characters_;
}
inline const ::service::ActionConfig_Character& ActionConfig::_internal_characters(int index) const {
  return _impl_.characters_.Get(index);
}
inline const ::service::ActionConfig_Character& ActionConfig::characters(int index) const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.characters)
  return _internal_characters(index);
}
inline ::service::ActionConfig_Character* ActionConfig::_internal_add_characters() {
  return _impl_.characters_.Add();
}
inline ::service::ActionConfig_Character* ActionConfig::add_characters() {
  ::service::ActionConfig_Character* _add = _internal_add_characters();
  // @@protoc_insertion_point(field_add:service.ActionConfig.characters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >&
ActionConfig::characters() const {
  // @@protoc_insertion_point(field_list:service.ActionConfig.characters)
  return _impl_.characters_;
}

// repeated .service.ActionConfig.Object objects = 3;
inline int ActionConfig::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int ActionConfig::objects_size() const {
  return _internal_objects_size();
}
inline void ActionConfig::clear_objects() {
  _impl_.objects_.Clear();
}
inline ::service::ActionConfig_Object* ActionConfig::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >*
ActionConfig::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.objects)
  return &_impl_.objects_;
}
inline const ::service::ActionConfig_Object& ActionConfig::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::service::ActionConfig_Object& ActionConfig::objects(int index) const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.objects)
  return _internal_objects(index);
}
inline ::service::ActionConfig_Object* ActionConfig::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::service::ActionConfig_Object* ActionConfig::add_objects() {
  ::service::ActionConfig_Object* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:service.ActionConfig.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >&
ActionConfig::objects() const {
  // @@protoc_insertion_point(field_list:service.ActionConfig.objects)
  return _impl_.objects_;
}

// string classification = 4;
inline void ActionConfig::clear_classification() {
  _impl_.classification_.ClearToEmpty();
}
inline const std::string& ActionConfig::classification() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.classification)
  return _internal_classification();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig::set_classification(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classification_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.classification)
}
inline std::string* ActionConfig::mutable_classification() {
  std::string* _s = _internal_mutable_classification();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.classification)
  return _s;
}
inline const std::string& ActionConfig::_internal_classification() const {
  return _impl_.classification_.Get();
}
inline void ActionConfig::_internal_set_classification(const std::string& value) {
  
  _impl_.classification_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig::_internal_mutable_classification() {
  
  return _impl_.classification_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig::release_classification() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.classification)
  return _impl_.classification_.Release();
}
inline void ActionConfig::set_allocated_classification(std::string* classification) {
  if (classification != nullptr) {
    
  } else {
    
  }
  _impl_.classification_.SetAllocated(classification, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classification_.IsDefault()) {
    _impl_.classification_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.classification)
}

// int32 context_level = 5;
inline void ActionConfig::clear_context_level() {
  _impl_.context_level_ = 0;
}
inline int32_t ActionConfig::_internal_context_level() const {
  return _impl_.context_level_;
}
inline int32_t ActionConfig::context_level() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.context_level)
  return _internal_context_level();
}
inline void ActionConfig::_internal_set_context_level(int32_t value) {
  
  _impl_.context_level_ = value;
}
inline void ActionConfig::set_context_level(int32_t value) {
  _internal_set_context_level(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.context_level)
}

// string current_attention_object = 6;
inline void ActionConfig::clear_current_attention_object() {
  _impl_.current_attention_object_.ClearToEmpty();
}
inline const std::string& ActionConfig::current_attention_object() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.current_attention_object)
  return _internal_current_attention_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionConfig::set_current_attention_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_attention_object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.ActionConfig.current_attention_object)
}
inline std::string* ActionConfig::mutable_current_attention_object() {
  std::string* _s = _internal_mutable_current_attention_object();
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.current_attention_object)
  return _s;
}
inline const std::string& ActionConfig::_internal_current_attention_object() const {
  return _impl_.current_attention_object_.Get();
}
inline void ActionConfig::_internal_set_current_attention_object(const std::string& value) {
  
  _impl_.current_attention_object_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionConfig::_internal_mutable_current_attention_object() {
  
  return _impl_.current_attention_object_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionConfig::release_current_attention_object() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.current_attention_object)
  return _impl_.current_attention_object_.Release();
}
inline void ActionConfig::set_allocated_current_attention_object(std::string* current_attention_object) {
  if (current_attention_object != nullptr) {
    
  } else {
    
  }
  _impl_.current_attention_object_.SetAllocated(current_attention_object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_attention_object_.IsDefault()) {
    _impl_.current_attention_object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.current_attention_object)
}

// -------------------------------------------------------------------

// STTRequest

// .service.AudioConfig audio_config = 1;
inline bool STTRequest::_internal_has_audio_config() const {
  return request_type_case() == kAudioConfig;
}
inline bool STTRequest::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void STTRequest::set_has_audio_config() {
  _impl_._oneof_case_[0] = kAudioConfig;
}
inline void STTRequest::clear_audio_config() {
  if (_internal_has_audio_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.audio_config_;
    }
    clear_has_request_type();
  }
}
inline ::service::AudioConfig* STTRequest::release_audio_config() {
  // @@protoc_insertion_point(field_release:service.STTRequest.audio_config)
  if (_internal_has_audio_config()) {
    clear_has_request_type();
    ::service::AudioConfig* temp = _impl_.request_type_.audio_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.audio_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::AudioConfig& STTRequest::_internal_audio_config() const {
  return _internal_has_audio_config()
      ? *_impl_.request_type_.audio_config_
      : reinterpret_cast< ::service::AudioConfig&>(::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& STTRequest::audio_config() const {
  // @@protoc_insertion_point(field_get:service.STTRequest.audio_config)
  return _internal_audio_config();
}
inline ::service::AudioConfig* STTRequest::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.STTRequest.audio_config)
  if (_internal_has_audio_config()) {
    clear_has_request_type();
    ::service::AudioConfig* temp = _impl_.request_type_.audio_config_;
    _impl_.request_type_.audio_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void STTRequest::unsafe_arena_set_allocated_audio_config(::service::AudioConfig* audio_config) {
  clear_request_type();
  if (audio_config) {
    set_has_audio_config();
    _impl_.request_type_.audio_config_ = audio_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.STTRequest.audio_config)
}
inline ::service::AudioConfig* STTRequest::_internal_mutable_audio_config() {
  if (!_internal_has_audio_config()) {
    clear_request_type();
    set_has_audio_config();
    _impl_.request_type_.audio_config_ = CreateMaybeMessage< ::service::AudioConfig >(GetArenaForAllocation());
  }
  return _impl_.request_type_.audio_config_;
}
inline ::service::AudioConfig* STTRequest::mutable_audio_config() {
  ::service::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:service.STTRequest.audio_config)
  return _msg;
}

// bytes audio_chunk = 2;
inline bool STTRequest::_internal_has_audio_chunk() const {
  return request_type_case() == kAudioChunk;
}
inline bool STTRequest::has_audio_chunk() const {
  return _internal_has_audio_chunk();
}
inline void STTRequest::set_has_audio_chunk() {
  _impl_._oneof_case_[0] = kAudioChunk;
}
inline void STTRequest::clear_audio_chunk() {
  if (_internal_has_audio_chunk()) {
    _impl_.request_type_.audio_chunk_.Destroy();
    clear_has_request_type();
  }
}
inline const std::string& STTRequest::audio_chunk() const {
  // @@protoc_insertion_point(field_get:service.STTRequest.audio_chunk)
  return _internal_audio_chunk();
}
template <typename ArgT0, typename... ArgT>
inline void STTRequest::set_audio_chunk(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitDefault();
  }
  _impl_.request_type_.audio_chunk_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.STTRequest.audio_chunk)
}
inline std::string* STTRequest::mutable_audio_chunk() {
  std::string* _s = _internal_mutable_audio_chunk();
  // @@protoc_insertion_point(field_mutable:service.STTRequest.audio_chunk)
  return _s;
}
inline const std::string& STTRequest::_internal_audio_chunk() const {
  if (_internal_has_audio_chunk()) {
    return _impl_.request_type_.audio_chunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void STTRequest::_internal_set_audio_chunk(const std::string& value) {
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitDefault();
  }
  _impl_.request_type_.audio_chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* STTRequest::_internal_mutable_audio_chunk() {
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitDefault();
  }
  return _impl_.request_type_.audio_chunk_.Mutable(      GetArenaForAllocation());
}
inline std::string* STTRequest::release_audio_chunk() {
  // @@protoc_insertion_point(field_release:service.STTRequest.audio_chunk)
  if (_internal_has_audio_chunk()) {
    clear_has_request_type();
    return _impl_.request_type_.audio_chunk_.Release();
  } else {
    return nullptr;
  }
}
inline void STTRequest::set_allocated_audio_chunk(std::string* audio_chunk) {
  if (has_request_type()) {
    clear_request_type();
  }
  if (audio_chunk != nullptr) {
    set_has_audio_chunk();
    _impl_.request_type_.audio_chunk_.InitAllocated(audio_chunk, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.STTRequest.audio_chunk)
}

inline bool STTRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void STTRequest::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline STTRequest::RequestTypeCase STTRequest::request_type_case() const {
  return STTRequest::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// STTResponse

// string text = 1;
inline void STTResponse::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& STTResponse::text() const {
  // @@protoc_insertion_point(field_get:service.STTResponse.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void STTResponse::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.STTResponse.text)
}
inline std::string* STTResponse::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:service.STTResponse.text)
  return _s;
}
inline const std::string& STTResponse::_internal_text() const {
  return _impl_.text_.Get();
}
inline void STTResponse::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* STTResponse::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* STTResponse::release_text() {
  // @@protoc_insertion_point(field_release:service.STTResponse.text)
  return _impl_.text_.Release();
}
inline void STTResponse::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.STTResponse.text)
}

// -------------------------------------------------------------------

// GetResponseRequest_GetResponseConfig

// string character_id = 2;
inline void GetResponseRequest_GetResponseConfig::clear_character_id() {
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::character_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.character_id)
  return _internal_character_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_character_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.character_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.character_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_character_id() {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.character_id)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_character_id() const {
  return _impl_.character_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_character_id(const std::string& value) {
  
  _impl_.character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_character_id() {
  
  return _impl_.character_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_character_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.character_id)
  return _impl_.character_id_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_character_id(std::string* character_id) {
  if (character_id != nullptr) {
    
  } else {
    
  }
  _impl_.character_id_.SetAllocated(character_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.character_id)
}

// string api_key = 3;
inline void GetResponseRequest_GetResponseConfig::clear_api_key() {
  _impl_.api_key_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::api_key() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.api_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.api_key)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.api_key)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_api_key() const {
  return _impl_.api_key_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_api_key(const std::string& value) {
  
  _impl_.api_key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_api_key() {
  
  return _impl_.api_key_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_api_key() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.api_key)
  return _impl_.api_key_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  _impl_.api_key_.SetAllocated(api_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.api_key_.IsDefault()) {
    _impl_.api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.api_key)
}

// string session_id = 4;
inline void GetResponseRequest_GetResponseConfig::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::session_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.session_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.session_id)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_session_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.session_id)
  return _impl_.session_id_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.session_id)
}

// .service.AudioConfig audio_config = 5;
inline bool GetResponseRequest_GetResponseConfig::_internal_has_audio_config() const {
  return this != internal_default_instance() && _impl_.audio_config_ != nullptr;
}
inline bool GetResponseRequest_GetResponseConfig::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void GetResponseRequest_GetResponseConfig::clear_audio_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_config_ != nullptr) {
    delete _impl_.audio_config_;
  }
  _impl_.audio_config_ = nullptr;
}
inline const ::service::AudioConfig& GetResponseRequest_GetResponseConfig::_internal_audio_config() const {
  const ::service::AudioConfig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::AudioConfig&>(
      ::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& GetResponseRequest_GetResponseConfig::audio_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.audio_config)
  return _internal_audio_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_audio_config(
    ::service::AudioConfig* audio_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = audio_config;
  if (audio_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.audio_config)
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::release_audio_config() {
  
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.audio_config)
  
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_audio_config() {
  
  if (_impl_.audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::AudioConfig>(GetArenaForAllocation());
    _impl_.audio_config_ = p;
  }
  return _impl_.audio_config_;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::mutable_audio_config() {
  ::service::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.audio_config)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_audio_config(::service::AudioConfig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.audio_config)
}

// .service.ActionConfig action_config = 6;
inline bool GetResponseRequest_GetResponseConfig::_internal_has_action_config() const {
  return this != internal_default_instance() && _impl_.action_config_ != nullptr;
}
inline bool GetResponseRequest_GetResponseConfig::has_action_config() const {
  return _internal_has_action_config();
}
inline void GetResponseRequest_GetResponseConfig::clear_action_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.action_config_ != nullptr) {
    delete _impl_.action_config_;
  }
  _impl_.action_config_ = nullptr;
}
inline const ::service::ActionConfig& GetResponseRequest_GetResponseConfig::_internal_action_config() const {
  const ::service::ActionConfig* p = _impl_.action_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::ActionConfig&>(
      ::service::_ActionConfig_default_instance_);
}
inline const ::service::ActionConfig& GetResponseRequest_GetResponseConfig::action_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.action_config)
  return _internal_action_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_action_config(
    ::service::ActionConfig* action_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_config_);
  }
  _impl_.action_config_ = action_config;
  if (action_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.action_config)
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::release_action_config() {
  
  ::service::ActionConfig* temp = _impl_.action_config_;
  _impl_.action_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_action_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.action_config)
  
  ::service::ActionConfig* temp = _impl_.action_config_;
  _impl_.action_config_ = nullptr;
  return temp;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_action_config() {
  
  if (_impl_.action_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::ActionConfig>(GetArenaForAllocation());
    _impl_.action_config_ = p;
  }
  return _impl_.action_config_;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::mutable_action_config() {
  ::service::ActionConfig* _msg = _internal_mutable_action_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.action_config)
  return _msg;
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_action_config(::service::ActionConfig* action_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.action_config_;
  }
  if (action_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action_config);
    if (message_arena != submessage_arena) {
      action_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.action_config_ = action_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.action_config)
}

// string speaker = 7;
inline void GetResponseRequest_GetResponseConfig::clear_speaker() {
  _impl_.speaker_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::speaker() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.speaker)
  return _internal_speaker();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_speaker(ArgT0&& arg0, ArgT... args) {
 
 _impl_.speaker_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.speaker)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_speaker() {
  std::string* _s = _internal_mutable_speaker();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.speaker)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_speaker() const {
  return _impl_.speaker_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_speaker(const std::string& value) {
  
  _impl_.speaker_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_speaker() {
  
  return _impl_.speaker_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_speaker() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.speaker)
  return _impl_.speaker_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_speaker(std::string* speaker) {
  if (speaker != nullptr) {
    
  } else {
    
  }
  _impl_.speaker_.SetAllocated(speaker, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.speaker_.IsDefault()) {
    _impl_.speaker_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.speaker)
}

// string language_code = 8;
inline void GetResponseRequest_GetResponseConfig::clear_language_code() {
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::language_code() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.language_code)
  return _internal_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseRequest_GetResponseConfig::set_language_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.language_code)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_language_code() {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.language_code)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_language_code() const {
  return _impl_.language_code_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_language_code(const std::string& value) {
  
  _impl_.language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_language_code() {
  
  return _impl_.language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_language_code() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.language_code)
  return _impl_.language_code_.Release();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  _impl_.language_code_.SetAllocated(language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_code_.IsDefault()) {
    _impl_.language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.language_code)
}

// -------------------------------------------------------------------

// GetResponseRequest_GetResponseData

// bytes audio_data = 1;
inline bool GetResponseRequest_GetResponseData::_internal_has_audio_data() const {
  return input_type_case() == kAudioData;
}
inline bool GetResponseRequest_GetResponseData::has_audio_data() const {
  return _internal_has_audio_data();
}
inline void GetResponseRequest_GetResponseData::set_has_audio_data() {
  _impl_._oneof_case_[0] = kAudioData;
}
inline void GetResponseRequest_GetResponseData::clear_audio_data() {
  if (_internal_has_audio_data()) {
    _impl_.input_type_.audio_data_.Destroy();
    clear_has_input_type();
  }
}
inline const std::string& GetResponseRequest_GetResponseData::audio_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.audio_data)
  return _internal_audio_data();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseRequest_GetResponseData::set_audio_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitDefault();
  }
  _impl_.input_type_.audio_data_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.audio_data)
}
inline std::string* GetResponseRequest_GetResponseData::mutable_audio_data() {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.audio_data)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseData::_internal_audio_data() const {
  if (_internal_has_audio_data()) {
    return _impl_.input_type_.audio_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseRequest_GetResponseData::_internal_set_audio_data(const std::string& value) {
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitDefault();
  }
  _impl_.input_type_.audio_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseData::_internal_mutable_audio_data() {
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitDefault();
  }
  return _impl_.input_type_.audio_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseData::release_audio_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.audio_data)
  if (_internal_has_audio_data()) {
    clear_has_input_type();
    return _impl_.input_type_.audio_data_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::set_allocated_audio_data(std::string* audio_data) {
  if (has_input_type()) {
    clear_input_type();
  }
  if (audio_data != nullptr) {
    set_has_audio_data();
    _impl_.input_type_.audio_data_.InitAllocated(audio_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseData.audio_data)
}

// string text_data = 2;
inline bool GetResponseRequest_GetResponseData::_internal_has_text_data() const {
  return input_type_case() == kTextData;
}
inline bool GetResponseRequest_GetResponseData::has_text_data() const {
  return _internal_has_text_data();
}
inline void GetResponseRequest_GetResponseData::set_has_text_data() {
  _impl_._oneof_case_[0] = kTextData;
}
inline void GetResponseRequest_GetResponseData::clear_text_data() {
  if (_internal_has_text_data()) {
    _impl_.input_type_.text_data_.Destroy();
    clear_has_input_type();
  }
}
inline const std::string& GetResponseRequest_GetResponseData::text_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.text_data)
  return _internal_text_data();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseRequest_GetResponseData::set_text_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    _impl_.input_type_.text_data_.InitDefault();
  }
  _impl_.input_type_.text_data_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.text_data)
}
inline std::string* GetResponseRequest_GetResponseData::mutable_text_data() {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.text_data)
  return _s;
}
inline const std::string& GetResponseRequest_GetResponseData::_internal_text_data() const {
  if (_internal_has_text_data()) {
    return _impl_.input_type_.text_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseRequest_GetResponseData::_internal_set_text_data(const std::string& value) {
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    _impl_.input_type_.text_data_.InitDefault();
  }
  _impl_.input_type_.text_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseData::_internal_mutable_text_data() {
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    _impl_.input_type_.text_data_.InitDefault();
  }
  return _impl_.input_type_.text_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseRequest_GetResponseData::release_text_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.text_data)
  if (_internal_has_text_data()) {
    clear_has_input_type();
    return _impl_.input_type_.text_data_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::set_allocated_text_data(std::string* text_data) {
  if (has_input_type()) {
    clear_input_type();
  }
  if (text_data != nullptr) {
    set_has_text_data();
    _impl_.input_type_.text_data_.InitAllocated(text_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseData.text_data)
}

// .service.TriggerConfig trigger_data = 3;
inline bool GetResponseRequest_GetResponseData::_internal_has_trigger_data() const {
  return input_type_case() == kTriggerData;
}
inline bool GetResponseRequest_GetResponseData::has_trigger_data() const {
  return _internal_has_trigger_data();
}
inline void GetResponseRequest_GetResponseData::set_has_trigger_data() {
  _impl_._oneof_case_[0] = kTriggerData;
}
inline void GetResponseRequest_GetResponseData::clear_trigger_data() {
  if (_internal_has_trigger_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.input_type_.trigger_data_;
    }
    clear_has_input_type();
  }
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::release_trigger_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.trigger_data)
  if (_internal_has_trigger_data()) {
    clear_has_input_type();
    ::service::TriggerConfig* temp = _impl_.input_type_.trigger_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_type_.trigger_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::TriggerConfig& GetResponseRequest_GetResponseData::_internal_trigger_data() const {
  return _internal_has_trigger_data()
      ? *_impl_.input_type_.trigger_data_
      : reinterpret_cast< ::service::TriggerConfig&>(::service::_TriggerConfig_default_instance_);
}
inline const ::service::TriggerConfig& GetResponseRequest_GetResponseData::trigger_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.trigger_data)
  return _internal_trigger_data();
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::unsafe_arena_release_trigger_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.GetResponseData.trigger_data)
  if (_internal_has_trigger_data()) {
    clear_has_input_type();
    ::service::TriggerConfig* temp = _impl_.input_type_.trigger_data_;
    _impl_.input_type_.trigger_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::unsafe_arena_set_allocated_trigger_data(::service::TriggerConfig* trigger_data) {
  clear_input_type();
  if (trigger_data) {
    set_has_trigger_data();
    _impl_.input_type_.trigger_data_ = trigger_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseData.trigger_data)
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::_internal_mutable_trigger_data() {
  if (!_internal_has_trigger_data()) {
    clear_input_type();
    set_has_trigger_data();
    _impl_.input_type_.trigger_data_ = CreateMaybeMessage< ::service::TriggerConfig >(GetArenaForAllocation());
  }
  return _impl_.input_type_.trigger_data_;
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::mutable_trigger_data() {
  ::service::TriggerConfig* _msg = _internal_mutable_trigger_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.trigger_data)
  return _msg;
}

inline bool GetResponseRequest_GetResponseData::has_input_type() const {
  return input_type_case() != INPUT_TYPE_NOT_SET;
}
inline void GetResponseRequest_GetResponseData::clear_has_input_type() {
  _impl_._oneof_case_[0] = INPUT_TYPE_NOT_SET;
}
inline GetResponseRequest_GetResponseData::InputTypeCase GetResponseRequest_GetResponseData::input_type_case() const {
  return GetResponseRequest_GetResponseData::InputTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseRequest

// .service.GetResponseRequest.GetResponseConfig get_response_config = 1;
inline bool GetResponseRequest::_internal_has_get_response_config() const {
  return request_type_case() == kGetResponseConfig;
}
inline bool GetResponseRequest::has_get_response_config() const {
  return _internal_has_get_response_config();
}
inline void GetResponseRequest::set_has_get_response_config() {
  _impl_._oneof_case_[0] = kGetResponseConfig;
}
inline void GetResponseRequest::clear_get_response_config() {
  if (_internal_has_get_response_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.get_response_config_;
    }
    clear_has_request_type();
  }
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::release_get_response_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.get_response_config)
  if (_internal_has_get_response_config()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseConfig* temp = _impl_.request_type_.get_response_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.get_response_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseRequest_GetResponseConfig& GetResponseRequest::_internal_get_response_config() const {
  return _internal_has_get_response_config()
      ? *_impl_.request_type_.get_response_config_
      : reinterpret_cast< ::service::GetResponseRequest_GetResponseConfig&>(::service::_GetResponseRequest_GetResponseConfig_default_instance_);
}
inline const ::service::GetResponseRequest_GetResponseConfig& GetResponseRequest::get_response_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.get_response_config)
  return _internal_get_response_config();
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::unsafe_arena_release_get_response_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.get_response_config)
  if (_internal_has_get_response_config()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseConfig* temp = _impl_.request_type_.get_response_config_;
    _impl_.request_type_.get_response_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest::unsafe_arena_set_allocated_get_response_config(::service::GetResponseRequest_GetResponseConfig* get_response_config) {
  clear_request_type();
  if (get_response_config) {
    set_has_get_response_config();
    _impl_.request_type_.get_response_config_ = get_response_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.get_response_config)
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::_internal_mutable_get_response_config() {
  if (!_internal_has_get_response_config()) {
    clear_request_type();
    set_has_get_response_config();
    _impl_.request_type_.get_response_config_ = CreateMaybeMessage< ::service::GetResponseRequest_GetResponseConfig >(GetArenaForAllocation());
  }
  return _impl_.request_type_.get_response_config_;
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::mutable_get_response_config() {
  ::service::GetResponseRequest_GetResponseConfig* _msg = _internal_mutable_get_response_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.get_response_config)
  return _msg;
}

// .service.GetResponseRequest.GetResponseData get_response_data = 2;
inline bool GetResponseRequest::_internal_has_get_response_data() const {
  return request_type_case() == kGetResponseData;
}
inline bool GetResponseRequest::has_get_response_data() const {
  return _internal_has_get_response_data();
}
inline void GetResponseRequest::set_has_get_response_data() {
  _impl_._oneof_case_[0] = kGetResponseData;
}
inline void GetResponseRequest::clear_get_response_data() {
  if (_internal_has_get_response_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.get_response_data_;
    }
    clear_has_request_type();
  }
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::release_get_response_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.get_response_data)
  if (_internal_has_get_response_data()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseData* temp = _impl_.request_type_.get_response_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.get_response_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseRequest_GetResponseData& GetResponseRequest::_internal_get_response_data() const {
  return _internal_has_get_response_data()
      ? *_impl_.request_type_.get_response_data_
      : reinterpret_cast< ::service::GetResponseRequest_GetResponseData&>(::service::_GetResponseRequest_GetResponseData_default_instance_);
}
inline const ::service::GetResponseRequest_GetResponseData& GetResponseRequest::get_response_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.get_response_data)
  return _internal_get_response_data();
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::unsafe_arena_release_get_response_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.get_response_data)
  if (_internal_has_get_response_data()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseData* temp = _impl_.request_type_.get_response_data_;
    _impl_.request_type_.get_response_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest::unsafe_arena_set_allocated_get_response_data(::service::GetResponseRequest_GetResponseData* get_response_data) {
  clear_request_type();
  if (get_response_data) {
    set_has_get_response_data();
    _impl_.request_type_.get_response_data_ = get_response_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.get_response_data)
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::_internal_mutable_get_response_data() {
  if (!_internal_has_get_response_data()) {
    clear_request_type();
    set_has_get_response_data();
    _impl_.request_type_.get_response_data_ = CreateMaybeMessage< ::service::GetResponseRequest_GetResponseData >(GetArenaForAllocation());
  }
  return _impl_.request_type_.get_response_data_;
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::mutable_get_response_data() {
  ::service::GetResponseRequest_GetResponseData* _msg = _internal_mutable_get_response_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.get_response_data)
  return _msg;
}

inline bool GetResponseRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void GetResponseRequest::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline GetResponseRequest::RequestTypeCase GetResponseRequest::request_type_case() const {
  return GetResponseRequest::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseRequestSingle

// .service.GetResponseRequest response_config = 1;
inline bool GetResponseRequestSingle::_internal_has_response_config() const {
  return this != internal_default_instance() && _impl_.response_config_ != nullptr;
}
inline bool GetResponseRequestSingle::has_response_config() const {
  return _internal_has_response_config();
}
inline void GetResponseRequestSingle::clear_response_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_config_ != nullptr) {
    delete _impl_.response_config_;
  }
  _impl_.response_config_ = nullptr;
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::_internal_response_config() const {
  const ::service::GetResponseRequest* p = _impl_.response_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::GetResponseRequest&>(
      ::service::_GetResponseRequest_default_instance_);
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::response_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequestSingle.response_config)
  return _internal_response_config();
}
inline void GetResponseRequestSingle::unsafe_arena_set_allocated_response_config(
    ::service::GetResponseRequest* response_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_config_);
  }
  _impl_.response_config_ = response_config;
  if (response_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequestSingle.response_config)
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::release_response_config() {
  
  ::service::GetResponseRequest* temp = _impl_.response_config_;
  _impl_.response_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::unsafe_arena_release_response_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequestSingle.response_config)
  
  ::service::GetResponseRequest* temp = _impl_.response_config_;
  _impl_.response_config_ = nullptr;
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::_internal_mutable_response_config() {
  
  if (_impl_.response_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::GetResponseRequest>(GetArenaForAllocation());
    _impl_.response_config_ = p;
  }
  return _impl_.response_config_;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::mutable_response_config() {
  ::service::GetResponseRequest* _msg = _internal_mutable_response_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequestSingle.response_config)
  return _msg;
}
inline void GetResponseRequestSingle::set_allocated_response_config(::service::GetResponseRequest* response_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_config_;
  }
  if (response_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_config);
    if (message_arena != submessage_arena) {
      response_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_config_ = response_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequestSingle.response_config)
}

// .service.GetResponseRequest response_data = 2;
inline bool GetResponseRequestSingle::_internal_has_response_data() const {
  return this != internal_default_instance() && _impl_.response_data_ != nullptr;
}
inline bool GetResponseRequestSingle::has_response_data() const {
  return _internal_has_response_data();
}
inline void GetResponseRequestSingle::clear_response_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_data_ != nullptr) {
    delete _impl_.response_data_;
  }
  _impl_.response_data_ = nullptr;
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::_internal_response_data() const {
  const ::service::GetResponseRequest* p = _impl_.response_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::GetResponseRequest&>(
      ::service::_GetResponseRequest_default_instance_);
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::response_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequestSingle.response_data)
  return _internal_response_data();
}
inline void GetResponseRequestSingle::unsafe_arena_set_allocated_response_data(
    ::service::GetResponseRequest* response_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_data_);
  }
  _impl_.response_data_ = response_data;
  if (response_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequestSingle.response_data)
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::release_response_data() {
  
  ::service::GetResponseRequest* temp = _impl_.response_data_;
  _impl_.response_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::unsafe_arena_release_response_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequestSingle.response_data)
  
  ::service::GetResponseRequest* temp = _impl_.response_data_;
  _impl_.response_data_ = nullptr;
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::_internal_mutable_response_data() {
  
  if (_impl_.response_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::GetResponseRequest>(GetArenaForAllocation());
    _impl_.response_data_ = p;
  }
  return _impl_.response_data_;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::mutable_response_data() {
  ::service::GetResponseRequest* _msg = _internal_mutable_response_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequestSingle.response_data)
  return _msg;
}
inline void GetResponseRequestSingle::set_allocated_response_data(::service::GetResponseRequest* response_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_data_;
  }
  if (response_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_data);
    if (message_arena != submessage_arena) {
      response_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_data_ = response_data;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequestSingle.response_data)
}

// -------------------------------------------------------------------

// GetResponseResponse_AudioResponse

// bytes audio_data = 1;
inline void GetResponseResponse_AudioResponse::clear_audio_data() {
  _impl_.audio_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::audio_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.audio_data)
  return _internal_audio_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_AudioResponse::set_audio_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.audio_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_audio_data() {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.audio_data)
  return _s;
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_audio_data() const {
  return _impl_.audio_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_audio_data(const std::string& value) {
  
  _impl_.audio_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_audio_data() {
  
  return _impl_.audio_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::release_audio_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.audio_data)
  return _impl_.audio_data_.Release();
}
inline void GetResponseResponse_AudioResponse::set_allocated_audio_data(std::string* audio_data) {
  if (audio_data != nullptr) {
    
  } else {
    
  }
  _impl_.audio_data_.SetAllocated(audio_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_data_.IsDefault()) {
    _impl_.audio_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.audio_data)
}

// .service.AudioConfig audio_config = 2;
inline bool GetResponseResponse_AudioResponse::_internal_has_audio_config() const {
  return this != internal_default_instance() && _impl_.audio_config_ != nullptr;
}
inline bool GetResponseResponse_AudioResponse::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void GetResponseResponse_AudioResponse::clear_audio_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_config_ != nullptr) {
    delete _impl_.audio_config_;
  }
  _impl_.audio_config_ = nullptr;
}
inline const ::service::AudioConfig& GetResponseResponse_AudioResponse::_internal_audio_config() const {
  const ::service::AudioConfig* p = _impl_.audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::AudioConfig&>(
      ::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& GetResponseResponse_AudioResponse::audio_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.audio_config)
  return _internal_audio_config();
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_audio_config(
    ::service::AudioConfig* audio_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_config_);
  }
  _impl_.audio_config_ = audio_config;
  if (audio_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.audio_config)
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::release_audio_config() {
  
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.audio_config)
  
  ::service::AudioConfig* temp = _impl_.audio_config_;
  _impl_.audio_config_ = nullptr;
  return temp;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::_internal_mutable_audio_config() {
  
  if (_impl_.audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::AudioConfig>(GetArenaForAllocation());
    _impl_.audio_config_ = p;
  }
  return _impl_.audio_config_;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::mutable_audio_config() {
  ::service::AudioConfig* _msg = _internal_mutable_audio_config();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.audio_config)
  return _msg;
}
inline void GetResponseResponse_AudioResponse::set_allocated_audio_config(::service::AudioConfig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.audio_config)
}

// string text_data = 3;
inline void GetResponseResponse_AudioResponse::clear_text_data() {
  _impl_.text_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::text_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.text_data)
  return _internal_text_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_AudioResponse::set_text_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.text_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_text_data() {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.text_data)
  return _s;
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_text_data() const {
  return _impl_.text_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_text_data(const std::string& value) {
  
  _impl_.text_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_text_data() {
  
  return _impl_.text_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::release_text_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.text_data)
  return _impl_.text_data_.Release();
}
inline void GetResponseResponse_AudioResponse::set_allocated_text_data(std::string* text_data) {
  if (text_data != nullptr) {
    
  } else {
    
  }
  _impl_.text_data_.SetAllocated(text_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_data_.IsDefault()) {
    _impl_.text_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.text_data)
}

// bool end_of_response = 4;
inline void GetResponseResponse_AudioResponse::clear_end_of_response() {
  _impl_.end_of_response_ = false;
}
inline bool GetResponseResponse_AudioResponse::_internal_end_of_response() const {
  return _impl_.end_of_response_;
}
inline bool GetResponseResponse_AudioResponse::end_of_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.end_of_response)
  return _internal_end_of_response();
}
inline void GetResponseResponse_AudioResponse::_internal_set_end_of_response(bool value) {
  
  _impl_.end_of_response_ = value;
}
inline void GetResponseResponse_AudioResponse::set_end_of_response(bool value) {
  _internal_set_end_of_response(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.end_of_response)
}

// string face_data = 5;
inline void GetResponseResponse_AudioResponse::clear_face_data() {
  _impl_.face_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::face_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.face_data)
  return _internal_face_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_AudioResponse::set_face_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.face_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.face_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_face_data() {
  std::string* _s = _internal_mutable_face_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.face_data)
  return _s;
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_face_data() const {
  return _impl_.face_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_face_data(const std::string& value) {
  
  _impl_.face_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_face_data() {
  
  return _impl_.face_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_AudioResponse::release_face_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.face_data)
  return _impl_.face_data_.Release();
}
inline void GetResponseResponse_AudioResponse::set_allocated_face_data(std::string* face_data) {
  if (face_data != nullptr) {
    
  } else {
    
  }
  _impl_.face_data_.SetAllocated(face_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.face_data_.IsDefault()) {
    _impl_.face_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.face_data)
}

// .service.VisemesData visemes_data = 6;
inline bool GetResponseResponse_AudioResponse::_internal_has_visemes_data() const {
  return face_data_type_case() == kVisemesData;
}
inline bool GetResponseResponse_AudioResponse::has_visemes_data() const {
  return _internal_has_visemes_data();
}
inline void GetResponseResponse_AudioResponse::set_has_visemes_data() {
  _impl_._oneof_case_[0] = kVisemesData;
}
inline void GetResponseResponse_AudioResponse::clear_visemes_data() {
  if (_internal_has_visemes_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.face_data_type_.visemes_data_;
    }
    clear_has_face_data_type();
  }
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::release_visemes_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.visemes_data)
  if (_internal_has_visemes_data()) {
    clear_has_face_data_type();
    ::service::VisemesData* temp = _impl_.face_data_type_.visemes_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.face_data_type_.visemes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::VisemesData& GetResponseResponse_AudioResponse::_internal_visemes_data() const {
  return _internal_has_visemes_data()
      ? *_impl_.face_data_type_.visemes_data_
      : reinterpret_cast< ::service::VisemesData&>(::service::_VisemesData_default_instance_);
}
inline const ::service::VisemesData& GetResponseResponse_AudioResponse::visemes_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.visemes_data)
  return _internal_visemes_data();
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::unsafe_arena_release_visemes_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.AudioResponse.visemes_data)
  if (_internal_has_visemes_data()) {
    clear_has_face_data_type();
    ::service::VisemesData* temp = _impl_.face_data_type_.visemes_data_;
    _impl_.face_data_type_.visemes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_visemes_data(::service::VisemesData* visemes_data) {
  clear_face_data_type();
  if (visemes_data) {
    set_has_visemes_data();
    _impl_.face_data_type_.visemes_data_ = visemes_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.visemes_data)
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::_internal_mutable_visemes_data() {
  if (!_internal_has_visemes_data()) {
    clear_face_data_type();
    set_has_visemes_data();
    _impl_.face_data_type_.visemes_data_ = CreateMaybeMessage< ::service::VisemesData >(GetArenaForAllocation());
  }
  return _impl_.face_data_type_.visemes_data_;
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::mutable_visemes_data() {
  ::service::VisemesData* _msg = _internal_mutable_visemes_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.visemes_data)
  return _msg;
}

// .service.BlendShapesData blendshapes_data = 7;
inline bool GetResponseResponse_AudioResponse::_internal_has_blendshapes_data() const {
  return face_data_type_case() == kBlendshapesData;
}
inline bool GetResponseResponse_AudioResponse::has_blendshapes_data() const {
  return _internal_has_blendshapes_data();
}
inline void GetResponseResponse_AudioResponse::set_has_blendshapes_data() {
  _impl_._oneof_case_[0] = kBlendshapesData;
}
inline void GetResponseResponse_AudioResponse::clear_blendshapes_data() {
  if (_internal_has_blendshapes_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.face_data_type_.blendshapes_data_;
    }
    clear_has_face_data_type();
  }
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::release_blendshapes_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.blendshapes_data)
  if (_internal_has_blendshapes_data()) {
    clear_has_face_data_type();
    ::service::BlendShapesData* temp = _impl_.face_data_type_.blendshapes_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.face_data_type_.blendshapes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::BlendShapesData& GetResponseResponse_AudioResponse::_internal_blendshapes_data() const {
  return _internal_has_blendshapes_data()
      ? *_impl_.face_data_type_.blendshapes_data_
      : reinterpret_cast< ::service::BlendShapesData&>(::service::_BlendShapesData_default_instance_);
}
inline const ::service::BlendShapesData& GetResponseResponse_AudioResponse::blendshapes_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.blendshapes_data)
  return _internal_blendshapes_data();
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::unsafe_arena_release_blendshapes_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.AudioResponse.blendshapes_data)
  if (_internal_has_blendshapes_data()) {
    clear_has_face_data_type();
    ::service::BlendShapesData* temp = _impl_.face_data_type_.blendshapes_data_;
    _impl_.face_data_type_.blendshapes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_blendshapes_data(::service::BlendShapesData* blendshapes_data) {
  clear_face_data_type();
  if (blendshapes_data) {
    set_has_blendshapes_data();
    _impl_.face_data_type_.blendshapes_data_ = blendshapes_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.blendshapes_data)
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::_internal_mutable_blendshapes_data() {
  if (!_internal_has_blendshapes_data()) {
    clear_face_data_type();
    set_has_blendshapes_data();
    _impl_.face_data_type_.blendshapes_data_ = CreateMaybeMessage< ::service::BlendShapesData >(GetArenaForAllocation());
  }
  return _impl_.face_data_type_.blendshapes_data_;
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::mutable_blendshapes_data() {
  ::service::BlendShapesData* _msg = _internal_mutable_blendshapes_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.blendshapes_data)
  return _msg;
}

inline bool GetResponseResponse_AudioResponse::has_face_data_type() const {
  return face_data_type_case() != FACE_DATA_TYPE_NOT_SET;
}
inline void GetResponseResponse_AudioResponse::clear_has_face_data_type() {
  _impl_._oneof_case_[0] = FACE_DATA_TYPE_NOT_SET;
}
inline GetResponseResponse_AudioResponse::FaceDataTypeCase GetResponseResponse_AudioResponse::face_data_type_case() const {
  return GetResponseResponse_AudioResponse::FaceDataTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseResponse_ActionResponse

// string action = 1;
inline void GetResponseResponse_ActionResponse::clear_action() {
  _impl_.action_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_ActionResponse::action() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.ActionResponse.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_ActionResponse::set_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.ActionResponse.action)
}
inline std::string* GetResponseResponse_ActionResponse::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.ActionResponse.action)
  return _s;
}
inline const std::string& GetResponseResponse_ActionResponse::_internal_action() const {
  return _impl_.action_.Get();
}
inline void GetResponseResponse_ActionResponse::_internal_set_action(const std::string& value) {
  
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_ActionResponse::_internal_mutable_action() {
  
  return _impl_.action_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_ActionResponse::release_action() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.ActionResponse.action)
  return _impl_.action_.Release();
}
inline void GetResponseResponse_ActionResponse::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  _impl_.action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.ActionResponse.action)
}

// -------------------------------------------------------------------

// GetResponseResponse_BehaviorTreeResponse

// string bt_code = 1;
inline void GetResponseResponse_BehaviorTreeResponse::clear_bt_code() {
  _impl_.bt_code_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::bt_code() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _internal_bt_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_BehaviorTreeResponse::set_bt_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bt_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_bt_code() {
  std::string* _s = _internal_mutable_bt_code();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _s;
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_bt_code() const {
  return _impl_.bt_code_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_bt_code(const std::string& value) {
  
  _impl_.bt_code_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_bt_code() {
  
  return _impl_.bt_code_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_bt_code() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _impl_.bt_code_.Release();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_bt_code(std::string* bt_code) {
  if (bt_code != nullptr) {
    
  } else {
    
  }
  _impl_.bt_code_.SetAllocated(bt_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bt_code_.IsDefault()) {
    _impl_.bt_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}

// string bt_constants = 2;
inline void GetResponseResponse_BehaviorTreeResponse::clear_bt_constants() {
  _impl_.bt_constants_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::bt_constants() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _internal_bt_constants();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_BehaviorTreeResponse::set_bt_constants(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bt_constants_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_bt_constants() {
  std::string* _s = _internal_mutable_bt_constants();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _s;
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_bt_constants() const {
  return _impl_.bt_constants_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_bt_constants(const std::string& value) {
  
  _impl_.bt_constants_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_bt_constants() {
  
  return _impl_.bt_constants_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_bt_constants() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _impl_.bt_constants_.Release();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_bt_constants(std::string* bt_constants) {
  if (bt_constants != nullptr) {
    
  } else {
    
  }
  _impl_.bt_constants_.SetAllocated(bt_constants, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bt_constants_.IsDefault()) {
    _impl_.bt_constants_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}

// string narrative_section_id = 3;
inline void GetResponseResponse_BehaviorTreeResponse::clear_narrative_section_id() {
  _impl_.narrative_section_id_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::narrative_section_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _internal_narrative_section_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_BehaviorTreeResponse::set_narrative_section_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.narrative_section_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_narrative_section_id() {
  std::string* _s = _internal_mutable_narrative_section_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _s;
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_narrative_section_id() const {
  return _impl_.narrative_section_id_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_narrative_section_id(const std::string& value) {
  
  _impl_.narrative_section_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_narrative_section_id() {
  
  return _impl_.narrative_section_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_narrative_section_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _impl_.narrative_section_id_.Release();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_narrative_section_id(std::string* narrative_section_id) {
  if (narrative_section_id != nullptr) {
    
  } else {
    
  }
  _impl_.narrative_section_id_.SetAllocated(narrative_section_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.narrative_section_id_.IsDefault()) {
    _impl_.narrative_section_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}

// -------------------------------------------------------------------

// GetResponseResponse_UserTranscript

// string text_data = 1;
inline void GetResponseResponse_UserTranscript::clear_text_data() {
  _impl_.text_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_UserTranscript::text_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.text_data)
  return _internal_text_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse_UserTranscript::set_text_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.text_data)
}
inline std::string* GetResponseResponse_UserTranscript::mutable_text_data() {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.UserTranscript.text_data)
  return _s;
}
inline const std::string& GetResponseResponse_UserTranscript::_internal_text_data() const {
  return _impl_.text_data_.Get();
}
inline void GetResponseResponse_UserTranscript::_internal_set_text_data(const std::string& value) {
  
  _impl_.text_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse_UserTranscript::_internal_mutable_text_data() {
  
  return _impl_.text_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse_UserTranscript::release_text_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.UserTranscript.text_data)
  return _impl_.text_data_.Release();
}
inline void GetResponseResponse_UserTranscript::set_allocated_text_data(std::string* text_data) {
  if (text_data != nullptr) {
    
  } else {
    
  }
  _impl_.text_data_.SetAllocated(text_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_data_.IsDefault()) {
    _impl_.text_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.UserTranscript.text_data)
}

// bool is_final = 2;
inline void GetResponseResponse_UserTranscript::clear_is_final() {
  _impl_.is_final_ = false;
}
inline bool GetResponseResponse_UserTranscript::_internal_is_final() const {
  return _impl_.is_final_;
}
inline bool GetResponseResponse_UserTranscript::is_final() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.is_final)
  return _internal_is_final();
}
inline void GetResponseResponse_UserTranscript::_internal_set_is_final(bool value) {
  
  _impl_.is_final_ = value;
}
inline void GetResponseResponse_UserTranscript::set_is_final(bool value) {
  _internal_set_is_final(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.is_final)
}

// bool end_of_response = 3;
inline void GetResponseResponse_UserTranscript::clear_end_of_response() {
  _impl_.end_of_response_ = false;
}
inline bool GetResponseResponse_UserTranscript::_internal_end_of_response() const {
  return _impl_.end_of_response_;
}
inline bool GetResponseResponse_UserTranscript::end_of_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.end_of_response)
  return _internal_end_of_response();
}
inline void GetResponseResponse_UserTranscript::_internal_set_end_of_response(bool value) {
  
  _impl_.end_of_response_ = value;
}
inline void GetResponseResponse_UserTranscript::set_end_of_response(bool value) {
  _internal_set_end_of_response(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.end_of_response)
}

// -------------------------------------------------------------------

// GetResponseResponse

// string session_id = 1;
inline void GetResponseResponse::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& GetResponseResponse::session_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponseResponse::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.session_id)
}
inline std::string* GetResponseResponse::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.session_id)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void GetResponseResponse::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponseResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void GetResponseResponse::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.session_id)
}

// .service.GetResponseResponse.ActionResponse action_response = 2;
inline bool GetResponseResponse::_internal_has_action_response() const {
  return response_type_case() == kActionResponse;
}
inline bool GetResponseResponse::has_action_response() const {
  return _internal_has_action_response();
}
inline void GetResponseResponse::set_has_action_response() {
  _impl_._oneof_case_[0] = kActionResponse;
}
inline void GetResponseResponse::clear_action_response() {
  if (_internal_has_action_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.action_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::release_action_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.action_response)
  if (_internal_has_action_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_ActionResponse* temp = _impl_.response_type_.action_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_ActionResponse& GetResponseResponse::_internal_action_response() const {
  return _internal_has_action_response()
      ? *_impl_.response_type_.action_response_
      : reinterpret_cast< ::service::GetResponseResponse_ActionResponse&>(::service::_GetResponseResponse_ActionResponse_default_instance_);
}
inline const ::service::GetResponseResponse_ActionResponse& GetResponseResponse::action_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.action_response)
  return _internal_action_response();
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::unsafe_arena_release_action_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.action_response)
  if (_internal_has_action_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_ActionResponse* temp = _impl_.response_type_.action_response_;
    _impl_.response_type_.action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_action_response(::service::GetResponseResponse_ActionResponse* action_response) {
  clear_response_type();
  if (action_response) {
    set_has_action_response();
    _impl_.response_type_.action_response_ = action_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.action_response)
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::_internal_mutable_action_response() {
  if (!_internal_has_action_response()) {
    clear_response_type();
    set_has_action_response();
    _impl_.response_type_.action_response_ = CreateMaybeMessage< ::service::GetResponseResponse_ActionResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.action_response_;
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::mutable_action_response() {
  ::service::GetResponseResponse_ActionResponse* _msg = _internal_mutable_action_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.action_response)
  return _msg;
}

// .service.GetResponseResponse.AudioResponse audio_response = 3;
inline bool GetResponseResponse::_internal_has_audio_response() const {
  return response_type_case() == kAudioResponse;
}
inline bool GetResponseResponse::has_audio_response() const {
  return _internal_has_audio_response();
}
inline void GetResponseResponse::set_has_audio_response() {
  _impl_._oneof_case_[0] = kAudioResponse;
}
inline void GetResponseResponse::clear_audio_response() {
  if (_internal_has_audio_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.audio_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::release_audio_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.audio_response)
  if (_internal_has_audio_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_AudioResponse* temp = _impl_.response_type_.audio_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.audio_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_AudioResponse& GetResponseResponse::_internal_audio_response() const {
  return _internal_has_audio_response()
      ? *_impl_.response_type_.audio_response_
      : reinterpret_cast< ::service::GetResponseResponse_AudioResponse&>(::service::_GetResponseResponse_AudioResponse_default_instance_);
}
inline const ::service::GetResponseResponse_AudioResponse& GetResponseResponse::audio_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.audio_response)
  return _internal_audio_response();
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::unsafe_arena_release_audio_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.audio_response)
  if (_internal_has_audio_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_AudioResponse* temp = _impl_.response_type_.audio_response_;
    _impl_.response_type_.audio_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_audio_response(::service::GetResponseResponse_AudioResponse* audio_response) {
  clear_response_type();
  if (audio_response) {
    set_has_audio_response();
    _impl_.response_type_.audio_response_ = audio_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.audio_response)
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::_internal_mutable_audio_response() {
  if (!_internal_has_audio_response()) {
    clear_response_type();
    set_has_audio_response();
    _impl_.response_type_.audio_response_ = CreateMaybeMessage< ::service::GetResponseResponse_AudioResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.audio_response_;
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::mutable_audio_response() {
  ::service::GetResponseResponse_AudioResponse* _msg = _internal_mutable_audio_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.audio_response)
  return _msg;
}

// string debug_log = 4;
inline bool GetResponseResponse::_internal_has_debug_log() const {
  return response_type_case() == kDebugLog;
}
inline bool GetResponseResponse::has_debug_log() const {
  return _internal_has_debug_log();
}
inline void GetResponseResponse::set_has_debug_log() {
  _impl_._oneof_case_[0] = kDebugLog;
}
inline void GetResponseResponse::clear_debug_log() {
  if (_internal_has_debug_log()) {
    _impl_.response_type_.debug_log_.Destroy();
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::debug_log() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.debug_log)
  return _internal_debug_log();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseResponse::set_debug_log(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitDefault();
  }
  _impl_.response_type_.debug_log_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.debug_log)
}
inline std::string* GetResponseResponse::mutable_debug_log() {
  std::string* _s = _internal_mutable_debug_log();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.debug_log)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_debug_log() const {
  if (_internal_has_debug_log()) {
    return _impl_.response_type_.debug_log_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseResponse::_internal_set_debug_log(const std::string& value) {
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitDefault();
  }
  _impl_.response_type_.debug_log_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse::_internal_mutable_debug_log() {
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitDefault();
  }
  return _impl_.response_type_.debug_log_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseResponse::release_debug_log() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.debug_log)
  if (_internal_has_debug_log()) {
    clear_has_response_type();
    return _impl_.response_type_.debug_log_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::set_allocated_debug_log(std::string* debug_log) {
  if (has_response_type()) {
    clear_response_type();
  }
  if (debug_log != nullptr) {
    set_has_debug_log();
    _impl_.response_type_.debug_log_.InitAllocated(debug_log, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.debug_log)
}

// .service.GetResponseResponse.UserTranscript user_query = 5;
inline bool GetResponseResponse::_internal_has_user_query() const {
  return response_type_case() == kUserQuery;
}
inline bool GetResponseResponse::has_user_query() const {
  return _internal_has_user_query();
}
inline void GetResponseResponse::set_has_user_query() {
  _impl_._oneof_case_[0] = kUserQuery;
}
inline void GetResponseResponse::clear_user_query() {
  if (_internal_has_user_query()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.user_query_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::release_user_query() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.user_query)
  if (_internal_has_user_query()) {
    clear_has_response_type();
    ::service::GetResponseResponse_UserTranscript* temp = _impl_.response_type_.user_query_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.user_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_UserTranscript& GetResponseResponse::_internal_user_query() const {
  return _internal_has_user_query()
      ? *_impl_.response_type_.user_query_
      : reinterpret_cast< ::service::GetResponseResponse_UserTranscript&>(::service::_GetResponseResponse_UserTranscript_default_instance_);
}
inline const ::service::GetResponseResponse_UserTranscript& GetResponseResponse::user_query() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.user_query)
  return _internal_user_query();
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::unsafe_arena_release_user_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.user_query)
  if (_internal_has_user_query()) {
    clear_has_response_type();
    ::service::GetResponseResponse_UserTranscript* temp = _impl_.response_type_.user_query_;
    _impl_.response_type_.user_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_user_query(::service::GetResponseResponse_UserTranscript* user_query) {
  clear_response_type();
  if (user_query) {
    set_has_user_query();
    _impl_.response_type_.user_query_ = user_query;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.user_query)
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::_internal_mutable_user_query() {
  if (!_internal_has_user_query()) {
    clear_response_type();
    set_has_user_query();
    _impl_.response_type_.user_query_ = CreateMaybeMessage< ::service::GetResponseResponse_UserTranscript >(GetArenaForAllocation());
  }
  return _impl_.response_type_.user_query_;
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::mutable_user_query() {
  ::service::GetResponseResponse_UserTranscript* _msg = _internal_mutable_user_query();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.user_query)
  return _msg;
}

// .service.GetResponseResponse.BehaviorTreeResponse bt_response = 6;
inline bool GetResponseResponse::_internal_has_bt_response() const {
  return response_type_case() == kBtResponse;
}
inline bool GetResponseResponse::has_bt_response() const {
  return _internal_has_bt_response();
}
inline void GetResponseResponse::set_has_bt_response() {
  _impl_._oneof_case_[0] = kBtResponse;
}
inline void GetResponseResponse::clear_bt_response() {
  if (_internal_has_bt_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.bt_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::release_bt_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.bt_response)
  if (_internal_has_bt_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_BehaviorTreeResponse* temp = _impl_.response_type_.bt_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.bt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_BehaviorTreeResponse& GetResponseResponse::_internal_bt_response() const {
  return _internal_has_bt_response()
      ? *_impl_.response_type_.bt_response_
      : reinterpret_cast< ::service::GetResponseResponse_BehaviorTreeResponse&>(::service::_GetResponseResponse_BehaviorTreeResponse_default_instance_);
}
inline const ::service::GetResponseResponse_BehaviorTreeResponse& GetResponseResponse::bt_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.bt_response)
  return _internal_bt_response();
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::unsafe_arena_release_bt_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.bt_response)
  if (_internal_has_bt_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_BehaviorTreeResponse* temp = _impl_.response_type_.bt_response_;
    _impl_.response_type_.bt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_bt_response(::service::GetResponseResponse_BehaviorTreeResponse* bt_response) {
  clear_response_type();
  if (bt_response) {
    set_has_bt_response();
    _impl_.response_type_.bt_response_ = bt_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.bt_response)
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::_internal_mutable_bt_response() {
  if (!_internal_has_bt_response()) {
    clear_response_type();
    set_has_bt_response();
    _impl_.response_type_.bt_response_ = CreateMaybeMessage< ::service::GetResponseResponse_BehaviorTreeResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.bt_response_;
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::mutable_bt_response() {
  ::service::GetResponseResponse_BehaviorTreeResponse* _msg = _internal_mutable_bt_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.bt_response)
  return _msg;
}

// string emotion_response = 7;
inline bool GetResponseResponse::_internal_has_emotion_response() const {
  return response_type_case() == kEmotionResponse;
}
inline bool GetResponseResponse::has_emotion_response() const {
  return _internal_has_emotion_response();
}
inline void GetResponseResponse::set_has_emotion_response() {
  _impl_._oneof_case_[0] = kEmotionResponse;
}
inline void GetResponseResponse::clear_emotion_response() {
  if (_internal_has_emotion_response()) {
    _impl_.response_type_.emotion_response_.Destroy();
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::emotion_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.emotion_response)
  return _internal_emotion_response();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseResponse::set_emotion_response(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitDefault();
  }
  _impl_.response_type_.emotion_response_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.emotion_response)
}
inline std::string* GetResponseResponse::mutable_emotion_response() {
  std::string* _s = _internal_mutable_emotion_response();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.emotion_response)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_emotion_response() const {
  if (_internal_has_emotion_response()) {
    return _impl_.response_type_.emotion_response_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseResponse::_internal_set_emotion_response(const std::string& value) {
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitDefault();
  }
  _impl_.response_type_.emotion_response_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse::_internal_mutable_emotion_response() {
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitDefault();
  }
  return _impl_.response_type_.emotion_response_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseResponse::release_emotion_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.emotion_response)
  if (_internal_has_emotion_response()) {
    clear_has_response_type();
    return _impl_.response_type_.emotion_response_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::set_allocated_emotion_response(std::string* emotion_response) {
  if (has_response_type()) {
    clear_response_type();
  }
  if (emotion_response != nullptr) {
    set_has_emotion_response();
    _impl_.response_type_.emotion_response_.InitAllocated(emotion_response, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.emotion_response)
}

// string interaction_id = 8;
inline bool GetResponseResponse::_internal_has_interaction_id() const {
  return response_type_case() == kInteractionId;
}
inline bool GetResponseResponse::has_interaction_id() const {
  return _internal_has_interaction_id();
}
inline void GetResponseResponse::set_has_interaction_id() {
  _impl_._oneof_case_[0] = kInteractionId;
}
inline void GetResponseResponse::clear_interaction_id() {
  if (_internal_has_interaction_id()) {
    _impl_.response_type_.interaction_id_.Destroy();
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::interaction_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline void GetResponseResponse::set_interaction_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitDefault();
  }
  _impl_.response_type_.interaction_id_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.interaction_id)
}
inline std::string* GetResponseResponse::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.interaction_id)
  return _s;
}
inline const std::string& GetResponseResponse::_internal_interaction_id() const {
  if (_internal_has_interaction_id()) {
    return _impl_.response_type_.interaction_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseResponse::_internal_set_interaction_id(const std::string& value) {
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitDefault();
  }
  _impl_.response_type_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponseResponse::_internal_mutable_interaction_id() {
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitDefault();
  }
  return _impl_.response_type_.interaction_id_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetResponseResponse::release_interaction_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.interaction_id)
  if (_internal_has_interaction_id()) {
    clear_has_response_type();
    return _impl_.response_type_.interaction_id_.Release();
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::set_allocated_interaction_id(std::string* interaction_id) {
  if (has_response_type()) {
    clear_response_type();
  }
  if (interaction_id != nullptr) {
    set_has_interaction_id();
    _impl_.response_type_.interaction_id_.InitAllocated(interaction_id, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.interaction_id)
}

inline bool GetResponseResponse::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void GetResponseResponse::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline GetResponseResponse::ResponseTypeCase GetResponseResponse::response_type_case() const {
  return GetResponseResponse::ResponseTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VisemesData

// .service.Viseme visemes = 1;
inline bool VisemesData::_internal_has_visemes() const {
  return this != internal_default_instance() && _impl_.visemes_ != nullptr;
}
inline bool VisemesData::has_visemes() const {
  return _internal_has_visemes();
}
inline void VisemesData::clear_visemes() {
  if (GetArenaForAllocation() == nullptr && _impl_.visemes_ != nullptr) {
    delete _impl_.visemes_;
  }
  _impl_.visemes_ = nullptr;
}
inline const ::service::Viseme& VisemesData::_internal_visemes() const {
  const ::service::Viseme* p = _impl_.visemes_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::Viseme&>(
      ::service::_Viseme_default_instance_);
}
inline const ::service::Viseme& VisemesData::visemes() const {
  // @@protoc_insertion_point(field_get:service.VisemesData.visemes)
  return _internal_visemes();
}
inline void VisemesData::unsafe_arena_set_allocated_visemes(
    ::service::Viseme* visemes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.visemes_);
  }
  _impl_.visemes_ = visemes;
  if (visemes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.VisemesData.visemes)
}
inline ::service::Viseme* VisemesData::release_visemes() {
  
  ::service::Viseme* temp = _impl_.visemes_;
  _impl_.visemes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::Viseme* VisemesData::unsafe_arena_release_visemes() {
  // @@protoc_insertion_point(field_release:service.VisemesData.visemes)
  
  ::service::Viseme* temp = _impl_.visemes_;
  _impl_.visemes_ = nullptr;
  return temp;
}
inline ::service::Viseme* VisemesData::_internal_mutable_visemes() {
  
  if (_impl_.visemes_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::Viseme>(GetArenaForAllocation());
    _impl_.visemes_ = p;
  }
  return _impl_.visemes_;
}
inline ::service::Viseme* VisemesData::mutable_visemes() {
  ::service::Viseme* _msg = _internal_mutable_visemes();
  // @@protoc_insertion_point(field_mutable:service.VisemesData.visemes)
  return _msg;
}
inline void VisemesData::set_allocated_visemes(::service::Viseme* visemes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.visemes_;
  }
  if (visemes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visemes);
    if (message_arena != submessage_arena) {
      visemes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visemes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.visemes_ = visemes;
  // @@protoc_insertion_point(field_set_allocated:service.VisemesData.visemes)
}

// -------------------------------------------------------------------

// Viseme

// float sil = 1;
inline void Viseme::clear_sil() {
  _impl_.sil_ = 0;
}
inline float Viseme::_internal_sil() const {
  return _impl_.sil_;
}
inline float Viseme::sil() const {
  // @@protoc_insertion_point(field_get:service.Viseme.sil)
  return _internal_sil();
}
inline void Viseme::_internal_set_sil(float value) {
  
  _impl_.sil_ = value;
}
inline void Viseme::set_sil(float value) {
  _internal_set_sil(value);
  // @@protoc_insertion_point(field_set:service.Viseme.sil)
}

// float pp = 2;
inline void Viseme::clear_pp() {
  _impl_.pp_ = 0;
}
inline float Viseme::_internal_pp() const {
  return _impl_.pp_;
}
inline float Viseme::pp() const {
  // @@protoc_insertion_point(field_get:service.Viseme.pp)
  return _internal_pp();
}
inline void Viseme::_internal_set_pp(float value) {
  
  _impl_.pp_ = value;
}
inline void Viseme::set_pp(float value) {
  _internal_set_pp(value);
  // @@protoc_insertion_point(field_set:service.Viseme.pp)
}

// float ff = 3;
inline void Viseme::clear_ff() {
  _impl_.ff_ = 0;
}
inline float Viseme::_internal_ff() const {
  return _impl_.ff_;
}
inline float Viseme::ff() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ff)
  return _internal_ff();
}
inline void Viseme::_internal_set_ff(float value) {
  
  _impl_.ff_ = value;
}
inline void Viseme::set_ff(float value) {
  _internal_set_ff(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ff)
}

// float th = 4;
inline void Viseme::clear_th() {
  _impl_.th_ = 0;
}
inline float Viseme::_internal_th() const {
  return _impl_.th_;
}
inline float Viseme::th() const {
  // @@protoc_insertion_point(field_get:service.Viseme.th)
  return _internal_th();
}
inline void Viseme::_internal_set_th(float value) {
  
  _impl_.th_ = value;
}
inline void Viseme::set_th(float value) {
  _internal_set_th(value);
  // @@protoc_insertion_point(field_set:service.Viseme.th)
}

// float dd = 5;
inline void Viseme::clear_dd() {
  _impl_.dd_ = 0;
}
inline float Viseme::_internal_dd() const {
  return _impl_.dd_;
}
inline float Viseme::dd() const {
  // @@protoc_insertion_point(field_get:service.Viseme.dd)
  return _internal_dd();
}
inline void Viseme::_internal_set_dd(float value) {
  
  _impl_.dd_ = value;
}
inline void Viseme::set_dd(float value) {
  _internal_set_dd(value);
  // @@protoc_insertion_point(field_set:service.Viseme.dd)
}

// float kk = 6;
inline void Viseme::clear_kk() {
  _impl_.kk_ = 0;
}
inline float Viseme::_internal_kk() const {
  return _impl_.kk_;
}
inline float Viseme::kk() const {
  // @@protoc_insertion_point(field_get:service.Viseme.kk)
  return _internal_kk();
}
inline void Viseme::_internal_set_kk(float value) {
  
  _impl_.kk_ = value;
}
inline void Viseme::set_kk(float value) {
  _internal_set_kk(value);
  // @@protoc_insertion_point(field_set:service.Viseme.kk)
}

// float ch = 7;
inline void Viseme::clear_ch() {
  _impl_.ch_ = 0;
}
inline float Viseme::_internal_ch() const {
  return _impl_.ch_;
}
inline float Viseme::ch() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ch)
  return _internal_ch();
}
inline void Viseme::_internal_set_ch(float value) {
  
  _impl_.ch_ = value;
}
inline void Viseme::set_ch(float value) {
  _internal_set_ch(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ch)
}

// float ss = 8;
inline void Viseme::clear_ss() {
  _impl_.ss_ = 0;
}
inline float Viseme::_internal_ss() const {
  return _impl_.ss_;
}
inline float Viseme::ss() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ss)
  return _internal_ss();
}
inline void Viseme::_internal_set_ss(float value) {
  
  _impl_.ss_ = value;
}
inline void Viseme::set_ss(float value) {
  _internal_set_ss(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ss)
}

// float nn = 9;
inline void Viseme::clear_nn() {
  _impl_.nn_ = 0;
}
inline float Viseme::_internal_nn() const {
  return _impl_.nn_;
}
inline float Viseme::nn() const {
  // @@protoc_insertion_point(field_get:service.Viseme.nn)
  return _internal_nn();
}
inline void Viseme::_internal_set_nn(float value) {
  
  _impl_.nn_ = value;
}
inline void Viseme::set_nn(float value) {
  _internal_set_nn(value);
  // @@protoc_insertion_point(field_set:service.Viseme.nn)
}

// float rr = 10;
inline void Viseme::clear_rr() {
  _impl_.rr_ = 0;
}
inline float Viseme::_internal_rr() const {
  return _impl_.rr_;
}
inline float Viseme::rr() const {
  // @@protoc_insertion_point(field_get:service.Viseme.rr)
  return _internal_rr();
}
inline void Viseme::_internal_set_rr(float value) {
  
  _impl_.rr_ = value;
}
inline void Viseme::set_rr(float value) {
  _internal_set_rr(value);
  // @@protoc_insertion_point(field_set:service.Viseme.rr)
}

// float aa = 11;
inline void Viseme::clear_aa() {
  _impl_.aa_ = 0;
}
inline float Viseme::_internal_aa() const {
  return _impl_.aa_;
}
inline float Viseme::aa() const {
  // @@protoc_insertion_point(field_get:service.Viseme.aa)
  return _internal_aa();
}
inline void Viseme::_internal_set_aa(float value) {
  
  _impl_.aa_ = value;
}
inline void Viseme::set_aa(float value) {
  _internal_set_aa(value);
  // @@protoc_insertion_point(field_set:service.Viseme.aa)
}

// float e = 12;
inline void Viseme::clear_e() {
  _impl_.e_ = 0;
}
inline float Viseme::_internal_e() const {
  return _impl_.e_;
}
inline float Viseme::e() const {
  // @@protoc_insertion_point(field_get:service.Viseme.e)
  return _internal_e();
}
inline void Viseme::_internal_set_e(float value) {
  
  _impl_.e_ = value;
}
inline void Viseme::set_e(float value) {
  _internal_set_e(value);
  // @@protoc_insertion_point(field_set:service.Viseme.e)
}

// float ih = 13;
inline void Viseme::clear_ih() {
  _impl_.ih_ = 0;
}
inline float Viseme::_internal_ih() const {
  return _impl_.ih_;
}
inline float Viseme::ih() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ih)
  return _internal_ih();
}
inline void Viseme::_internal_set_ih(float value) {
  
  _impl_.ih_ = value;
}
inline void Viseme::set_ih(float value) {
  _internal_set_ih(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ih)
}

// float oh = 14;
inline void Viseme::clear_oh() {
  _impl_.oh_ = 0;
}
inline float Viseme::_internal_oh() const {
  return _impl_.oh_;
}
inline float Viseme::oh() const {
  // @@protoc_insertion_point(field_get:service.Viseme.oh)
  return _internal_oh();
}
inline void Viseme::_internal_set_oh(float value) {
  
  _impl_.oh_ = value;
}
inline void Viseme::set_oh(float value) {
  _internal_set_oh(value);
  // @@protoc_insertion_point(field_set:service.Viseme.oh)
}

// float ou = 15;
inline void Viseme::clear_ou() {
  _impl_.ou_ = 0;
}
inline float Viseme::_internal_ou() const {
  return _impl_.ou_;
}
inline float Viseme::ou() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ou)
  return _internal_ou();
}
inline void Viseme::_internal_set_ou(float value) {
  
  _impl_.ou_ = value;
}
inline void Viseme::set_ou(float value) {
  _internal_set_ou(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ou)
}

// -------------------------------------------------------------------

// BlendShapesData

// string blendshape_data = 1;
inline void BlendShapesData::clear_blendshape_data() {
  _impl_.blendshape_data_.ClearToEmpty();
}
inline const std::string& BlendShapesData::blendshape_data() const {
  // @@protoc_insertion_point(field_get:service.BlendShapesData.blendshape_data)
  return _internal_blendshape_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlendShapesData::set_blendshape_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blendshape_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.BlendShapesData.blendshape_data)
}
inline std::string* BlendShapesData::mutable_blendshape_data() {
  std::string* _s = _internal_mutable_blendshape_data();
  // @@protoc_insertion_point(field_mutable:service.BlendShapesData.blendshape_data)
  return _s;
}
inline const std::string& BlendShapesData::_internal_blendshape_data() const {
  return _impl_.blendshape_data_.Get();
}
inline void BlendShapesData::_internal_set_blendshape_data(const std::string& value) {
  
  _impl_.blendshape_data_.Set(value, GetArenaForAllocation());
}
inline std::string* BlendShapesData::_internal_mutable_blendshape_data() {
  
  return _impl_.blendshape_data_.Mutable(GetArenaForAllocation());
}
inline std::string* BlendShapesData::release_blendshape_data() {
  // @@protoc_insertion_point(field_release:service.BlendShapesData.blendshape_data)
  return _impl_.blendshape_data_.Release();
}
inline void BlendShapesData::set_allocated_blendshape_data(std::string* blendshape_data) {
  if (blendshape_data != nullptr) {
    
  } else {
    
  }
  _impl_.blendshape_data_.SetAllocated(blendshape_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blendshape_data_.IsDefault()) {
    _impl_.blendshape_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.BlendShapesData.blendshape_data)
}

// -------------------------------------------------------------------

// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:service.HelloRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:service.HelloRequest.name)
  return _s;
}
inline const std::string& HelloRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:service.HelloRequest.name)
  return _impl_.name_.Release();
}
inline void HelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloResponse

// string message = 1;
inline void HelloResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HelloResponse::message() const {
  // @@protoc_insertion_point(field_get:service.HelloResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.HelloResponse.message)
}
inline std::string* HelloResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:service.HelloResponse.message)
  return _s;
}
inline const std::string& HelloResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HelloResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloResponse::release_message() {
  // @@protoc_insertion_point(field_release:service.HelloResponse.message)
  return _impl_.message_.Release();
}
inline void HelloResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.HelloResponse.message)
}

// -------------------------------------------------------------------

// FeedbackRequest_Feedback

// bool thumbs_up = 1;
inline void FeedbackRequest_Feedback::clear_thumbs_up() {
  _impl_.thumbs_up_ = false;
}
inline bool FeedbackRequest_Feedback::_internal_thumbs_up() const {
  return _impl_.thumbs_up_;
}
inline bool FeedbackRequest_Feedback::thumbs_up() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.thumbs_up)
  return _internal_thumbs_up();
}
inline void FeedbackRequest_Feedback::_internal_set_thumbs_up(bool value) {
  
  _impl_.thumbs_up_ = value;
}
inline void FeedbackRequest_Feedback::set_thumbs_up(bool value) {
  _internal_set_thumbs_up(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.thumbs_up)
}

// string feedback_text = 2;
inline void FeedbackRequest_Feedback::clear_feedback_text() {
  _impl_.feedback_text_.ClearToEmpty();
}
inline const std::string& FeedbackRequest_Feedback::feedback_text() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.feedback_text)
  return _internal_feedback_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest_Feedback::set_feedback_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feedback_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.feedback_text)
}
inline std::string* FeedbackRequest_Feedback::mutable_feedback_text() {
  std::string* _s = _internal_mutable_feedback_text();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.Feedback.feedback_text)
  return _s;
}
inline const std::string& FeedbackRequest_Feedback::_internal_feedback_text() const {
  return _impl_.feedback_text_.Get();
}
inline void FeedbackRequest_Feedback::_internal_set_feedback_text(const std::string& value) {
  
  _impl_.feedback_text_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest_Feedback::_internal_mutable_feedback_text() {
  
  return _impl_.feedback_text_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest_Feedback::release_feedback_text() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.Feedback.feedback_text)
  return _impl_.feedback_text_.Release();
}
inline void FeedbackRequest_Feedback::set_allocated_feedback_text(std::string* feedback_text) {
  if (feedback_text != nullptr) {
    
  } else {
    
  }
  _impl_.feedback_text_.SetAllocated(feedback_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_text_.IsDefault()) {
    _impl_.feedback_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.Feedback.feedback_text)
}

// -------------------------------------------------------------------

// FeedbackRequest

// string interaction_id = 1;
inline void FeedbackRequest::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::interaction_id() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.interaction_id)
}
inline std::string* FeedbackRequest::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.interaction_id)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void FeedbackRequest::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest::release_interaction_id() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void FeedbackRequest::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.interaction_id)
}

// string character_id = 2;
inline void FeedbackRequest::clear_character_id() {
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::character_id() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.character_id)
  return _internal_character_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest::set_character_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.character_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.character_id)
}
inline std::string* FeedbackRequest::mutable_character_id() {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.character_id)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_character_id() const {
  return _impl_.character_id_.Get();
}
inline void FeedbackRequest::_internal_set_character_id(const std::string& value) {
  
  _impl_.character_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest::_internal_mutable_character_id() {
  
  return _impl_.character_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest::release_character_id() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.character_id)
  return _impl_.character_id_.Release();
}
inline void FeedbackRequest::set_allocated_character_id(std::string* character_id) {
  if (character_id != nullptr) {
    
  } else {
    
  }
  _impl_.character_id_.SetAllocated(character_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.character_id_.IsDefault()) {
    _impl_.character_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.character_id)
}

// string session_id = 3;
inline void FeedbackRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::session_id() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.session_id)
}
inline std::string* FeedbackRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.session_id)
  return _s;
}
inline const std::string& FeedbackRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void FeedbackRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void FeedbackRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.session_id)
}

// .service.FeedbackRequest.Feedback text_feedback = 5;
inline bool FeedbackRequest::_internal_has_text_feedback() const {
  return this != internal_default_instance() && _impl_.text_feedback_ != nullptr;
}
inline bool FeedbackRequest::has_text_feedback() const {
  return _internal_has_text_feedback();
}
inline void FeedbackRequest::clear_text_feedback() {
  if (GetArenaForAllocation() == nullptr && _impl_.text_feedback_ != nullptr) {
    delete _impl_.text_feedback_;
  }
  _impl_.text_feedback_ = nullptr;
}
inline const ::service::FeedbackRequest_Feedback& FeedbackRequest::_internal_text_feedback() const {
  const ::service::FeedbackRequest_Feedback* p = _impl_.text_feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::FeedbackRequest_Feedback&>(
      ::service::_FeedbackRequest_Feedback_default_instance_);
}
inline const ::service::FeedbackRequest_Feedback& FeedbackRequest::text_feedback() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.text_feedback)
  return _internal_text_feedback();
}
inline void FeedbackRequest::unsafe_arena_set_allocated_text_feedback(
    ::service::FeedbackRequest_Feedback* text_feedback) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_feedback_);
  }
  _impl_.text_feedback_ = text_feedback;
  if (text_feedback) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.FeedbackRequest.text_feedback)
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::release_text_feedback() {
  
  ::service::FeedbackRequest_Feedback* temp = _impl_.text_feedback_;
  _impl_.text_feedback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::unsafe_arena_release_text_feedback() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.text_feedback)
  
  ::service::FeedbackRequest_Feedback* temp = _impl_.text_feedback_;
  _impl_.text_feedback_ = nullptr;
  return temp;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::_internal_mutable_text_feedback() {
  
  if (_impl_.text_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::FeedbackRequest_Feedback>(GetArenaForAllocation());
    _impl_.text_feedback_ = p;
  }
  return _impl_.text_feedback_;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::mutable_text_feedback() {
  ::service::FeedbackRequest_Feedback* _msg = _internal_mutable_text_feedback();
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.text_feedback)
  return _msg;
}
inline void FeedbackRequest::set_allocated_text_feedback(::service::FeedbackRequest_Feedback* text_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.text_feedback_;
  }
  if (text_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_feedback);
    if (message_arena != submessage_arena) {
      text_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_feedback, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.text_feedback_ = text_feedback;
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.text_feedback)
}

// -------------------------------------------------------------------

// FeedbackResponse

// string feedback_response = 1;
inline void FeedbackResponse::clear_feedback_response() {
  _impl_.feedback_response_.ClearToEmpty();
}
inline const std::string& FeedbackResponse::feedback_response() const {
  // @@protoc_insertion_point(field_get:service.FeedbackResponse.feedback_response)
  return _internal_feedback_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedbackResponse::set_feedback_response(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feedback_response_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:service.FeedbackResponse.feedback_response)
}
inline std::string* FeedbackResponse::mutable_feedback_response() {
  std::string* _s = _internal_mutable_feedback_response();
  // @@protoc_insertion_point(field_mutable:service.FeedbackResponse.feedback_response)
  return _s;
}
inline const std::string& FeedbackResponse::_internal_feedback_response() const {
  return _impl_.feedback_response_.Get();
}
inline void FeedbackResponse::_internal_set_feedback_response(const std::string& value) {
  
  _impl_.feedback_response_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedbackResponse::_internal_mutable_feedback_response() {
  
  return _impl_.feedback_response_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedbackResponse::release_feedback_response() {
  // @@protoc_insertion_point(field_release:service.FeedbackResponse.feedback_response)
  return _impl_.feedback_response_.Release();
}
inline void FeedbackResponse::set_allocated_feedback_response(std::string* feedback_response) {
  if (feedback_response != nullptr) {
    
  } else {
    
  }
  _impl_.feedback_response_.SetAllocated(feedback_response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_response_.IsDefault()) {
    _impl_.feedback_response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackResponse.feedback_response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::service::FaceModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service::FaceModel>() {
  return ::service::FaceModel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_service_2eproto

#else
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_service_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_service_2eproto;
namespace service {
class ActionConfig;
class ActionConfigDefaultTypeInternal;
extern ActionConfigDefaultTypeInternal _ActionConfig_default_instance_;
class ActionConfig_Character;
class ActionConfig_CharacterDefaultTypeInternal;
extern ActionConfig_CharacterDefaultTypeInternal _ActionConfig_Character_default_instance_;
class ActionConfig_Object;
class ActionConfig_ObjectDefaultTypeInternal;
extern ActionConfig_ObjectDefaultTypeInternal _ActionConfig_Object_default_instance_;
class AudioConfig;
class AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class BlendShapesData;
class BlendShapesDataDefaultTypeInternal;
extern BlendShapesDataDefaultTypeInternal _BlendShapesData_default_instance_;
class FeedbackRequest;
class FeedbackRequestDefaultTypeInternal;
extern FeedbackRequestDefaultTypeInternal _FeedbackRequest_default_instance_;
class FeedbackRequest_Feedback;
class FeedbackRequest_FeedbackDefaultTypeInternal;
extern FeedbackRequest_FeedbackDefaultTypeInternal _FeedbackRequest_Feedback_default_instance_;
class FeedbackResponse;
class FeedbackResponseDefaultTypeInternal;
extern FeedbackResponseDefaultTypeInternal _FeedbackResponse_default_instance_;
class GetResponseRequest;
class GetResponseRequestDefaultTypeInternal;
extern GetResponseRequestDefaultTypeInternal _GetResponseRequest_default_instance_;
class GetResponseRequestSingle;
class GetResponseRequestSingleDefaultTypeInternal;
extern GetResponseRequestSingleDefaultTypeInternal _GetResponseRequestSingle_default_instance_;
class GetResponseRequest_GetResponseConfig;
class GetResponseRequest_GetResponseConfigDefaultTypeInternal;
extern GetResponseRequest_GetResponseConfigDefaultTypeInternal _GetResponseRequest_GetResponseConfig_default_instance_;
class GetResponseRequest_GetResponseData;
class GetResponseRequest_GetResponseDataDefaultTypeInternal;
extern GetResponseRequest_GetResponseDataDefaultTypeInternal _GetResponseRequest_GetResponseData_default_instance_;
class GetResponseResponse;
class GetResponseResponseDefaultTypeInternal;
extern GetResponseResponseDefaultTypeInternal _GetResponseResponse_default_instance_;
class GetResponseResponse_ActionResponse;
class GetResponseResponse_ActionResponseDefaultTypeInternal;
extern GetResponseResponse_ActionResponseDefaultTypeInternal _GetResponseResponse_ActionResponse_default_instance_;
class GetResponseResponse_AudioResponse;
class GetResponseResponse_AudioResponseDefaultTypeInternal;
extern GetResponseResponse_AudioResponseDefaultTypeInternal _GetResponseResponse_AudioResponse_default_instance_;
class GetResponseResponse_BehaviorTreeResponse;
class GetResponseResponse_BehaviorTreeResponseDefaultTypeInternal;
extern GetResponseResponse_BehaviorTreeResponseDefaultTypeInternal _GetResponseResponse_BehaviorTreeResponse_default_instance_;
class GetResponseResponse_UserTranscript;
class GetResponseResponse_UserTranscriptDefaultTypeInternal;
extern GetResponseResponse_UserTranscriptDefaultTypeInternal _GetResponseResponse_UserTranscript_default_instance_;
class HelloRequest;
class HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class HelloResponse;
class HelloResponseDefaultTypeInternal;
extern HelloResponseDefaultTypeInternal _HelloResponse_default_instance_;
class STTRequest;
class STTRequestDefaultTypeInternal;
extern STTRequestDefaultTypeInternal _STTRequest_default_instance_;
class STTResponse;
class STTResponseDefaultTypeInternal;
extern STTResponseDefaultTypeInternal _STTResponse_default_instance_;
class TriggerConfig;
class TriggerConfigDefaultTypeInternal;
extern TriggerConfigDefaultTypeInternal _TriggerConfig_default_instance_;
class Viseme;
class VisemeDefaultTypeInternal;
extern VisemeDefaultTypeInternal _Viseme_default_instance_;
class VisemesData;
class VisemesDataDefaultTypeInternal;
extern VisemesDataDefaultTypeInternal _VisemesData_default_instance_;
}  // namespace service
PROTOBUF_NAMESPACE_OPEN
template<> ::service::ActionConfig* Arena::CreateMaybeMessage<::service::ActionConfig>(Arena*);
template<> ::service::ActionConfig_Character* Arena::CreateMaybeMessage<::service::ActionConfig_Character>(Arena*);
template<> ::service::ActionConfig_Object* Arena::CreateMaybeMessage<::service::ActionConfig_Object>(Arena*);
template<> ::service::AudioConfig* Arena::CreateMaybeMessage<::service::AudioConfig>(Arena*);
template<> ::service::BlendShapesData* Arena::CreateMaybeMessage<::service::BlendShapesData>(Arena*);
template<> ::service::FeedbackRequest* Arena::CreateMaybeMessage<::service::FeedbackRequest>(Arena*);
template<> ::service::FeedbackRequest_Feedback* Arena::CreateMaybeMessage<::service::FeedbackRequest_Feedback>(Arena*);
template<> ::service::FeedbackResponse* Arena::CreateMaybeMessage<::service::FeedbackResponse>(Arena*);
template<> ::service::GetResponseRequest* Arena::CreateMaybeMessage<::service::GetResponseRequest>(Arena*);
template<> ::service::GetResponseRequestSingle* Arena::CreateMaybeMessage<::service::GetResponseRequestSingle>(Arena*);
template<> ::service::GetResponseRequest_GetResponseConfig* Arena::CreateMaybeMessage<::service::GetResponseRequest_GetResponseConfig>(Arena*);
template<> ::service::GetResponseRequest_GetResponseData* Arena::CreateMaybeMessage<::service::GetResponseRequest_GetResponseData>(Arena*);
template<> ::service::GetResponseResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse>(Arena*);
template<> ::service::GetResponseResponse_ActionResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse_ActionResponse>(Arena*);
template<> ::service::GetResponseResponse_AudioResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse_AudioResponse>(Arena*);
template<> ::service::GetResponseResponse_BehaviorTreeResponse* Arena::CreateMaybeMessage<::service::GetResponseResponse_BehaviorTreeResponse>(Arena*);
template<> ::service::GetResponseResponse_UserTranscript* Arena::CreateMaybeMessage<::service::GetResponseResponse_UserTranscript>(Arena*);
template<> ::service::HelloRequest* Arena::CreateMaybeMessage<::service::HelloRequest>(Arena*);
template<> ::service::HelloResponse* Arena::CreateMaybeMessage<::service::HelloResponse>(Arena*);
template<> ::service::STTRequest* Arena::CreateMaybeMessage<::service::STTRequest>(Arena*);
template<> ::service::STTResponse* Arena::CreateMaybeMessage<::service::STTResponse>(Arena*);
template<> ::service::TriggerConfig* Arena::CreateMaybeMessage<::service::TriggerConfig>(Arena*);
template<> ::service::Viseme* Arena::CreateMaybeMessage<::service::Viseme>(Arena*);
template<> ::service::VisemesData* Arena::CreateMaybeMessage<::service::VisemesData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace service {

enum FaceModel : int {
  FACE_MODEL_UNSPECIFIED = 0,
  FACE_MODEL_A_2F_MODEL_NAME = 1,
  FACE_MODEL_PHONEMES_MODEL_NAME = 2,
  FACE_MODEL_OVR_MODEL_NAME = 3,
  FaceModel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FaceModel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FaceModel_IsValid(int value);
constexpr FaceModel FaceModel_MIN = FACE_MODEL_UNSPECIFIED;
constexpr FaceModel FaceModel_MAX = FACE_MODEL_OVR_MODEL_NAME;
constexpr int FaceModel_ARRAYSIZE = FaceModel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FaceModel_descriptor();
template<typename T>
inline const std::string& FaceModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FaceModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FaceModel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FaceModel_descriptor(), enum_t_value);
}
inline bool FaceModel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FaceModel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FaceModel>(
    FaceModel_descriptor(), name, value);
}
// ===================================================================

class AudioConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.AudioConfig) */ {
 public:
  inline AudioConfig() : AudioConfig(nullptr) {}
  virtual ~AudioConfig();

  AudioConfig(const AudioConfig& from);
  AudioConfig(AudioConfig&& from) noexcept
    : AudioConfig() {
    *this = ::std::move(from);
  }

  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioConfig& default_instance();

  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
               &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AudioConfig& a, AudioConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioConfig* New() const final {
    return CreateMaybeMessage<AudioConfig>(nullptr);
  }

  AudioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioConfig& from);
  void MergeFrom(const AudioConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.AudioConfig";
  }
  protected:
  explicit AudioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleRateHertzFieldNumber = 1,
    kDisableAudioFieldNumber = 2,
    kEnableFacialDataFieldNumber = 3,
    kFaceModelFieldNumber = 4,
  };
  // int32 sample_rate_hertz = 1;
  void clear_sample_rate_hertz();
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rate_hertz() const;
  void set_sample_rate_hertz(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sample_rate_hertz() const;
  void _internal_set_sample_rate_hertz(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool disable_audio = 2;
  void clear_disable_audio();
  bool disable_audio() const;
  void set_disable_audio(bool value);
  private:
  bool _internal_disable_audio() const;
  void _internal_set_disable_audio(bool value);
  public:

  // bool enable_facial_data = 3;
  void clear_enable_facial_data();
  bool enable_facial_data() const;
  void set_enable_facial_data(bool value);
  private:
  bool _internal_enable_facial_data() const;
  void _internal_set_enable_facial_data(bool value);
  public:

  // .service.FaceModel face_model = 4;
  void clear_face_model();
  ::service::FaceModel face_model() const;
  void set_face_model(::service::FaceModel value);
  private:
  ::service::FaceModel _internal_face_model() const;
  void _internal_set_face_model(::service::FaceModel value);
  public:

  // @@protoc_insertion_point(class_scope:service.AudioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rate_hertz_;
  bool disable_audio_;
  bool enable_facial_data_;
  int face_model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TriggerConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.TriggerConfig) */ {
 public:
  inline TriggerConfig() : TriggerConfig(nullptr) {}
  virtual ~TriggerConfig();

  TriggerConfig(const TriggerConfig& from);
  TriggerConfig(TriggerConfig&& from) noexcept
    : TriggerConfig() {
    *this = ::std::move(from);
  }

  inline TriggerConfig& operator=(const TriggerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerConfig& operator=(TriggerConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TriggerConfig& default_instance();

  static inline const TriggerConfig* internal_default_instance() {
    return reinterpret_cast<const TriggerConfig*>(
               &_TriggerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TriggerConfig& a, TriggerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TriggerConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TriggerConfig* New() const final {
    return CreateMaybeMessage<TriggerConfig>(nullptr);
  }

  TriggerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TriggerConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TriggerConfig& from);
  void MergeFrom(const TriggerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriggerConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.TriggerConfig";
  }
  protected:
  explicit TriggerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerNameFieldNumber = 1,
    kTriggerMessageFieldNumber = 2,
  };
  // string trigger_name = 1;
  void clear_trigger_name();
  const std::string& trigger_name() const;
  void set_trigger_name(const std::string& value);
  void set_trigger_name(std::string&& value);
  void set_trigger_name(const char* value);
  void set_trigger_name(const char* value, size_t size);
  std::string* mutable_trigger_name();
  std::string* release_trigger_name();
  void set_allocated_trigger_name(std::string* trigger_name);
  private:
  const std::string& _internal_trigger_name() const;
  void _internal_set_trigger_name(const std::string& value);
  std::string* _internal_mutable_trigger_name();
  public:

  // string trigger_message = 2;
  void clear_trigger_message();
  const std::string& trigger_message() const;
  void set_trigger_message(const std::string& value);
  void set_trigger_message(std::string&& value);
  void set_trigger_message(const char* value);
  void set_trigger_message(const char* value, size_t size);
  std::string* mutable_trigger_message();
  std::string* release_trigger_message();
  void set_allocated_trigger_message(std::string* trigger_message);
  private:
  const std::string& _internal_trigger_message() const;
  void _internal_set_trigger_message(const std::string& value);
  std::string* _internal_mutable_trigger_message();
  public:

  // @@protoc_insertion_point(class_scope:service.TriggerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig_Character PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.ActionConfig.Character) */ {
 public:
  inline ActionConfig_Character() : ActionConfig_Character(nullptr) {}
  virtual ~ActionConfig_Character();

  ActionConfig_Character(const ActionConfig_Character& from);
  ActionConfig_Character(ActionConfig_Character&& from) noexcept
    : ActionConfig_Character() {
    *this = ::std::move(from);
  }

  inline ActionConfig_Character& operator=(const ActionConfig_Character& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig_Character& operator=(ActionConfig_Character&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionConfig_Character& default_instance();

  static inline const ActionConfig_Character* internal_default_instance() {
    return reinterpret_cast<const ActionConfig_Character*>(
               &_ActionConfig_Character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ActionConfig_Character& a, ActionConfig_Character& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionConfig_Character* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig_Character* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionConfig_Character* New() const final {
    return CreateMaybeMessage<ActionConfig_Character>(nullptr);
  }

  ActionConfig_Character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionConfig_Character>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionConfig_Character& from);
  void MergeFrom(const ActionConfig_Character& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig_Character* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.ActionConfig.Character";
  }
  protected:
  explicit ActionConfig_Character(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kBioFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string bio = 2;
  void clear_bio();
  const std::string& bio() const;
  void set_bio(const std::string& value);
  void set_bio(std::string&& value);
  void set_bio(const char* value);
  void set_bio(const char* value, size_t size);
  std::string* mutable_bio();
  std::string* release_bio();
  void set_allocated_bio(std::string* bio);
  private:
  const std::string& _internal_bio() const;
  void _internal_set_bio(const std::string& value);
  std::string* _internal_mutable_bio();
  public:

  // @@protoc_insertion_point(class_scope:service.ActionConfig.Character)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bio_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig_Object PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.ActionConfig.Object) */ {
 public:
  inline ActionConfig_Object() : ActionConfig_Object(nullptr) {}
  virtual ~ActionConfig_Object();

  ActionConfig_Object(const ActionConfig_Object& from);
  ActionConfig_Object(ActionConfig_Object&& from) noexcept
    : ActionConfig_Object() {
    *this = ::std::move(from);
  }

  inline ActionConfig_Object& operator=(const ActionConfig_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig_Object& operator=(ActionConfig_Object&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionConfig_Object& default_instance();

  static inline const ActionConfig_Object* internal_default_instance() {
    return reinterpret_cast<const ActionConfig_Object*>(
               &_ActionConfig_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ActionConfig_Object& a, ActionConfig_Object& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionConfig_Object* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig_Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionConfig_Object* New() const final {
    return CreateMaybeMessage<ActionConfig_Object>(nullptr);
  }

  ActionConfig_Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionConfig_Object>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionConfig_Object& from);
  void MergeFrom(const ActionConfig_Object& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig_Object* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.ActionConfig.Object";
  }
  protected:
  explicit ActionConfig_Object(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:service.ActionConfig.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class ActionConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.ActionConfig) */ {
 public:
  inline ActionConfig() : ActionConfig(nullptr) {}
  virtual ~ActionConfig();

  ActionConfig(const ActionConfig& from);
  ActionConfig(ActionConfig&& from) noexcept
    : ActionConfig() {
    *this = ::std::move(from);
  }

  inline ActionConfig& operator=(const ActionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionConfig& operator=(ActionConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionConfig& default_instance();

  static inline const ActionConfig* internal_default_instance() {
    return reinterpret_cast<const ActionConfig*>(
               &_ActionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ActionConfig& a, ActionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionConfig* New() const final {
    return CreateMaybeMessage<ActionConfig>(nullptr);
  }

  ActionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionConfig& from);
  void MergeFrom(const ActionConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.ActionConfig";
  }
  protected:
  explicit ActionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ActionConfig_Character Character;
  typedef ActionConfig_Object Object;

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
    kCharactersFieldNumber = 2,
    kObjectsFieldNumber = 3,
    kClassificationFieldNumber = 4,
    kCurrentAttentionObjectFieldNumber = 6,
    kContextLevelFieldNumber = 5,
  };
  // repeated string actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  const std::string& actions(int index) const;
  std::string* mutable_actions(int index);
  void set_actions(int index, const std::string& value);
  void set_actions(int index, std::string&& value);
  void set_actions(int index, const char* value);
  void set_actions(int index, const char* value, size_t size);
  std::string* add_actions();
  void add_actions(const std::string& value);
  void add_actions(std::string&& value);
  void add_actions(const char* value);
  void add_actions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_actions();
  private:
  const std::string& _internal_actions(int index) const;
  std::string* _internal_add_actions();
  public:

  // repeated .service.ActionConfig.Character characters = 2;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::service::ActionConfig_Character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >*
      mutable_characters();
  private:
  const ::service::ActionConfig_Character& _internal_characters(int index) const;
  ::service::ActionConfig_Character* _internal_add_characters();
  public:
  const ::service::ActionConfig_Character& characters(int index) const;
  ::service::ActionConfig_Character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >&
      characters() const;

  // repeated .service.ActionConfig.Object objects = 3;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::service::ActionConfig_Object* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >*
      mutable_objects();
  private:
  const ::service::ActionConfig_Object& _internal_objects(int index) const;
  ::service::ActionConfig_Object* _internal_add_objects();
  public:
  const ::service::ActionConfig_Object& objects(int index) const;
  ::service::ActionConfig_Object* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >&
      objects() const;

  // string classification = 4;
  void clear_classification();
  const std::string& classification() const;
  void set_classification(const std::string& value);
  void set_classification(std::string&& value);
  void set_classification(const char* value);
  void set_classification(const char* value, size_t size);
  std::string* mutable_classification();
  std::string* release_classification();
  void set_allocated_classification(std::string* classification);
  private:
  const std::string& _internal_classification() const;
  void _internal_set_classification(const std::string& value);
  std::string* _internal_mutable_classification();
  public:

  // string current_attention_object = 6;
  void clear_current_attention_object();
  const std::string& current_attention_object() const;
  void set_current_attention_object(const std::string& value);
  void set_current_attention_object(std::string&& value);
  void set_current_attention_object(const char* value);
  void set_current_attention_object(const char* value, size_t size);
  std::string* mutable_current_attention_object();
  std::string* release_current_attention_object();
  void set_allocated_current_attention_object(std::string* current_attention_object);
  private:
  const std::string& _internal_current_attention_object() const;
  void _internal_set_current_attention_object(const std::string& value);
  std::string* _internal_mutable_current_attention_object();
  public:

  // int32 context_level = 5;
  void clear_context_level();
  ::PROTOBUF_NAMESPACE_ID::int32 context_level() const;
  void set_context_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_context_level() const;
  void _internal_set_context_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:service.ActionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> actions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character > characters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object > objects_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classification_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_attention_object_;
  ::PROTOBUF_NAMESPACE_ID::int32 context_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class STTRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.STTRequest) */ {
 public:
  inline STTRequest() : STTRequest(nullptr) {}
  virtual ~STTRequest();

  STTRequest(const STTRequest& from);
  STTRequest(STTRequest&& from) noexcept
    : STTRequest() {
    *this = ::std::move(from);
  }

  inline STTRequest& operator=(const STTRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTRequest& operator=(STTRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const STTRequest& default_instance();

  enum RequestTypeCase {
    kAudioConfig = 1,
    kAudioChunk = 2,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const STTRequest* internal_default_instance() {
    return reinterpret_cast<const STTRequest*>(
               &_STTRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(STTRequest& a, STTRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(STTRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline STTRequest* New() const final {
    return CreateMaybeMessage<STTRequest>(nullptr);
  }

  STTRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<STTRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const STTRequest& from);
  void MergeFrom(const STTRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.STTRequest";
  }
  protected:
  explicit STTRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioConfigFieldNumber = 1,
    kAudioChunkFieldNumber = 2,
  };
  // .service.AudioConfig audio_config = 1;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::service::AudioConfig& audio_config() const;
  ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* audio_config);
  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::service::AudioConfig* audio_config);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  // bytes audio_chunk = 2;
  private:
  bool _internal_has_audio_chunk() const;
  public:
  void clear_audio_chunk();
  const std::string& audio_chunk() const;
  void set_audio_chunk(const std::string& value);
  void set_audio_chunk(std::string&& value);
  void set_audio_chunk(const char* value);
  void set_audio_chunk(const void* value, size_t size);
  std::string* mutable_audio_chunk();
  std::string* release_audio_chunk();
  void set_allocated_audio_chunk(std::string* audio_chunk);
  private:
  const std::string& _internal_audio_chunk() const;
  void _internal_set_audio_chunk(const std::string& value);
  std::string* _internal_mutable_audio_chunk();
  public:

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:service.STTRequest)
 private:
  class _Internal;
  void set_has_audio_config();
  void set_has_audio_chunk();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RequestTypeUnion {
    RequestTypeUnion() {}
    ::service::AudioConfig* audio_config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_chunk_;
  } request_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class STTResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.STTResponse) */ {
 public:
  inline STTResponse() : STTResponse(nullptr) {}
  virtual ~STTResponse();

  STTResponse(const STTResponse& from);
  STTResponse(STTResponse&& from) noexcept
    : STTResponse() {
    *this = ::std::move(from);
  }

  inline STTResponse& operator=(const STTResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTResponse& operator=(STTResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const STTResponse& default_instance();

  static inline const STTResponse* internal_default_instance() {
    return reinterpret_cast<const STTResponse*>(
               &_STTResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(STTResponse& a, STTResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(STTResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline STTResponse* New() const final {
    return CreateMaybeMessage<STTResponse>(nullptr);
  }

  STTResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<STTResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const STTResponse& from);
  void MergeFrom(const STTResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.STTResponse";
  }
  protected:
  explicit STTResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:service.STTResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest_GetResponseConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequest.GetResponseConfig) */ {
 public:
  inline GetResponseRequest_GetResponseConfig() : GetResponseRequest_GetResponseConfig(nullptr) {}
  virtual ~GetResponseRequest_GetResponseConfig();

  GetResponseRequest_GetResponseConfig(const GetResponseRequest_GetResponseConfig& from);
  GetResponseRequest_GetResponseConfig(GetResponseRequest_GetResponseConfig&& from) noexcept
    : GetResponseRequest_GetResponseConfig() {
    *this = ::std::move(from);
  }

  inline GetResponseRequest_GetResponseConfig& operator=(const GetResponseRequest_GetResponseConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest_GetResponseConfig& operator=(GetResponseRequest_GetResponseConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponseRequest_GetResponseConfig& default_instance();

  static inline const GetResponseRequest_GetResponseConfig* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest_GetResponseConfig*>(
               &_GetResponseRequest_GetResponseConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetResponseRequest_GetResponseConfig& a, GetResponseRequest_GetResponseConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequest_GetResponseConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest_GetResponseConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponseRequest_GetResponseConfig* New() const final {
    return CreateMaybeMessage<GetResponseRequest_GetResponseConfig>(nullptr);
  }

  GetResponseRequest_GetResponseConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponseRequest_GetResponseConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponseRequest_GetResponseConfig& from);
  void MergeFrom(const GetResponseRequest_GetResponseConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequest_GetResponseConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequest.GetResponseConfig";
  }
  protected:
  explicit GetResponseRequest_GetResponseConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterIdFieldNumber = 2,
    kApiKeyFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kSpeakerFieldNumber = 7,
    kLanguageCodeFieldNumber = 8,
    kAudioConfigFieldNumber = 5,
    kActionConfigFieldNumber = 6,
  };
  // string character_id = 2;
  void clear_character_id();
  const std::string& character_id() const;
  void set_character_id(const std::string& value);
  void set_character_id(std::string&& value);
  void set_character_id(const char* value);
  void set_character_id(const char* value, size_t size);
  std::string* mutable_character_id();
  std::string* release_character_id();
  void set_allocated_character_id(std::string* character_id);
  private:
  const std::string& _internal_character_id() const;
  void _internal_set_character_id(const std::string& value);
  std::string* _internal_mutable_character_id();
  public:

  // string api_key = 3;
  void clear_api_key();
  const std::string& api_key() const;
  void set_api_key(const std::string& value);
  void set_api_key(std::string&& value);
  void set_api_key(const char* value);
  void set_api_key(const char* value, size_t size);
  std::string* mutable_api_key();
  std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string session_id = 4;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string speaker = 7;
  void clear_speaker();
  const std::string& speaker() const;
  void set_speaker(const std::string& value);
  void set_speaker(std::string&& value);
  void set_speaker(const char* value);
  void set_speaker(const char* value, size_t size);
  std::string* mutable_speaker();
  std::string* release_speaker();
  void set_allocated_speaker(std::string* speaker);
  private:
  const std::string& _internal_speaker() const;
  void _internal_set_speaker(const std::string& value);
  std::string* _internal_mutable_speaker();
  public:

  // string language_code = 8;
  void clear_language_code();
  const std::string& language_code() const;
  void set_language_code(const std::string& value);
  void set_language_code(std::string&& value);
  void set_language_code(const char* value);
  void set_language_code(const char* value, size_t size);
  std::string* mutable_language_code();
  std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // .service.AudioConfig audio_config = 5;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::service::AudioConfig& audio_config() const;
  ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* audio_config);
  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::service::AudioConfig* audio_config);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  // .service.ActionConfig action_config = 6;
  bool has_action_config() const;
  private:
  bool _internal_has_action_config() const;
  public:
  void clear_action_config();
  const ::service::ActionConfig& action_config() const;
  ::service::ActionConfig* release_action_config();
  ::service::ActionConfig* mutable_action_config();
  void set_allocated_action_config(::service::ActionConfig* action_config);
  private:
  const ::service::ActionConfig& _internal_action_config() const;
  ::service::ActionConfig* _internal_mutable_action_config();
  public:
  void unsafe_arena_set_allocated_action_config(
      ::service::ActionConfig* action_config);
  ::service::ActionConfig* unsafe_arena_release_action_config();

  // @@protoc_insertion_point(class_scope:service.GetResponseRequest.GetResponseConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr speaker_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
  ::service::AudioConfig* audio_config_;
  ::service::ActionConfig* action_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest_GetResponseData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequest.GetResponseData) */ {
 public:
  inline GetResponseRequest_GetResponseData() : GetResponseRequest_GetResponseData(nullptr) {}
  virtual ~GetResponseRequest_GetResponseData();

  GetResponseRequest_GetResponseData(const GetResponseRequest_GetResponseData& from);
  GetResponseRequest_GetResponseData(GetResponseRequest_GetResponseData&& from) noexcept
    : GetResponseRequest_GetResponseData() {
    *this = ::std::move(from);
  }

  inline GetResponseRequest_GetResponseData& operator=(const GetResponseRequest_GetResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest_GetResponseData& operator=(GetResponseRequest_GetResponseData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponseRequest_GetResponseData& default_instance();

  enum InputTypeCase {
    kAudioData = 1,
    kTextData = 2,
    kTriggerData = 3,
    INPUT_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseRequest_GetResponseData* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest_GetResponseData*>(
               &_GetResponseRequest_GetResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetResponseRequest_GetResponseData& a, GetResponseRequest_GetResponseData& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequest_GetResponseData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest_GetResponseData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponseRequest_GetResponseData* New() const final {
    return CreateMaybeMessage<GetResponseRequest_GetResponseData>(nullptr);
  }

  GetResponseRequest_GetResponseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponseRequest_GetResponseData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponseRequest_GetResponseData& from);
  void MergeFrom(const GetResponseRequest_GetResponseData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequest_GetResponseData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequest.GetResponseData";
  }
  protected:
  explicit GetResponseRequest_GetResponseData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDataFieldNumber = 1,
    kTextDataFieldNumber = 2,
    kTriggerDataFieldNumber = 3,
  };
  // bytes audio_data = 1;
  private:
  bool _internal_has_audio_data() const;
  public:
  void clear_audio_data();
  const std::string& audio_data() const;
  void set_audio_data(const std::string& value);
  void set_audio_data(std::string&& value);
  void set_audio_data(const char* value);
  void set_audio_data(const void* value, size_t size);
  std::string* mutable_audio_data();
  std::string* release_audio_data();
  void set_allocated_audio_data(std::string* audio_data);
  private:
  const std::string& _internal_audio_data() const;
  void _internal_set_audio_data(const std::string& value);
  std::string* _internal_mutable_audio_data();
  public:

  // string text_data = 2;
  private:
  bool _internal_has_text_data() const;
  public:
  void clear_text_data();
  const std::string& text_data() const;
  void set_text_data(const std::string& value);
  void set_text_data(std::string&& value);
  void set_text_data(const char* value);
  void set_text_data(const char* value, size_t size);
  std::string* mutable_text_data();
  std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // .service.TriggerConfig trigger_data = 3;
  bool has_trigger_data() const;
  private:
  bool _internal_has_trigger_data() const;
  public:
  void clear_trigger_data();
  const ::service::TriggerConfig& trigger_data() const;
  ::service::TriggerConfig* release_trigger_data();
  ::service::TriggerConfig* mutable_trigger_data();
  void set_allocated_trigger_data(::service::TriggerConfig* trigger_data);
  private:
  const ::service::TriggerConfig& _internal_trigger_data() const;
  ::service::TriggerConfig* _internal_mutable_trigger_data();
  public:
  void unsafe_arena_set_allocated_trigger_data(
      ::service::TriggerConfig* trigger_data);
  ::service::TriggerConfig* unsafe_arena_release_trigger_data();

  void clear_input_type();
  InputTypeCase input_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseRequest.GetResponseData)
 private:
  class _Internal;
  void set_has_audio_data();
  void set_has_text_data();
  void set_has_trigger_data();

  inline bool has_input_type() const;
  inline void clear_has_input_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InputTypeUnion {
    InputTypeUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
    ::service::TriggerConfig* trigger_data_;
  } input_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequest) */ {
 public:
  inline GetResponseRequest() : GetResponseRequest(nullptr) {}
  virtual ~GetResponseRequest();

  GetResponseRequest(const GetResponseRequest& from);
  GetResponseRequest(GetResponseRequest&& from) noexcept
    : GetResponseRequest() {
    *this = ::std::move(from);
  }

  inline GetResponseRequest& operator=(const GetResponseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequest& operator=(GetResponseRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponseRequest& default_instance();

  enum RequestTypeCase {
    kGetResponseConfig = 1,
    kGetResponseData = 2,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseRequest* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequest*>(
               &_GetResponseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetResponseRequest& a, GetResponseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponseRequest* New() const final {
    return CreateMaybeMessage<GetResponseRequest>(nullptr);
  }

  GetResponseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponseRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponseRequest& from);
  void MergeFrom(const GetResponseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequest";
  }
  protected:
  explicit GetResponseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GetResponseRequest_GetResponseConfig GetResponseConfig;
  typedef GetResponseRequest_GetResponseData GetResponseData;

  // accessors -------------------------------------------------------

  enum : int {
    kGetResponseConfigFieldNumber = 1,
    kGetResponseDataFieldNumber = 2,
  };
  // .service.GetResponseRequest.GetResponseConfig get_response_config = 1;
  bool has_get_response_config() const;
  private:
  bool _internal_has_get_response_config() const;
  public:
  void clear_get_response_config();
  const ::service::GetResponseRequest_GetResponseConfig& get_response_config() const;
  ::service::GetResponseRequest_GetResponseConfig* release_get_response_config();
  ::service::GetResponseRequest_GetResponseConfig* mutable_get_response_config();
  void set_allocated_get_response_config(::service::GetResponseRequest_GetResponseConfig* get_response_config);
  private:
  const ::service::GetResponseRequest_GetResponseConfig& _internal_get_response_config() const;
  ::service::GetResponseRequest_GetResponseConfig* _internal_mutable_get_response_config();
  public:
  void unsafe_arena_set_allocated_get_response_config(
      ::service::GetResponseRequest_GetResponseConfig* get_response_config);
  ::service::GetResponseRequest_GetResponseConfig* unsafe_arena_release_get_response_config();

  // .service.GetResponseRequest.GetResponseData get_response_data = 2;
  bool has_get_response_data() const;
  private:
  bool _internal_has_get_response_data() const;
  public:
  void clear_get_response_data();
  const ::service::GetResponseRequest_GetResponseData& get_response_data() const;
  ::service::GetResponseRequest_GetResponseData* release_get_response_data();
  ::service::GetResponseRequest_GetResponseData* mutable_get_response_data();
  void set_allocated_get_response_data(::service::GetResponseRequest_GetResponseData* get_response_data);
  private:
  const ::service::GetResponseRequest_GetResponseData& _internal_get_response_data() const;
  ::service::GetResponseRequest_GetResponseData* _internal_mutable_get_response_data();
  public:
  void unsafe_arena_set_allocated_get_response_data(
      ::service::GetResponseRequest_GetResponseData* get_response_data);
  ::service::GetResponseRequest_GetResponseData* unsafe_arena_release_get_response_data();

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseRequest)
 private:
  class _Internal;
  void set_has_get_response_config();
  void set_has_get_response_data();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RequestTypeUnion {
    RequestTypeUnion() {}
    ::service::GetResponseRequest_GetResponseConfig* get_response_config_;
    ::service::GetResponseRequest_GetResponseData* get_response_data_;
  } request_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseRequestSingle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseRequestSingle) */ {
 public:
  inline GetResponseRequestSingle() : GetResponseRequestSingle(nullptr) {}
  virtual ~GetResponseRequestSingle();

  GetResponseRequestSingle(const GetResponseRequestSingle& from);
  GetResponseRequestSingle(GetResponseRequestSingle&& from) noexcept
    : GetResponseRequestSingle() {
    *this = ::std::move(from);
  }

  inline GetResponseRequestSingle& operator=(const GetResponseRequestSingle& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseRequestSingle& operator=(GetResponseRequestSingle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponseRequestSingle& default_instance();

  static inline const GetResponseRequestSingle* internal_default_instance() {
    return reinterpret_cast<const GetResponseRequestSingle*>(
               &_GetResponseRequestSingle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetResponseRequestSingle& a, GetResponseRequestSingle& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseRequestSingle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseRequestSingle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponseRequestSingle* New() const final {
    return CreateMaybeMessage<GetResponseRequestSingle>(nullptr);
  }

  GetResponseRequestSingle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponseRequestSingle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponseRequestSingle& from);
  void MergeFrom(const GetResponseRequestSingle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseRequestSingle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseRequestSingle";
  }
  protected:
  explicit GetResponseRequestSingle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseConfigFieldNumber = 1,
    kResponseDataFieldNumber = 2,
  };
  // .service.GetResponseRequest response_config = 1;
  bool has_response_config() const;
  private:
  bool _internal_has_response_config() const;
  public:
  void clear_response_config();
  const ::service::GetResponseRequest& response_config() const;
  ::service::GetResponseRequest* release_response_config();
  ::service::GetResponseRequest* mutable_response_config();
  void set_allocated_response_config(::service::GetResponseRequest* response_config);
  private:
  const ::service::GetResponseRequest& _internal_response_config() const;
  ::service::GetResponseRequest* _internal_mutable_response_config();
  public:
  void unsafe_arena_set_allocated_response_config(
      ::service::GetResponseRequest* response_config);
  ::service::GetResponseRequest* unsafe_arena_release_response_config();

  // .service.GetResponseRequest response_data = 2;
  bool has_response_data() const;
  private:
  bool _internal_has_response_data() const;
  public:
  void clear_response_data();
  const ::service::GetResponseRequest& response_data() const;
  ::service::GetResponseRequest* release_response_data();
  ::service::GetResponseRequest* mutable_response_data();
  void set_allocated_response_data(::service::GetResponseRequest* response_data);
  private:
  const ::service::GetResponseRequest& _internal_response_data() const;
  ::service::GetResponseRequest* _internal_mutable_response_data();
  public:
  void unsafe_arena_set_allocated_response_data(
      ::service::GetResponseRequest* response_data);
  ::service::GetResponseRequest* unsafe_arena_release_response_data();

  // @@protoc_insertion_point(class_scope:service.GetResponseRequestSingle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service::GetResponseRequest* response_config_;
  ::service::GetResponseRequest* response_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_AudioResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.AudioResponse) */ {
 public:
  inline GetResponseResponse_AudioResponse() : GetResponseResponse_AudioResponse(nullptr) {}
  virtual ~GetResponseResponse_AudioResponse();

  GetResponseResponse_AudioResponse(const GetResponseResponse_AudioResponse& from);
  GetResponseResponse_AudioResponse(GetResponseResponse_AudioResponse&& from) noexcept
    : GetResponseResponse_AudioResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_AudioResponse& operator=(const GetResponseResponse_AudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_AudioResponse& operator=(GetResponseResponse_AudioResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponseResponse_AudioResponse& default_instance();

  enum FaceDataTypeCase {
    kVisemesData = 6,
    kBlendshapesData = 7,
    FACE_DATA_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseResponse_AudioResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_AudioResponse*>(
               &_GetResponseResponse_AudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetResponseResponse_AudioResponse& a, GetResponseResponse_AudioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_AudioResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_AudioResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponseResponse_AudioResponse* New() const final {
    return CreateMaybeMessage<GetResponseResponse_AudioResponse>(nullptr);
  }

  GetResponseResponse_AudioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponseResponse_AudioResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponseResponse_AudioResponse& from);
  void MergeFrom(const GetResponseResponse_AudioResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_AudioResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.AudioResponse";
  }
  protected:
  explicit GetResponseResponse_AudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDataFieldNumber = 1,
    kTextDataFieldNumber = 3,
    kFaceDataFieldNumber = 5,
    kAudioConfigFieldNumber = 2,
    kEndOfResponseFieldNumber = 4,
    kVisemesDataFieldNumber = 6,
    kBlendshapesDataFieldNumber = 7,
  };
  // bytes audio_data = 1;
  void clear_audio_data();
  const std::string& audio_data() const;
  void set_audio_data(const std::string& value);
  void set_audio_data(std::string&& value);
  void set_audio_data(const char* value);
  void set_audio_data(const void* value, size_t size);
  std::string* mutable_audio_data();
  std::string* release_audio_data();
  void set_allocated_audio_data(std::string* audio_data);
  private:
  const std::string& _internal_audio_data() const;
  void _internal_set_audio_data(const std::string& value);
  std::string* _internal_mutable_audio_data();
  public:

  // string text_data = 3;
  void clear_text_data();
  const std::string& text_data() const;
  void set_text_data(const std::string& value);
  void set_text_data(std::string&& value);
  void set_text_data(const char* value);
  void set_text_data(const char* value, size_t size);
  std::string* mutable_text_data();
  std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // string face_data = 5;
  void clear_face_data();
  const std::string& face_data() const;
  void set_face_data(const std::string& value);
  void set_face_data(std::string&& value);
  void set_face_data(const char* value);
  void set_face_data(const char* value, size_t size);
  std::string* mutable_face_data();
  std::string* release_face_data();
  void set_allocated_face_data(std::string* face_data);
  private:
  const std::string& _internal_face_data() const;
  void _internal_set_face_data(const std::string& value);
  std::string* _internal_mutable_face_data();
  public:

  // .service.AudioConfig audio_config = 2;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::service::AudioConfig& audio_config() const;
  ::service::AudioConfig* release_audio_config();
  ::service::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::service::AudioConfig* audio_config);
  private:
  const ::service::AudioConfig& _internal_audio_config() const;
  ::service::AudioConfig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::service::AudioConfig* audio_config);
  ::service::AudioConfig* unsafe_arena_release_audio_config();

  // bool end_of_response = 4;
  void clear_end_of_response();
  bool end_of_response() const;
  void set_end_of_response(bool value);
  private:
  bool _internal_end_of_response() const;
  void _internal_set_end_of_response(bool value);
  public:

  // .service.VisemesData visemes_data = 6;
  bool has_visemes_data() const;
  private:
  bool _internal_has_visemes_data() const;
  public:
  void clear_visemes_data();
  const ::service::VisemesData& visemes_data() const;
  ::service::VisemesData* release_visemes_data();
  ::service::VisemesData* mutable_visemes_data();
  void set_allocated_visemes_data(::service::VisemesData* visemes_data);
  private:
  const ::service::VisemesData& _internal_visemes_data() const;
  ::service::VisemesData* _internal_mutable_visemes_data();
  public:
  void unsafe_arena_set_allocated_visemes_data(
      ::service::VisemesData* visemes_data);
  ::service::VisemesData* unsafe_arena_release_visemes_data();

  // .service.BlendShapesData blendshapes_data = 7;
  bool has_blendshapes_data() const;
  private:
  bool _internal_has_blendshapes_data() const;
  public:
  void clear_blendshapes_data();
  const ::service::BlendShapesData& blendshapes_data() const;
  ::service::BlendShapesData* release_blendshapes_data();
  ::service::BlendShapesData* mutable_blendshapes_data();
  void set_allocated_blendshapes_data(::service::BlendShapesData* blendshapes_data);
  private:
  const ::service::BlendShapesData& _internal_blendshapes_data() const;
  ::service::BlendShapesData* _internal_mutable_blendshapes_data();
  public:
  void unsafe_arena_set_allocated_blendshapes_data(
      ::service::BlendShapesData* blendshapes_data);
  ::service::BlendShapesData* unsafe_arena_release_blendshapes_data();

  void clear_face_data_type();
  FaceDataTypeCase face_data_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.AudioResponse)
 private:
  class _Internal;
  void set_has_visemes_data();
  void set_has_blendshapes_data();

  inline bool has_face_data_type() const;
  inline void clear_has_face_data_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr face_data_;
  ::service::AudioConfig* audio_config_;
  bool end_of_response_;
  union FaceDataTypeUnion {
    FaceDataTypeUnion() {}
    ::service::VisemesData* visemes_data_;
    ::service::BlendShapesData* blendshapes_data_;
  } face_data_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_ActionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.ActionResponse) */ {
 public:
  inline GetResponseResponse_ActionResponse() : GetResponseResponse_ActionResponse(nullptr) {}
  virtual ~GetResponseResponse_ActionResponse();

  GetResponseResponse_ActionResponse(const GetResponseResponse_ActionResponse& from);
  GetResponseResponse_ActionResponse(GetResponseResponse_ActionResponse&& from) noexcept
    : GetResponseResponse_ActionResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_ActionResponse& operator=(const GetResponseResponse_ActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_ActionResponse& operator=(GetResponseResponse_ActionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponseResponse_ActionResponse& default_instance();

  static inline const GetResponseResponse_ActionResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_ActionResponse*>(
               &_GetResponseResponse_ActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetResponseResponse_ActionResponse& a, GetResponseResponse_ActionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_ActionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_ActionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponseResponse_ActionResponse* New() const final {
    return CreateMaybeMessage<GetResponseResponse_ActionResponse>(nullptr);
  }

  GetResponseResponse_ActionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponseResponse_ActionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponseResponse_ActionResponse& from);
  void MergeFrom(const GetResponseResponse_ActionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_ActionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.ActionResponse";
  }
  protected:
  explicit GetResponseResponse_ActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // string action = 1;
  void clear_action();
  const std::string& action() const;
  void set_action(const std::string& value);
  void set_action(std::string&& value);
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  std::string* mutable_action();
  std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.ActionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_BehaviorTreeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.BehaviorTreeResponse) */ {
 public:
  inline GetResponseResponse_BehaviorTreeResponse() : GetResponseResponse_BehaviorTreeResponse(nullptr) {}
  virtual ~GetResponseResponse_BehaviorTreeResponse();

  GetResponseResponse_BehaviorTreeResponse(const GetResponseResponse_BehaviorTreeResponse& from);
  GetResponseResponse_BehaviorTreeResponse(GetResponseResponse_BehaviorTreeResponse&& from) noexcept
    : GetResponseResponse_BehaviorTreeResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_BehaviorTreeResponse& operator=(const GetResponseResponse_BehaviorTreeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_BehaviorTreeResponse& operator=(GetResponseResponse_BehaviorTreeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponseResponse_BehaviorTreeResponse& default_instance();

  static inline const GetResponseResponse_BehaviorTreeResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_BehaviorTreeResponse*>(
               &_GetResponseResponse_BehaviorTreeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetResponseResponse_BehaviorTreeResponse& a, GetResponseResponse_BehaviorTreeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_BehaviorTreeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_BehaviorTreeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponseResponse_BehaviorTreeResponse* New() const final {
    return CreateMaybeMessage<GetResponseResponse_BehaviorTreeResponse>(nullptr);
  }

  GetResponseResponse_BehaviorTreeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponseResponse_BehaviorTreeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponseResponse_BehaviorTreeResponse& from);
  void MergeFrom(const GetResponseResponse_BehaviorTreeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_BehaviorTreeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.BehaviorTreeResponse";
  }
  protected:
  explicit GetResponseResponse_BehaviorTreeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBtCodeFieldNumber = 1,
    kBtConstantsFieldNumber = 2,
    kNarrativeSectionIdFieldNumber = 3,
  };
  // string bt_code = 1;
  void clear_bt_code();
  const std::string& bt_code() const;
  void set_bt_code(const std::string& value);
  void set_bt_code(std::string&& value);
  void set_bt_code(const char* value);
  void set_bt_code(const char* value, size_t size);
  std::string* mutable_bt_code();
  std::string* release_bt_code();
  void set_allocated_bt_code(std::string* bt_code);
  private:
  const std::string& _internal_bt_code() const;
  void _internal_set_bt_code(const std::string& value);
  std::string* _internal_mutable_bt_code();
  public:

  // string bt_constants = 2;
  void clear_bt_constants();
  const std::string& bt_constants() const;
  void set_bt_constants(const std::string& value);
  void set_bt_constants(std::string&& value);
  void set_bt_constants(const char* value);
  void set_bt_constants(const char* value, size_t size);
  std::string* mutable_bt_constants();
  std::string* release_bt_constants();
  void set_allocated_bt_constants(std::string* bt_constants);
  private:
  const std::string& _internal_bt_constants() const;
  void _internal_set_bt_constants(const std::string& value);
  std::string* _internal_mutable_bt_constants();
  public:

  // string narrative_section_id = 3;
  void clear_narrative_section_id();
  const std::string& narrative_section_id() const;
  void set_narrative_section_id(const std::string& value);
  void set_narrative_section_id(std::string&& value);
  void set_narrative_section_id(const char* value);
  void set_narrative_section_id(const char* value, size_t size);
  std::string* mutable_narrative_section_id();
  std::string* release_narrative_section_id();
  void set_allocated_narrative_section_id(std::string* narrative_section_id);
  private:
  const std::string& _internal_narrative_section_id() const;
  void _internal_set_narrative_section_id(const std::string& value);
  std::string* _internal_mutable_narrative_section_id();
  public:

  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.BehaviorTreeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bt_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bt_constants_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr narrative_section_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse_UserTranscript PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse.UserTranscript) */ {
 public:
  inline GetResponseResponse_UserTranscript() : GetResponseResponse_UserTranscript(nullptr) {}
  virtual ~GetResponseResponse_UserTranscript();

  GetResponseResponse_UserTranscript(const GetResponseResponse_UserTranscript& from);
  GetResponseResponse_UserTranscript(GetResponseResponse_UserTranscript&& from) noexcept
    : GetResponseResponse_UserTranscript() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse_UserTranscript& operator=(const GetResponseResponse_UserTranscript& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse_UserTranscript& operator=(GetResponseResponse_UserTranscript&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponseResponse_UserTranscript& default_instance();

  static inline const GetResponseResponse_UserTranscript* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse_UserTranscript*>(
               &_GetResponseResponse_UserTranscript_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetResponseResponse_UserTranscript& a, GetResponseResponse_UserTranscript& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse_UserTranscript* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse_UserTranscript* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponseResponse_UserTranscript* New() const final {
    return CreateMaybeMessage<GetResponseResponse_UserTranscript>(nullptr);
  }

  GetResponseResponse_UserTranscript* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponseResponse_UserTranscript>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponseResponse_UserTranscript& from);
  void MergeFrom(const GetResponseResponse_UserTranscript& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse_UserTranscript* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse.UserTranscript";
  }
  protected:
  explicit GetResponseResponse_UserTranscript(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextDataFieldNumber = 1,
    kIsFinalFieldNumber = 2,
    kEndOfResponseFieldNumber = 3,
  };
  // string text_data = 1;
  void clear_text_data();
  const std::string& text_data() const;
  void set_text_data(const std::string& value);
  void set_text_data(std::string&& value);
  void set_text_data(const char* value);
  void set_text_data(const char* value, size_t size);
  std::string* mutable_text_data();
  std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // bool is_final = 2;
  void clear_is_final();
  bool is_final() const;
  void set_is_final(bool value);
  private:
  bool _internal_is_final() const;
  void _internal_set_is_final(bool value);
  public:

  // bool end_of_response = 3;
  void clear_end_of_response();
  bool end_of_response() const;
  void set_end_of_response(bool value);
  private:
  bool _internal_end_of_response() const;
  void _internal_set_end_of_response(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service.GetResponseResponse.UserTranscript)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
  bool is_final_;
  bool end_of_response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class GetResponseResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.GetResponseResponse) */ {
 public:
  inline GetResponseResponse() : GetResponseResponse(nullptr) {}
  virtual ~GetResponseResponse();

  GetResponseResponse(const GetResponseResponse& from);
  GetResponseResponse(GetResponseResponse&& from) noexcept
    : GetResponseResponse() {
    *this = ::std::move(from);
  }

  inline GetResponseResponse& operator=(const GetResponseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponseResponse& operator=(GetResponseResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponseResponse& default_instance();

  enum ResponseTypeCase {
    kActionResponse = 2,
    kAudioResponse = 3,
    kDebugLog = 4,
    kUserQuery = 5,
    kBtResponse = 6,
    kEmotionResponse = 7,
    kInteractionId = 8,
    RESPONSE_TYPE_NOT_SET = 0,
  };

  static inline const GetResponseResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponseResponse*>(
               &_GetResponseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetResponseResponse& a, GetResponseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponseResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponseResponse* New() const final {
    return CreateMaybeMessage<GetResponseResponse>(nullptr);
  }

  GetResponseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponseResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponseResponse& from);
  void MergeFrom(const GetResponseResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponseResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.GetResponseResponse";
  }
  protected:
  explicit GetResponseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GetResponseResponse_AudioResponse AudioResponse;
  typedef GetResponseResponse_ActionResponse ActionResponse;
  typedef GetResponseResponse_BehaviorTreeResponse BehaviorTreeResponse;
  typedef GetResponseResponse_UserTranscript UserTranscript;

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kActionResponseFieldNumber = 2,
    kAudioResponseFieldNumber = 3,
    kDebugLogFieldNumber = 4,
    kUserQueryFieldNumber = 5,
    kBtResponseFieldNumber = 6,
    kEmotionResponseFieldNumber = 7,
    kInteractionIdFieldNumber = 8,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .service.GetResponseResponse.ActionResponse action_response = 2;
  bool has_action_response() const;
  private:
  bool _internal_has_action_response() const;
  public:
  void clear_action_response();
  const ::service::GetResponseResponse_ActionResponse& action_response() const;
  ::service::GetResponseResponse_ActionResponse* release_action_response();
  ::service::GetResponseResponse_ActionResponse* mutable_action_response();
  void set_allocated_action_response(::service::GetResponseResponse_ActionResponse* action_response);
  private:
  const ::service::GetResponseResponse_ActionResponse& _internal_action_response() const;
  ::service::GetResponseResponse_ActionResponse* _internal_mutable_action_response();
  public:
  void unsafe_arena_set_allocated_action_response(
      ::service::GetResponseResponse_ActionResponse* action_response);
  ::service::GetResponseResponse_ActionResponse* unsafe_arena_release_action_response();

  // .service.GetResponseResponse.AudioResponse audio_response = 3;
  bool has_audio_response() const;
  private:
  bool _internal_has_audio_response() const;
  public:
  void clear_audio_response();
  const ::service::GetResponseResponse_AudioResponse& audio_response() const;
  ::service::GetResponseResponse_AudioResponse* release_audio_response();
  ::service::GetResponseResponse_AudioResponse* mutable_audio_response();
  void set_allocated_audio_response(::service::GetResponseResponse_AudioResponse* audio_response);
  private:
  const ::service::GetResponseResponse_AudioResponse& _internal_audio_response() const;
  ::service::GetResponseResponse_AudioResponse* _internal_mutable_audio_response();
  public:
  void unsafe_arena_set_allocated_audio_response(
      ::service::GetResponseResponse_AudioResponse* audio_response);
  ::service::GetResponseResponse_AudioResponse* unsafe_arena_release_audio_response();

  // string debug_log = 4;
  private:
  bool _internal_has_debug_log() const;
  public:
  void clear_debug_log();
  const std::string& debug_log() const;
  void set_debug_log(const std::string& value);
  void set_debug_log(std::string&& value);
  void set_debug_log(const char* value);
  void set_debug_log(const char* value, size_t size);
  std::string* mutable_debug_log();
  std::string* release_debug_log();
  void set_allocated_debug_log(std::string* debug_log);
  private:
  const std::string& _internal_debug_log() const;
  void _internal_set_debug_log(const std::string& value);
  std::string* _internal_mutable_debug_log();
  public:

  // .service.GetResponseResponse.UserTranscript user_query = 5;
  bool has_user_query() const;
  private:
  bool _internal_has_user_query() const;
  public:
  void clear_user_query();
  const ::service::GetResponseResponse_UserTranscript& user_query() const;
  ::service::GetResponseResponse_UserTranscript* release_user_query();
  ::service::GetResponseResponse_UserTranscript* mutable_user_query();
  void set_allocated_user_query(::service::GetResponseResponse_UserTranscript* user_query);
  private:
  const ::service::GetResponseResponse_UserTranscript& _internal_user_query() const;
  ::service::GetResponseResponse_UserTranscript* _internal_mutable_user_query();
  public:
  void unsafe_arena_set_allocated_user_query(
      ::service::GetResponseResponse_UserTranscript* user_query);
  ::service::GetResponseResponse_UserTranscript* unsafe_arena_release_user_query();

  // .service.GetResponseResponse.BehaviorTreeResponse bt_response = 6;
  bool has_bt_response() const;
  private:
  bool _internal_has_bt_response() const;
  public:
  void clear_bt_response();
  const ::service::GetResponseResponse_BehaviorTreeResponse& bt_response() const;
  ::service::GetResponseResponse_BehaviorTreeResponse* release_bt_response();
  ::service::GetResponseResponse_BehaviorTreeResponse* mutable_bt_response();
  void set_allocated_bt_response(::service::GetResponseResponse_BehaviorTreeResponse* bt_response);
  private:
  const ::service::GetResponseResponse_BehaviorTreeResponse& _internal_bt_response() const;
  ::service::GetResponseResponse_BehaviorTreeResponse* _internal_mutable_bt_response();
  public:
  void unsafe_arena_set_allocated_bt_response(
      ::service::GetResponseResponse_BehaviorTreeResponse* bt_response);
  ::service::GetResponseResponse_BehaviorTreeResponse* unsafe_arena_release_bt_response();

  // string emotion_response = 7;
  private:
  bool _internal_has_emotion_response() const;
  public:
  void clear_emotion_response();
  const std::string& emotion_response() const;
  void set_emotion_response(const std::string& value);
  void set_emotion_response(std::string&& value);
  void set_emotion_response(const char* value);
  void set_emotion_response(const char* value, size_t size);
  std::string* mutable_emotion_response();
  std::string* release_emotion_response();
  void set_allocated_emotion_response(std::string* emotion_response);
  private:
  const std::string& _internal_emotion_response() const;
  void _internal_set_emotion_response(const std::string& value);
  std::string* _internal_mutable_emotion_response();
  public:

  // string interaction_id = 8;
  private:
  bool _internal_has_interaction_id() const;
  public:
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:service.GetResponseResponse)
 private:
  class _Internal;
  void set_has_action_response();
  void set_has_audio_response();
  void set_has_debug_log();
  void set_has_user_query();
  void set_has_bt_response();
  void set_has_emotion_response();
  void set_has_interaction_id();

  inline bool has_response_type() const;
  inline void clear_has_response_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  union ResponseTypeUnion {
    ResponseTypeUnion() {}
    ::service::GetResponseResponse_ActionResponse* action_response_;
    ::service::GetResponseResponse_AudioResponse* audio_response_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_log_;
    ::service::GetResponseResponse_UserTranscript* user_query_;
    ::service::GetResponseResponse_BehaviorTreeResponse* bt_response_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emotion_response_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  } response_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class VisemesData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.VisemesData) */ {
 public:
  inline VisemesData() : VisemesData(nullptr) {}
  virtual ~VisemesData();

  VisemesData(const VisemesData& from);
  VisemesData(VisemesData&& from) noexcept
    : VisemesData() {
    *this = ::std::move(from);
  }

  inline VisemesData& operator=(const VisemesData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisemesData& operator=(VisemesData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VisemesData& default_instance();

  static inline const VisemesData* internal_default_instance() {
    return reinterpret_cast<const VisemesData*>(
               &_VisemesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VisemesData& a, VisemesData& b) {
    a.Swap(&b);
  }
  inline void Swap(VisemesData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisemesData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VisemesData* New() const final {
    return CreateMaybeMessage<VisemesData>(nullptr);
  }

  VisemesData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VisemesData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VisemesData& from);
  void MergeFrom(const VisemesData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisemesData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.VisemesData";
  }
  protected:
  explicit VisemesData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisemesFieldNumber = 1,
  };
  // .service.Viseme visemes = 1;
  bool has_visemes() const;
  private:
  bool _internal_has_visemes() const;
  public:
  void clear_visemes();
  const ::service::Viseme& visemes() const;
  ::service::Viseme* release_visemes();
  ::service::Viseme* mutable_visemes();
  void set_allocated_visemes(::service::Viseme* visemes);
  private:
  const ::service::Viseme& _internal_visemes() const;
  ::service::Viseme* _internal_mutable_visemes();
  public:
  void unsafe_arena_set_allocated_visemes(
      ::service::Viseme* visemes);
  ::service::Viseme* unsafe_arena_release_visemes();

  // @@protoc_insertion_point(class_scope:service.VisemesData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::service::Viseme* visemes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class Viseme PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.Viseme) */ {
 public:
  inline Viseme() : Viseme(nullptr) {}
  virtual ~Viseme();

  Viseme(const Viseme& from);
  Viseme(Viseme&& from) noexcept
    : Viseme() {
    *this = ::std::move(from);
  }

  inline Viseme& operator=(const Viseme& from) {
    CopyFrom(from);
    return *this;
  }
  inline Viseme& operator=(Viseme&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Viseme& default_instance();

  static inline const Viseme* internal_default_instance() {
    return reinterpret_cast<const Viseme*>(
               &_Viseme_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Viseme& a, Viseme& b) {
    a.Swap(&b);
  }
  inline void Swap(Viseme* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Viseme* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Viseme* New() const final {
    return CreateMaybeMessage<Viseme>(nullptr);
  }

  Viseme* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Viseme>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Viseme& from);
  void MergeFrom(const Viseme& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Viseme* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.Viseme";
  }
  protected:
  explicit Viseme(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSilFieldNumber = 1,
    kPpFieldNumber = 2,
    kFfFieldNumber = 3,
    kThFieldNumber = 4,
    kDdFieldNumber = 5,
    kKkFieldNumber = 6,
    kChFieldNumber = 7,
    kSsFieldNumber = 8,
    kNnFieldNumber = 9,
    kRrFieldNumber = 10,
    kAaFieldNumber = 11,
    kEFieldNumber = 12,
    kIhFieldNumber = 13,
    kOhFieldNumber = 14,
    kOuFieldNumber = 15,
  };
  // float sil = 1;
  void clear_sil();
  float sil() const;
  void set_sil(float value);
  private:
  float _internal_sil() const;
  void _internal_set_sil(float value);
  public:

  // float pp = 2;
  void clear_pp();
  float pp() const;
  void set_pp(float value);
  private:
  float _internal_pp() const;
  void _internal_set_pp(float value);
  public:

  // float ff = 3;
  void clear_ff();
  float ff() const;
  void set_ff(float value);
  private:
  float _internal_ff() const;
  void _internal_set_ff(float value);
  public:

  // float th = 4;
  void clear_th();
  float th() const;
  void set_th(float value);
  private:
  float _internal_th() const;
  void _internal_set_th(float value);
  public:

  // float dd = 5;
  void clear_dd();
  float dd() const;
  void set_dd(float value);
  private:
  float _internal_dd() const;
  void _internal_set_dd(float value);
  public:

  // float kk = 6;
  void clear_kk();
  float kk() const;
  void set_kk(float value);
  private:
  float _internal_kk() const;
  void _internal_set_kk(float value);
  public:

  // float ch = 7;
  void clear_ch();
  float ch() const;
  void set_ch(float value);
  private:
  float _internal_ch() const;
  void _internal_set_ch(float value);
  public:

  // float ss = 8;
  void clear_ss();
  float ss() const;
  void set_ss(float value);
  private:
  float _internal_ss() const;
  void _internal_set_ss(float value);
  public:

  // float nn = 9;
  void clear_nn();
  float nn() const;
  void set_nn(float value);
  private:
  float _internal_nn() const;
  void _internal_set_nn(float value);
  public:

  // float rr = 10;
  void clear_rr();
  float rr() const;
  void set_rr(float value);
  private:
  float _internal_rr() const;
  void _internal_set_rr(float value);
  public:

  // float aa = 11;
  void clear_aa();
  float aa() const;
  void set_aa(float value);
  private:
  float _internal_aa() const;
  void _internal_set_aa(float value);
  public:

  // float e = 12;
  void clear_e();
  float e() const;
  void set_e(float value);
  private:
  float _internal_e() const;
  void _internal_set_e(float value);
  public:

  // float ih = 13;
  void clear_ih();
  float ih() const;
  void set_ih(float value);
  private:
  float _internal_ih() const;
  void _internal_set_ih(float value);
  public:

  // float oh = 14;
  void clear_oh();
  float oh() const;
  void set_oh(float value);
  private:
  float _internal_oh() const;
  void _internal_set_oh(float value);
  public:

  // float ou = 15;
  void clear_ou();
  float ou() const;
  void set_ou(float value);
  private:
  float _internal_ou() const;
  void _internal_set_ou(float value);
  public:

  // @@protoc_insertion_point(class_scope:service.Viseme)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float sil_;
  float pp_;
  float ff_;
  float th_;
  float dd_;
  float kk_;
  float ch_;
  float ss_;
  float nn_;
  float rr_;
  float aa_;
  float e_;
  float ih_;
  float oh_;
  float ou_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class BlendShapesData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.BlendShapesData) */ {
 public:
  inline BlendShapesData() : BlendShapesData(nullptr) {}
  virtual ~BlendShapesData();

  BlendShapesData(const BlendShapesData& from);
  BlendShapesData(BlendShapesData&& from) noexcept
    : BlendShapesData() {
    *this = ::std::move(from);
  }

  inline BlendShapesData& operator=(const BlendShapesData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlendShapesData& operator=(BlendShapesData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlendShapesData& default_instance();

  static inline const BlendShapesData* internal_default_instance() {
    return reinterpret_cast<const BlendShapesData*>(
               &_BlendShapesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BlendShapesData& a, BlendShapesData& b) {
    a.Swap(&b);
  }
  inline void Swap(BlendShapesData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlendShapesData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlendShapesData* New() const final {
    return CreateMaybeMessage<BlendShapesData>(nullptr);
  }

  BlendShapesData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlendShapesData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlendShapesData& from);
  void MergeFrom(const BlendShapesData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlendShapesData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.BlendShapesData";
  }
  protected:
  explicit BlendShapesData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlendshapeDataFieldNumber = 1,
  };
  // string blendshape_data = 1;
  void clear_blendshape_data();
  const std::string& blendshape_data() const;
  void set_blendshape_data(const std::string& value);
  void set_blendshape_data(std::string&& value);
  void set_blendshape_data(const char* value);
  void set_blendshape_data(const char* value, size_t size);
  std::string* mutable_blendshape_data();
  std::string* release_blendshape_data();
  void set_allocated_blendshape_data(std::string* blendshape_data);
  private:
  const std::string& _internal_blendshape_data() const;
  void _internal_set_blendshape_data(const std::string& value);
  std::string* _internal_mutable_blendshape_data();
  public:

  // @@protoc_insertion_point(class_scope:service.BlendShapesData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blendshape_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class HelloRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  virtual ~HelloRequest();

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HelloRequest& default_instance();

  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HelloRequest* New() const final {
    return CreateMaybeMessage<HelloRequest>(nullptr);
  }

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HelloRequest& from);
  void MergeFrom(const HelloRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:service.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class HelloResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.HelloResponse) */ {
 public:
  inline HelloResponse() : HelloResponse(nullptr) {}
  virtual ~HelloResponse();

  HelloResponse(const HelloResponse& from);
  HelloResponse(HelloResponse&& from) noexcept
    : HelloResponse() {
    *this = ::std::move(from);
  }

  inline HelloResponse& operator=(const HelloResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloResponse& operator=(HelloResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HelloResponse& default_instance();

  static inline const HelloResponse* internal_default_instance() {
    return reinterpret_cast<const HelloResponse*>(
               &_HelloResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(HelloResponse& a, HelloResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HelloResponse* New() const final {
    return CreateMaybeMessage<HelloResponse>(nullptr);
  }

  HelloResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HelloResponse& from);
  void MergeFrom(const HelloResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.HelloResponse";
  }
  protected:
  explicit HelloResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:service.HelloResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackRequest_Feedback PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.FeedbackRequest.Feedback) */ {
 public:
  inline FeedbackRequest_Feedback() : FeedbackRequest_Feedback(nullptr) {}
  virtual ~FeedbackRequest_Feedback();

  FeedbackRequest_Feedback(const FeedbackRequest_Feedback& from);
  FeedbackRequest_Feedback(FeedbackRequest_Feedback&& from) noexcept
    : FeedbackRequest_Feedback() {
    *this = ::std::move(from);
  }

  inline FeedbackRequest_Feedback& operator=(const FeedbackRequest_Feedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackRequest_Feedback& operator=(FeedbackRequest_Feedback&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeedbackRequest_Feedback& default_instance();

  static inline const FeedbackRequest_Feedback* internal_default_instance() {
    return reinterpret_cast<const FeedbackRequest_Feedback*>(
               &_FeedbackRequest_Feedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(FeedbackRequest_Feedback& a, FeedbackRequest_Feedback& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackRequest_Feedback* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackRequest_Feedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeedbackRequest_Feedback* New() const final {
    return CreateMaybeMessage<FeedbackRequest_Feedback>(nullptr);
  }

  FeedbackRequest_Feedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeedbackRequest_Feedback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeedbackRequest_Feedback& from);
  void MergeFrom(const FeedbackRequest_Feedback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackRequest_Feedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.FeedbackRequest.Feedback";
  }
  protected:
  explicit FeedbackRequest_Feedback(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedbackTextFieldNumber = 2,
    kThumbsUpFieldNumber = 1,
  };
  // string feedback_text = 2;
  void clear_feedback_text();
  const std::string& feedback_text() const;
  void set_feedback_text(const std::string& value);
  void set_feedback_text(std::string&& value);
  void set_feedback_text(const char* value);
  void set_feedback_text(const char* value, size_t size);
  std::string* mutable_feedback_text();
  std::string* release_feedback_text();
  void set_allocated_feedback_text(std::string* feedback_text);
  private:
  const std::string& _internal_feedback_text() const;
  void _internal_set_feedback_text(const std::string& value);
  std::string* _internal_mutable_feedback_text();
  public:

  // bool thumbs_up = 1;
  void clear_thumbs_up();
  bool thumbs_up() const;
  void set_thumbs_up(bool value);
  private:
  bool _internal_thumbs_up() const;
  void _internal_set_thumbs_up(bool value);
  public:

  // @@protoc_insertion_point(class_scope:service.FeedbackRequest.Feedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_text_;
  bool thumbs_up_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.FeedbackRequest) */ {
 public:
  inline FeedbackRequest() : FeedbackRequest(nullptr) {}
  virtual ~FeedbackRequest();

  FeedbackRequest(const FeedbackRequest& from);
  FeedbackRequest(FeedbackRequest&& from) noexcept
    : FeedbackRequest() {
    *this = ::std::move(from);
  }

  inline FeedbackRequest& operator=(const FeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackRequest& operator=(FeedbackRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeedbackRequest& default_instance();

  static inline const FeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const FeedbackRequest*>(
               &_FeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FeedbackRequest& a, FeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeedbackRequest* New() const final {
    return CreateMaybeMessage<FeedbackRequest>(nullptr);
  }

  FeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeedbackRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeedbackRequest& from);
  void MergeFrom(const FeedbackRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.FeedbackRequest";
  }
  protected:
  explicit FeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FeedbackRequest_Feedback Feedback;

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
    kCharacterIdFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kTextFeedbackFieldNumber = 5,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string character_id = 2;
  void clear_character_id();
  const std::string& character_id() const;
  void set_character_id(const std::string& value);
  void set_character_id(std::string&& value);
  void set_character_id(const char* value);
  void set_character_id(const char* value, size_t size);
  std::string* mutable_character_id();
  std::string* release_character_id();
  void set_allocated_character_id(std::string* character_id);
  private:
  const std::string& _internal_character_id() const;
  void _internal_set_character_id(const std::string& value);
  std::string* _internal_mutable_character_id();
  public:

  // string session_id = 3;
  void clear_session_id();
  const std::string& session_id() const;
  void set_session_id(const std::string& value);
  void set_session_id(std::string&& value);
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  std::string* mutable_session_id();
  std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .service.FeedbackRequest.Feedback text_feedback = 5;
  bool has_text_feedback() const;
  private:
  bool _internal_has_text_feedback() const;
  public:
  void clear_text_feedback();
  const ::service::FeedbackRequest_Feedback& text_feedback() const;
  ::service::FeedbackRequest_Feedback* release_text_feedback();
  ::service::FeedbackRequest_Feedback* mutable_text_feedback();
  void set_allocated_text_feedback(::service::FeedbackRequest_Feedback* text_feedback);
  private:
  const ::service::FeedbackRequest_Feedback& _internal_text_feedback() const;
  ::service::FeedbackRequest_Feedback* _internal_mutable_text_feedback();
  public:
  void unsafe_arena_set_allocated_text_feedback(
      ::service::FeedbackRequest_Feedback* text_feedback);
  ::service::FeedbackRequest_Feedback* unsafe_arena_release_text_feedback();

  // @@protoc_insertion_point(class_scope:service.FeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr character_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::service::FeedbackRequest_Feedback* text_feedback_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class FeedbackResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:service.FeedbackResponse) */ {
 public:
  inline FeedbackResponse() : FeedbackResponse(nullptr) {}
  virtual ~FeedbackResponse();

  FeedbackResponse(const FeedbackResponse& from);
  FeedbackResponse(FeedbackResponse&& from) noexcept
    : FeedbackResponse() {
    *this = ::std::move(from);
  }

  inline FeedbackResponse& operator=(const FeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedbackResponse& operator=(FeedbackResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeedbackResponse& default_instance();

  static inline const FeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const FeedbackResponse*>(
               &_FeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(FeedbackResponse& a, FeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedbackResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeedbackResponse* New() const final {
    return CreateMaybeMessage<FeedbackResponse>(nullptr);
  }

  FeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeedbackResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeedbackResponse& from);
  void MergeFrom(const FeedbackResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedbackResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "service.FeedbackResponse";
  }
  protected:
  explicit FeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_service_2eproto);
    return ::descriptor_table_service_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedbackResponseFieldNumber = 1,
  };
  // string feedback_response = 1;
  void clear_feedback_response();
  const std::string& feedback_response() const;
  void set_feedback_response(const std::string& value);
  void set_feedback_response(std::string&& value);
  void set_feedback_response(const char* value);
  void set_feedback_response(const char* value, size_t size);
  std::string* mutable_feedback_response();
  std::string* release_feedback_response();
  void set_allocated_feedback_response(std::string* feedback_response);
  private:
  const std::string& _internal_feedback_response() const;
  void _internal_set_feedback_response(const std::string& value);
  std::string* _internal_mutable_feedback_response();
  public:

  // @@protoc_insertion_point(class_scope:service.FeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_service_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AudioConfig

// int32 sample_rate_hertz = 1;
inline void AudioConfig::clear_sample_rate_hertz() {
  sample_rate_hertz_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::_internal_sample_rate_hertz() const {
  return sample_rate_hertz_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.sample_rate_hertz)
  return _internal_sample_rate_hertz();
}
inline void AudioConfig::_internal_set_sample_rate_hertz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sample_rate_hertz_ = value;
}
inline void AudioConfig::set_sample_rate_hertz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sample_rate_hertz(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.sample_rate_hertz)
}

// bool disable_audio = 2;
inline void AudioConfig::clear_disable_audio() {
  disable_audio_ = false;
}
inline bool AudioConfig::_internal_disable_audio() const {
  return disable_audio_;
}
inline bool AudioConfig::disable_audio() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.disable_audio)
  return _internal_disable_audio();
}
inline void AudioConfig::_internal_set_disable_audio(bool value) {
  
  disable_audio_ = value;
}
inline void AudioConfig::set_disable_audio(bool value) {
  _internal_set_disable_audio(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.disable_audio)
}

// bool enable_facial_data = 3;
inline void AudioConfig::clear_enable_facial_data() {
  enable_facial_data_ = false;
}
inline bool AudioConfig::_internal_enable_facial_data() const {
  return enable_facial_data_;
}
inline bool AudioConfig::enable_facial_data() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.enable_facial_data)
  return _internal_enable_facial_data();
}
inline void AudioConfig::_internal_set_enable_facial_data(bool value) {
  
  enable_facial_data_ = value;
}
inline void AudioConfig::set_enable_facial_data(bool value) {
  _internal_set_enable_facial_data(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.enable_facial_data)
}

// .service.FaceModel face_model = 4;
inline void AudioConfig::clear_face_model() {
  face_model_ = 0;
}
inline ::service::FaceModel AudioConfig::_internal_face_model() const {
  return static_cast< ::service::FaceModel >(face_model_);
}
inline ::service::FaceModel AudioConfig::face_model() const {
  // @@protoc_insertion_point(field_get:service.AudioConfig.face_model)
  return _internal_face_model();
}
inline void AudioConfig::_internal_set_face_model(::service::FaceModel value) {
  
  face_model_ = value;
}
inline void AudioConfig::set_face_model(::service::FaceModel value) {
  _internal_set_face_model(value);
  // @@protoc_insertion_point(field_set:service.AudioConfig.face_model)
}

// -------------------------------------------------------------------

// TriggerConfig

// string trigger_name = 1;
inline void TriggerConfig::clear_trigger_name() {
  trigger_name_.ClearToEmpty();
}
inline const std::string& TriggerConfig::trigger_name() const {
  // @@protoc_insertion_point(field_get:service.TriggerConfig.trigger_name)
  return _internal_trigger_name();
}
inline void TriggerConfig::set_trigger_name(const std::string& value) {
  _internal_set_trigger_name(value);
  // @@protoc_insertion_point(field_set:service.TriggerConfig.trigger_name)
}
inline std::string* TriggerConfig::mutable_trigger_name() {
  // @@protoc_insertion_point(field_mutable:service.TriggerConfig.trigger_name)
  return _internal_mutable_trigger_name();
}
inline const std::string& TriggerConfig::_internal_trigger_name() const {
  return trigger_name_.Get();
}
inline void TriggerConfig::_internal_set_trigger_name(const std::string& value) {
  
  trigger_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TriggerConfig::set_trigger_name(std::string&& value) {
  
  trigger_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.TriggerConfig.trigger_name)
}
inline void TriggerConfig::set_trigger_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  trigger_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.TriggerConfig.trigger_name)
}
inline void TriggerConfig::set_trigger_name(const char* value,
    size_t size) {
  
  trigger_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.TriggerConfig.trigger_name)
}
inline std::string* TriggerConfig::_internal_mutable_trigger_name() {
  
  return trigger_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TriggerConfig::release_trigger_name() {
  // @@protoc_insertion_point(field_release:service.TriggerConfig.trigger_name)
  return trigger_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TriggerConfig::set_allocated_trigger_name(std::string* trigger_name) {
  if (trigger_name != nullptr) {
    
  } else {
    
  }
  trigger_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trigger_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.TriggerConfig.trigger_name)
}

// string trigger_message = 2;
inline void TriggerConfig::clear_trigger_message() {
  trigger_message_.ClearToEmpty();
}
inline const std::string& TriggerConfig::trigger_message() const {
  // @@protoc_insertion_point(field_get:service.TriggerConfig.trigger_message)
  return _internal_trigger_message();
}
inline void TriggerConfig::set_trigger_message(const std::string& value) {
  _internal_set_trigger_message(value);
  // @@protoc_insertion_point(field_set:service.TriggerConfig.trigger_message)
}
inline std::string* TriggerConfig::mutable_trigger_message() {
  // @@protoc_insertion_point(field_mutable:service.TriggerConfig.trigger_message)
  return _internal_mutable_trigger_message();
}
inline const std::string& TriggerConfig::_internal_trigger_message() const {
  return trigger_message_.Get();
}
inline void TriggerConfig::_internal_set_trigger_message(const std::string& value) {
  
  trigger_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TriggerConfig::set_trigger_message(std::string&& value) {
  
  trigger_message_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.TriggerConfig.trigger_message)
}
inline void TriggerConfig::set_trigger_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  trigger_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.TriggerConfig.trigger_message)
}
inline void TriggerConfig::set_trigger_message(const char* value,
    size_t size) {
  
  trigger_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.TriggerConfig.trigger_message)
}
inline std::string* TriggerConfig::_internal_mutable_trigger_message() {
  
  return trigger_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TriggerConfig::release_trigger_message() {
  // @@protoc_insertion_point(field_release:service.TriggerConfig.trigger_message)
  return trigger_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TriggerConfig::set_allocated_trigger_message(std::string* trigger_message) {
  if (trigger_message != nullptr) {
    
  } else {
    
  }
  trigger_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trigger_message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.TriggerConfig.trigger_message)
}

// -------------------------------------------------------------------

// ActionConfig_Character

// string name = 1;
inline void ActionConfig_Character::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ActionConfig_Character::name() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Character.name)
  return _internal_name();
}
inline void ActionConfig_Character::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.Character.name)
}
inline std::string* ActionConfig_Character::mutable_name() {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Character.name)
  return _internal_mutable_name();
}
inline const std::string& ActionConfig_Character::_internal_name() const {
  return name_.Get();
}
inline void ActionConfig_Character::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ActionConfig_Character::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.ActionConfig.Character.name)
}
inline void ActionConfig_Character::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.Character.name)
}
inline void ActionConfig_Character::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.Character.name)
}
inline std::string* ActionConfig_Character::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ActionConfig_Character::release_name() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Character.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ActionConfig_Character::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Character.name)
}

// string bio = 2;
inline void ActionConfig_Character::clear_bio() {
  bio_.ClearToEmpty();
}
inline const std::string& ActionConfig_Character::bio() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Character.bio)
  return _internal_bio();
}
inline void ActionConfig_Character::set_bio(const std::string& value) {
  _internal_set_bio(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.Character.bio)
}
inline std::string* ActionConfig_Character::mutable_bio() {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Character.bio)
  return _internal_mutable_bio();
}
inline const std::string& ActionConfig_Character::_internal_bio() const {
  return bio_.Get();
}
inline void ActionConfig_Character::_internal_set_bio(const std::string& value) {
  
  bio_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ActionConfig_Character::set_bio(std::string&& value) {
  
  bio_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.ActionConfig.Character.bio)
}
inline void ActionConfig_Character::set_bio(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bio_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.Character.bio)
}
inline void ActionConfig_Character::set_bio(const char* value,
    size_t size) {
  
  bio_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.Character.bio)
}
inline std::string* ActionConfig_Character::_internal_mutable_bio() {
  
  return bio_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ActionConfig_Character::release_bio() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Character.bio)
  return bio_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ActionConfig_Character::set_allocated_bio(std::string* bio) {
  if (bio != nullptr) {
    
  } else {
    
  }
  bio_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bio,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Character.bio)
}

// -------------------------------------------------------------------

// ActionConfig_Object

// string name = 1;
inline void ActionConfig_Object::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ActionConfig_Object::name() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Object.name)
  return _internal_name();
}
inline void ActionConfig_Object::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.Object.name)
}
inline std::string* ActionConfig_Object::mutable_name() {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Object.name)
  return _internal_mutable_name();
}
inline const std::string& ActionConfig_Object::_internal_name() const {
  return name_.Get();
}
inline void ActionConfig_Object::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ActionConfig_Object::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.ActionConfig.Object.name)
}
inline void ActionConfig_Object::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.Object.name)
}
inline void ActionConfig_Object::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.Object.name)
}
inline std::string* ActionConfig_Object::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ActionConfig_Object::release_name() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Object.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ActionConfig_Object::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Object.name)
}

// string description = 2;
inline void ActionConfig_Object::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& ActionConfig_Object::description() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.Object.description)
  return _internal_description();
}
inline void ActionConfig_Object::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.Object.description)
}
inline std::string* ActionConfig_Object::mutable_description() {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.Object.description)
  return _internal_mutable_description();
}
inline const std::string& ActionConfig_Object::_internal_description() const {
  return description_.Get();
}
inline void ActionConfig_Object::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ActionConfig_Object::set_description(std::string&& value) {
  
  description_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.ActionConfig.Object.description)
}
inline void ActionConfig_Object::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.Object.description)
}
inline void ActionConfig_Object::set_description(const char* value,
    size_t size) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.Object.description)
}
inline std::string* ActionConfig_Object::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ActionConfig_Object::release_description() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.Object.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ActionConfig_Object::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.Object.description)
}

// -------------------------------------------------------------------

// ActionConfig

// repeated string actions = 1;
inline int ActionConfig::_internal_actions_size() const {
  return actions_.size();
}
inline int ActionConfig::actions_size() const {
  return _internal_actions_size();
}
inline void ActionConfig::clear_actions() {
  actions_.Clear();
}
inline std::string* ActionConfig::add_actions() {
  // @@protoc_insertion_point(field_add_mutable:service.ActionConfig.actions)
  return _internal_add_actions();
}
inline const std::string& ActionConfig::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline const std::string& ActionConfig::actions(int index) const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.actions)
  return _internal_actions(index);
}
inline std::string* ActionConfig::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.actions)
  return actions_.Mutable(index);
}
inline void ActionConfig::set_actions(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:service.ActionConfig.actions)
  actions_.Mutable(index)->assign(value);
}
inline void ActionConfig::set_actions(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:service.ActionConfig.actions)
  actions_.Mutable(index)->assign(std::move(value));
}
inline void ActionConfig::set_actions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  actions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.actions)
}
inline void ActionConfig::set_actions(int index, const char* value, size_t size) {
  actions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.actions)
}
inline std::string* ActionConfig::_internal_add_actions() {
  return actions_.Add();
}
inline void ActionConfig::add_actions(const std::string& value) {
  actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(std::string&& value) {
  actions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:service.ActionConfig.actions)
}
inline void ActionConfig::add_actions(const char* value, size_t size) {
  actions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:service.ActionConfig.actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ActionConfig::actions() const {
  // @@protoc_insertion_point(field_list:service.ActionConfig.actions)
  return actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ActionConfig::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.actions)
  return &actions_;
}

// repeated .service.ActionConfig.Character characters = 2;
inline int ActionConfig::_internal_characters_size() const {
  return characters_.size();
}
inline int ActionConfig::characters_size() const {
  return _internal_characters_size();
}
inline void ActionConfig::clear_characters() {
  characters_.Clear();
}
inline ::service::ActionConfig_Character* ActionConfig::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >*
ActionConfig::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.characters)
  return &characters_;
}
inline const ::service::ActionConfig_Character& ActionConfig::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::service::ActionConfig_Character& ActionConfig::characters(int index) const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.characters)
  return _internal_characters(index);
}
inline ::service::ActionConfig_Character* ActionConfig::_internal_add_characters() {
  return characters_.Add();
}
inline ::service::ActionConfig_Character* ActionConfig::add_characters() {
  // @@protoc_insertion_point(field_add:service.ActionConfig.characters)
  return _internal_add_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Character >&
ActionConfig::characters() const {
  // @@protoc_insertion_point(field_list:service.ActionConfig.characters)
  return characters_;
}

// repeated .service.ActionConfig.Object objects = 3;
inline int ActionConfig::_internal_objects_size() const {
  return objects_.size();
}
inline int ActionConfig::objects_size() const {
  return _internal_objects_size();
}
inline void ActionConfig::clear_objects() {
  objects_.Clear();
}
inline ::service::ActionConfig_Object* ActionConfig::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.objects)
  return objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >*
ActionConfig::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:service.ActionConfig.objects)
  return &objects_;
}
inline const ::service::ActionConfig_Object& ActionConfig::_internal_objects(int index) const {
  return objects_.Get(index);
}
inline const ::service::ActionConfig_Object& ActionConfig::objects(int index) const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.objects)
  return _internal_objects(index);
}
inline ::service::ActionConfig_Object* ActionConfig::_internal_add_objects() {
  return objects_.Add();
}
inline ::service::ActionConfig_Object* ActionConfig::add_objects() {
  // @@protoc_insertion_point(field_add:service.ActionConfig.objects)
  return _internal_add_objects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::service::ActionConfig_Object >&
ActionConfig::objects() const {
  // @@protoc_insertion_point(field_list:service.ActionConfig.objects)
  return objects_;
}

// string classification = 4;
inline void ActionConfig::clear_classification() {
  classification_.ClearToEmpty();
}
inline const std::string& ActionConfig::classification() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.classification)
  return _internal_classification();
}
inline void ActionConfig::set_classification(const std::string& value) {
  _internal_set_classification(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.classification)
}
inline std::string* ActionConfig::mutable_classification() {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.classification)
  return _internal_mutable_classification();
}
inline const std::string& ActionConfig::_internal_classification() const {
  return classification_.Get();
}
inline void ActionConfig::_internal_set_classification(const std::string& value) {
  
  classification_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ActionConfig::set_classification(std::string&& value) {
  
  classification_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.ActionConfig.classification)
}
inline void ActionConfig::set_classification(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  classification_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.classification)
}
inline void ActionConfig::set_classification(const char* value,
    size_t size) {
  
  classification_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.classification)
}
inline std::string* ActionConfig::_internal_mutable_classification() {
  
  return classification_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ActionConfig::release_classification() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.classification)
  return classification_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ActionConfig::set_allocated_classification(std::string* classification) {
  if (classification != nullptr) {
    
  } else {
    
  }
  classification_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), classification,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.classification)
}

// int32 context_level = 5;
inline void ActionConfig::clear_context_level() {
  context_level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionConfig::_internal_context_level() const {
  return context_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionConfig::context_level() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.context_level)
  return _internal_context_level();
}
inline void ActionConfig::_internal_set_context_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  context_level_ = value;
}
inline void ActionConfig::set_context_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_context_level(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.context_level)
}

// string current_attention_object = 6;
inline void ActionConfig::clear_current_attention_object() {
  current_attention_object_.ClearToEmpty();
}
inline const std::string& ActionConfig::current_attention_object() const {
  // @@protoc_insertion_point(field_get:service.ActionConfig.current_attention_object)
  return _internal_current_attention_object();
}
inline void ActionConfig::set_current_attention_object(const std::string& value) {
  _internal_set_current_attention_object(value);
  // @@protoc_insertion_point(field_set:service.ActionConfig.current_attention_object)
}
inline std::string* ActionConfig::mutable_current_attention_object() {
  // @@protoc_insertion_point(field_mutable:service.ActionConfig.current_attention_object)
  return _internal_mutable_current_attention_object();
}
inline const std::string& ActionConfig::_internal_current_attention_object() const {
  return current_attention_object_.Get();
}
inline void ActionConfig::_internal_set_current_attention_object(const std::string& value) {
  
  current_attention_object_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ActionConfig::set_current_attention_object(std::string&& value) {
  
  current_attention_object_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.ActionConfig.current_attention_object)
}
inline void ActionConfig::set_current_attention_object(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_attention_object_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.ActionConfig.current_attention_object)
}
inline void ActionConfig::set_current_attention_object(const char* value,
    size_t size) {
  
  current_attention_object_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.ActionConfig.current_attention_object)
}
inline std::string* ActionConfig::_internal_mutable_current_attention_object() {
  
  return current_attention_object_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ActionConfig::release_current_attention_object() {
  // @@protoc_insertion_point(field_release:service.ActionConfig.current_attention_object)
  return current_attention_object_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ActionConfig::set_allocated_current_attention_object(std::string* current_attention_object) {
  if (current_attention_object != nullptr) {
    
  } else {
    
  }
  current_attention_object_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_attention_object,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.ActionConfig.current_attention_object)
}

// -------------------------------------------------------------------

// STTRequest

// .service.AudioConfig audio_config = 1;
inline bool STTRequest::_internal_has_audio_config() const {
  return request_type_case() == kAudioConfig;
}
inline bool STTRequest::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void STTRequest::set_has_audio_config() {
  _oneof_case_[0] = kAudioConfig;
}
inline void STTRequest::clear_audio_config() {
  if (_internal_has_audio_config()) {
    if (GetArena() == nullptr) {
      delete request_type_.audio_config_;
    }
    clear_has_request_type();
  }
}
inline ::service::AudioConfig* STTRequest::release_audio_config() {
  // @@protoc_insertion_point(field_release:service.STTRequest.audio_config)
  if (_internal_has_audio_config()) {
    clear_has_request_type();
      ::service::AudioConfig* temp = request_type_.audio_config_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.audio_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::AudioConfig& STTRequest::_internal_audio_config() const {
  return _internal_has_audio_config()
      ? *request_type_.audio_config_
      : reinterpret_cast< ::service::AudioConfig&>(::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& STTRequest::audio_config() const {
  // @@protoc_insertion_point(field_get:service.STTRequest.audio_config)
  return _internal_audio_config();
}
inline ::service::AudioConfig* STTRequest::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.STTRequest.audio_config)
  if (_internal_has_audio_config()) {
    clear_has_request_type();
    ::service::AudioConfig* temp = request_type_.audio_config_;
    request_type_.audio_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void STTRequest::unsafe_arena_set_allocated_audio_config(::service::AudioConfig* audio_config) {
  clear_request_type();
  if (audio_config) {
    set_has_audio_config();
    request_type_.audio_config_ = audio_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.STTRequest.audio_config)
}
inline ::service::AudioConfig* STTRequest::_internal_mutable_audio_config() {
  if (!_internal_has_audio_config()) {
    clear_request_type();
    set_has_audio_config();
    request_type_.audio_config_ = CreateMaybeMessage< ::service::AudioConfig >(GetArena());
  }
  return request_type_.audio_config_;
}
inline ::service::AudioConfig* STTRequest::mutable_audio_config() {
  // @@protoc_insertion_point(field_mutable:service.STTRequest.audio_config)
  return _internal_mutable_audio_config();
}

// bytes audio_chunk = 2;
inline bool STTRequest::_internal_has_audio_chunk() const {
  return request_type_case() == kAudioChunk;
}
inline void STTRequest::set_has_audio_chunk() {
  _oneof_case_[0] = kAudioChunk;
}
inline void STTRequest::clear_audio_chunk() {
  if (_internal_has_audio_chunk()) {
    request_type_.audio_chunk_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_request_type();
  }
}
inline const std::string& STTRequest::audio_chunk() const {
  // @@protoc_insertion_point(field_get:service.STTRequest.audio_chunk)
  return _internal_audio_chunk();
}
inline void STTRequest::set_audio_chunk(const std::string& value) {
  _internal_set_audio_chunk(value);
  // @@protoc_insertion_point(field_set:service.STTRequest.audio_chunk)
}
inline std::string* STTRequest::mutable_audio_chunk() {
  // @@protoc_insertion_point(field_mutable:service.STTRequest.audio_chunk)
  return _internal_mutable_audio_chunk();
}
inline const std::string& STTRequest::_internal_audio_chunk() const {
  if (_internal_has_audio_chunk()) {
    return request_type_.audio_chunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void STTRequest::_internal_set_audio_chunk(const std::string& value) {
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    request_type_.audio_chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_type_.audio_chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void STTRequest::set_audio_chunk(std::string&& value) {
  // @@protoc_insertion_point(field_set:service.STTRequest.audio_chunk)
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    request_type_.audio_chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_type_.audio_chunk_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.STTRequest.audio_chunk)
}
inline void STTRequest::set_audio_chunk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    request_type_.audio_chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_type_.audio_chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.STTRequest.audio_chunk)
}
inline void STTRequest::set_audio_chunk(const void* value,
                             size_t size) {
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    request_type_.audio_chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_type_.audio_chunk_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.STTRequest.audio_chunk)
}
inline std::string* STTRequest::_internal_mutable_audio_chunk() {
  if (!_internal_has_audio_chunk()) {
    clear_request_type();
    set_has_audio_chunk();
    request_type_.audio_chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return request_type_.audio_chunk_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* STTRequest::release_audio_chunk() {
  // @@protoc_insertion_point(field_release:service.STTRequest.audio_chunk)
  if (_internal_has_audio_chunk()) {
    clear_has_request_type();
    return request_type_.audio_chunk_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void STTRequest::set_allocated_audio_chunk(std::string* audio_chunk) {
  if (has_request_type()) {
    clear_request_type();
  }
  if (audio_chunk != nullptr) {
    set_has_audio_chunk();
    request_type_.audio_chunk_.UnsafeSetDefault(audio_chunk);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(audio_chunk);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service.STTRequest.audio_chunk)
}

inline bool STTRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void STTRequest::clear_has_request_type() {
  _oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline STTRequest::RequestTypeCase STTRequest::request_type_case() const {
  return STTRequest::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// STTResponse

// string text = 1;
inline void STTResponse::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& STTResponse::text() const {
  // @@protoc_insertion_point(field_get:service.STTResponse.text)
  return _internal_text();
}
inline void STTResponse::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:service.STTResponse.text)
}
inline std::string* STTResponse::mutable_text() {
  // @@protoc_insertion_point(field_mutable:service.STTResponse.text)
  return _internal_mutable_text();
}
inline const std::string& STTResponse::_internal_text() const {
  return text_.Get();
}
inline void STTResponse::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void STTResponse::set_text(std::string&& value) {
  
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.STTResponse.text)
}
inline void STTResponse::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.STTResponse.text)
}
inline void STTResponse::set_text(const char* value,
    size_t size) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.STTResponse.text)
}
inline std::string* STTResponse::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* STTResponse::release_text() {
  // @@protoc_insertion_point(field_release:service.STTResponse.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void STTResponse::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.STTResponse.text)
}

// -------------------------------------------------------------------

// GetResponseRequest_GetResponseConfig

// string character_id = 2;
inline void GetResponseRequest_GetResponseConfig::clear_character_id() {
  character_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::character_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.character_id)
  return _internal_character_id();
}
inline void GetResponseRequest_GetResponseConfig::set_character_id(const std::string& value) {
  _internal_set_character_id(value);
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.character_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_character_id() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.character_id)
  return _internal_mutable_character_id();
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_character_id() const {
  return character_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_character_id(const std::string& value) {
  
  character_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_character_id(std::string&& value) {
  
  character_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseRequest.GetResponseConfig.character_id)
}
inline void GetResponseRequest_GetResponseConfig::set_character_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  character_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseRequest.GetResponseConfig.character_id)
}
inline void GetResponseRequest_GetResponseConfig::set_character_id(const char* value,
    size_t size) {
  
  character_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseRequest.GetResponseConfig.character_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_character_id() {
  
  return character_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_character_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.character_id)
  return character_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_character_id(std::string* character_id) {
  if (character_id != nullptr) {
    
  } else {
    
  }
  character_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), character_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.character_id)
}

// string api_key = 3;
inline void GetResponseRequest_GetResponseConfig::clear_api_key() {
  api_key_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::api_key() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.api_key)
  return _internal_api_key();
}
inline void GetResponseRequest_GetResponseConfig::set_api_key(const std::string& value) {
  _internal_set_api_key(value);
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.api_key)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_api_key() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.api_key)
  return _internal_mutable_api_key();
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_api_key() const {
  return api_key_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_api_key(const std::string& value) {
  
  api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_api_key(std::string&& value) {
  
  api_key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseRequest.GetResponseConfig.api_key)
}
inline void GetResponseRequest_GetResponseConfig::set_api_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseRequest.GetResponseConfig.api_key)
}
inline void GetResponseRequest_GetResponseConfig::set_api_key(const char* value,
    size_t size) {
  
  api_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseRequest.GetResponseConfig.api_key)
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_api_key() {
  
  return api_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_api_key() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.api_key)
  return api_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  api_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), api_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.api_key)
}

// string session_id = 4;
inline void GetResponseRequest_GetResponseConfig::clear_session_id() {
  session_id_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::session_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.session_id)
  return _internal_session_id();
}
inline void GetResponseRequest_GetResponseConfig::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.session_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_session_id() const {
  return session_id_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_session_id(const std::string& value) {
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_session_id(std::string&& value) {
  
  session_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseRequest.GetResponseConfig.session_id)
}
inline void GetResponseRequest_GetResponseConfig::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseRequest.GetResponseConfig.session_id)
}
inline void GetResponseRequest_GetResponseConfig::set_session_id(const char* value,
    size_t size) {
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseRequest.GetResponseConfig.session_id)
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_session_id() {
  
  return session_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_session_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.session_id)
  return session_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.session_id)
}

// .service.AudioConfig audio_config = 5;
inline bool GetResponseRequest_GetResponseConfig::_internal_has_audio_config() const {
  return this != internal_default_instance() && audio_config_ != nullptr;
}
inline bool GetResponseRequest_GetResponseConfig::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void GetResponseRequest_GetResponseConfig::clear_audio_config() {
  if (GetArena() == nullptr && audio_config_ != nullptr) {
    delete audio_config_;
  }
  audio_config_ = nullptr;
}
inline const ::service::AudioConfig& GetResponseRequest_GetResponseConfig::_internal_audio_config() const {
  const ::service::AudioConfig* p = audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::AudioConfig&>(
      ::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& GetResponseRequest_GetResponseConfig::audio_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.audio_config)
  return _internal_audio_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_audio_config(
    ::service::AudioConfig* audio_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_config_);
  }
  audio_config_ = audio_config;
  if (audio_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.audio_config)
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::release_audio_config() {
  
  ::service::AudioConfig* temp = audio_config_;
  audio_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.audio_config)
  
  ::service::AudioConfig* temp = audio_config_;
  audio_config_ = nullptr;
  return temp;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_audio_config() {
  
  if (audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::AudioConfig>(GetArena());
    audio_config_ = p;
  }
  return audio_config_;
}
inline ::service::AudioConfig* GetResponseRequest_GetResponseConfig::mutable_audio_config() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.audio_config)
  return _internal_mutable_audio_config();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_audio_config(::service::AudioConfig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.audio_config)
}

// .service.ActionConfig action_config = 6;
inline bool GetResponseRequest_GetResponseConfig::_internal_has_action_config() const {
  return this != internal_default_instance() && action_config_ != nullptr;
}
inline bool GetResponseRequest_GetResponseConfig::has_action_config() const {
  return _internal_has_action_config();
}
inline void GetResponseRequest_GetResponseConfig::clear_action_config() {
  if (GetArena() == nullptr && action_config_ != nullptr) {
    delete action_config_;
  }
  action_config_ = nullptr;
}
inline const ::service::ActionConfig& GetResponseRequest_GetResponseConfig::_internal_action_config() const {
  const ::service::ActionConfig* p = action_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::ActionConfig&>(
      ::service::_ActionConfig_default_instance_);
}
inline const ::service::ActionConfig& GetResponseRequest_GetResponseConfig::action_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.action_config)
  return _internal_action_config();
}
inline void GetResponseRequest_GetResponseConfig::unsafe_arena_set_allocated_action_config(
    ::service::ActionConfig* action_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_config_);
  }
  action_config_ = action_config;
  if (action_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseConfig.action_config)
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::release_action_config() {
  
  ::service::ActionConfig* temp = action_config_;
  action_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::unsafe_arena_release_action_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.action_config)
  
  ::service::ActionConfig* temp = action_config_;
  action_config_ = nullptr;
  return temp;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::_internal_mutable_action_config() {
  
  if (action_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::ActionConfig>(GetArena());
    action_config_ = p;
  }
  return action_config_;
}
inline ::service::ActionConfig* GetResponseRequest_GetResponseConfig::mutable_action_config() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.action_config)
  return _internal_mutable_action_config();
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_action_config(::service::ActionConfig* action_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete action_config_;
  }
  if (action_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(action_config);
    if (message_arena != submessage_arena) {
      action_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_config, submessage_arena);
    }
    
  } else {
    
  }
  action_config_ = action_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.action_config)
}

// string speaker = 7;
inline void GetResponseRequest_GetResponseConfig::clear_speaker() {
  speaker_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::speaker() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.speaker)
  return _internal_speaker();
}
inline void GetResponseRequest_GetResponseConfig::set_speaker(const std::string& value) {
  _internal_set_speaker(value);
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.speaker)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_speaker() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.speaker)
  return _internal_mutable_speaker();
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_speaker() const {
  return speaker_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_speaker(const std::string& value) {
  
  speaker_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_speaker(std::string&& value) {
  
  speaker_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseRequest.GetResponseConfig.speaker)
}
inline void GetResponseRequest_GetResponseConfig::set_speaker(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  speaker_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseRequest.GetResponseConfig.speaker)
}
inline void GetResponseRequest_GetResponseConfig::set_speaker(const char* value,
    size_t size) {
  
  speaker_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseRequest.GetResponseConfig.speaker)
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_speaker() {
  
  return speaker_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_speaker() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.speaker)
  return speaker_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_speaker(std::string* speaker) {
  if (speaker != nullptr) {
    
  } else {
    
  }
  speaker_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), speaker,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.speaker)
}

// string language_code = 8;
inline void GetResponseRequest_GetResponseConfig::clear_language_code() {
  language_code_.ClearToEmpty();
}
inline const std::string& GetResponseRequest_GetResponseConfig::language_code() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseConfig.language_code)
  return _internal_language_code();
}
inline void GetResponseRequest_GetResponseConfig::set_language_code(const std::string& value) {
  _internal_set_language_code(value);
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseConfig.language_code)
}
inline std::string* GetResponseRequest_GetResponseConfig::mutable_language_code() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseConfig.language_code)
  return _internal_mutable_language_code();
}
inline const std::string& GetResponseRequest_GetResponseConfig::_internal_language_code() const {
  return language_code_.Get();
}
inline void GetResponseRequest_GetResponseConfig::_internal_set_language_code(const std::string& value) {
  
  language_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_language_code(std::string&& value) {
  
  language_code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseRequest.GetResponseConfig.language_code)
}
inline void GetResponseRequest_GetResponseConfig::set_language_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  language_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseRequest.GetResponseConfig.language_code)
}
inline void GetResponseRequest_GetResponseConfig::set_language_code(const char* value,
    size_t size) {
  
  language_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseRequest.GetResponseConfig.language_code)
}
inline std::string* GetResponseRequest_GetResponseConfig::_internal_mutable_language_code() {
  
  return language_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseRequest_GetResponseConfig::release_language_code() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseConfig.language_code)
  return language_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseRequest_GetResponseConfig::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  language_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseConfig.language_code)
}

// -------------------------------------------------------------------

// GetResponseRequest_GetResponseData

// bytes audio_data = 1;
inline bool GetResponseRequest_GetResponseData::_internal_has_audio_data() const {
  return input_type_case() == kAudioData;
}
inline void GetResponseRequest_GetResponseData::set_has_audio_data() {
  _oneof_case_[0] = kAudioData;
}
inline void GetResponseRequest_GetResponseData::clear_audio_data() {
  if (_internal_has_audio_data()) {
    input_type_.audio_data_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_input_type();
  }
}
inline const std::string& GetResponseRequest_GetResponseData::audio_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.audio_data)
  return _internal_audio_data();
}
inline void GetResponseRequest_GetResponseData::set_audio_data(const std::string& value) {
  _internal_set_audio_data(value);
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.audio_data)
}
inline std::string* GetResponseRequest_GetResponseData::mutable_audio_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.audio_data)
  return _internal_mutable_audio_data();
}
inline const std::string& GetResponseRequest_GetResponseData::_internal_audio_data() const {
  if (_internal_has_audio_data()) {
    return input_type_.audio_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseRequest_GetResponseData::_internal_set_audio_data(const std::string& value) {
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    input_type_.audio_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_type_.audio_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseRequest_GetResponseData::set_audio_data(std::string&& value) {
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.audio_data)
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    input_type_.audio_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_type_.audio_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseRequest.GetResponseData.audio_data)
}
inline void GetResponseRequest_GetResponseData::set_audio_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    input_type_.audio_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_type_.audio_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseRequest.GetResponseData.audio_data)
}
inline void GetResponseRequest_GetResponseData::set_audio_data(const void* value,
                             size_t size) {
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    input_type_.audio_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_type_.audio_data_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseRequest.GetResponseData.audio_data)
}
inline std::string* GetResponseRequest_GetResponseData::_internal_mutable_audio_data() {
  if (!_internal_has_audio_data()) {
    clear_input_type();
    set_has_audio_data();
    input_type_.audio_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return input_type_.audio_data_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseRequest_GetResponseData::release_audio_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.audio_data)
  if (_internal_has_audio_data()) {
    clear_has_input_type();
    return input_type_.audio_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::set_allocated_audio_data(std::string* audio_data) {
  if (has_input_type()) {
    clear_input_type();
  }
  if (audio_data != nullptr) {
    set_has_audio_data();
    input_type_.audio_data_.UnsafeSetDefault(audio_data);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(audio_data);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseData.audio_data)
}

// string text_data = 2;
inline bool GetResponseRequest_GetResponseData::_internal_has_text_data() const {
  return input_type_case() == kTextData;
}
inline void GetResponseRequest_GetResponseData::set_has_text_data() {
  _oneof_case_[0] = kTextData;
}
inline void GetResponseRequest_GetResponseData::clear_text_data() {
  if (_internal_has_text_data()) {
    input_type_.text_data_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_input_type();
  }
}
inline const std::string& GetResponseRequest_GetResponseData::text_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.text_data)
  return _internal_text_data();
}
inline void GetResponseRequest_GetResponseData::set_text_data(const std::string& value) {
  _internal_set_text_data(value);
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.text_data)
}
inline std::string* GetResponseRequest_GetResponseData::mutable_text_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.text_data)
  return _internal_mutable_text_data();
}
inline const std::string& GetResponseRequest_GetResponseData::_internal_text_data() const {
  if (_internal_has_text_data()) {
    return input_type_.text_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseRequest_GetResponseData::_internal_set_text_data(const std::string& value) {
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    input_type_.text_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_type_.text_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseRequest_GetResponseData::set_text_data(std::string&& value) {
  // @@protoc_insertion_point(field_set:service.GetResponseRequest.GetResponseData.text_data)
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    input_type_.text_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_type_.text_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseRequest.GetResponseData.text_data)
}
inline void GetResponseRequest_GetResponseData::set_text_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    input_type_.text_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_type_.text_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseRequest.GetResponseData.text_data)
}
inline void GetResponseRequest_GetResponseData::set_text_data(const char* value,
                             size_t size) {
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    input_type_.text_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  input_type_.text_data_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseRequest.GetResponseData.text_data)
}
inline std::string* GetResponseRequest_GetResponseData::_internal_mutable_text_data() {
  if (!_internal_has_text_data()) {
    clear_input_type();
    set_has_text_data();
    input_type_.text_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return input_type_.text_data_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseRequest_GetResponseData::release_text_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.text_data)
  if (_internal_has_text_data()) {
    clear_has_input_type();
    return input_type_.text_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::set_allocated_text_data(std::string* text_data) {
  if (has_input_type()) {
    clear_input_type();
  }
  if (text_data != nullptr) {
    set_has_text_data();
    input_type_.text_data_.UnsafeSetDefault(text_data);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(text_data);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequest.GetResponseData.text_data)
}

// .service.TriggerConfig trigger_data = 3;
inline bool GetResponseRequest_GetResponseData::_internal_has_trigger_data() const {
  return input_type_case() == kTriggerData;
}
inline bool GetResponseRequest_GetResponseData::has_trigger_data() const {
  return _internal_has_trigger_data();
}
inline void GetResponseRequest_GetResponseData::set_has_trigger_data() {
  _oneof_case_[0] = kTriggerData;
}
inline void GetResponseRequest_GetResponseData::clear_trigger_data() {
  if (_internal_has_trigger_data()) {
    if (GetArena() == nullptr) {
      delete input_type_.trigger_data_;
    }
    clear_has_input_type();
  }
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::release_trigger_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.GetResponseData.trigger_data)
  if (_internal_has_trigger_data()) {
    clear_has_input_type();
      ::service::TriggerConfig* temp = input_type_.trigger_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    input_type_.trigger_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::TriggerConfig& GetResponseRequest_GetResponseData::_internal_trigger_data() const {
  return _internal_has_trigger_data()
      ? *input_type_.trigger_data_
      : reinterpret_cast< ::service::TriggerConfig&>(::service::_TriggerConfig_default_instance_);
}
inline const ::service::TriggerConfig& GetResponseRequest_GetResponseData::trigger_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.GetResponseData.trigger_data)
  return _internal_trigger_data();
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::unsafe_arena_release_trigger_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.GetResponseData.trigger_data)
  if (_internal_has_trigger_data()) {
    clear_has_input_type();
    ::service::TriggerConfig* temp = input_type_.trigger_data_;
    input_type_.trigger_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest_GetResponseData::unsafe_arena_set_allocated_trigger_data(::service::TriggerConfig* trigger_data) {
  clear_input_type();
  if (trigger_data) {
    set_has_trigger_data();
    input_type_.trigger_data_ = trigger_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.GetResponseData.trigger_data)
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::_internal_mutable_trigger_data() {
  if (!_internal_has_trigger_data()) {
    clear_input_type();
    set_has_trigger_data();
    input_type_.trigger_data_ = CreateMaybeMessage< ::service::TriggerConfig >(GetArena());
  }
  return input_type_.trigger_data_;
}
inline ::service::TriggerConfig* GetResponseRequest_GetResponseData::mutable_trigger_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.GetResponseData.trigger_data)
  return _internal_mutable_trigger_data();
}

inline bool GetResponseRequest_GetResponseData::has_input_type() const {
  return input_type_case() != INPUT_TYPE_NOT_SET;
}
inline void GetResponseRequest_GetResponseData::clear_has_input_type() {
  _oneof_case_[0] = INPUT_TYPE_NOT_SET;
}
inline GetResponseRequest_GetResponseData::InputTypeCase GetResponseRequest_GetResponseData::input_type_case() const {
  return GetResponseRequest_GetResponseData::InputTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseRequest

// .service.GetResponseRequest.GetResponseConfig get_response_config = 1;
inline bool GetResponseRequest::_internal_has_get_response_config() const {
  return request_type_case() == kGetResponseConfig;
}
inline bool GetResponseRequest::has_get_response_config() const {
  return _internal_has_get_response_config();
}
inline void GetResponseRequest::set_has_get_response_config() {
  _oneof_case_[0] = kGetResponseConfig;
}
inline void GetResponseRequest::clear_get_response_config() {
  if (_internal_has_get_response_config()) {
    if (GetArena() == nullptr) {
      delete request_type_.get_response_config_;
    }
    clear_has_request_type();
  }
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::release_get_response_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.get_response_config)
  if (_internal_has_get_response_config()) {
    clear_has_request_type();
      ::service::GetResponseRequest_GetResponseConfig* temp = request_type_.get_response_config_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.get_response_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseRequest_GetResponseConfig& GetResponseRequest::_internal_get_response_config() const {
  return _internal_has_get_response_config()
      ? *request_type_.get_response_config_
      : reinterpret_cast< ::service::GetResponseRequest_GetResponseConfig&>(::service::_GetResponseRequest_GetResponseConfig_default_instance_);
}
inline const ::service::GetResponseRequest_GetResponseConfig& GetResponseRequest::get_response_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.get_response_config)
  return _internal_get_response_config();
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::unsafe_arena_release_get_response_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.get_response_config)
  if (_internal_has_get_response_config()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseConfig* temp = request_type_.get_response_config_;
    request_type_.get_response_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest::unsafe_arena_set_allocated_get_response_config(::service::GetResponseRequest_GetResponseConfig* get_response_config) {
  clear_request_type();
  if (get_response_config) {
    set_has_get_response_config();
    request_type_.get_response_config_ = get_response_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.get_response_config)
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::_internal_mutable_get_response_config() {
  if (!_internal_has_get_response_config()) {
    clear_request_type();
    set_has_get_response_config();
    request_type_.get_response_config_ = CreateMaybeMessage< ::service::GetResponseRequest_GetResponseConfig >(GetArena());
  }
  return request_type_.get_response_config_;
}
inline ::service::GetResponseRequest_GetResponseConfig* GetResponseRequest::mutable_get_response_config() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.get_response_config)
  return _internal_mutable_get_response_config();
}

// .service.GetResponseRequest.GetResponseData get_response_data = 2;
inline bool GetResponseRequest::_internal_has_get_response_data() const {
  return request_type_case() == kGetResponseData;
}
inline bool GetResponseRequest::has_get_response_data() const {
  return _internal_has_get_response_data();
}
inline void GetResponseRequest::set_has_get_response_data() {
  _oneof_case_[0] = kGetResponseData;
}
inline void GetResponseRequest::clear_get_response_data() {
  if (_internal_has_get_response_data()) {
    if (GetArena() == nullptr) {
      delete request_type_.get_response_data_;
    }
    clear_has_request_type();
  }
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::release_get_response_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequest.get_response_data)
  if (_internal_has_get_response_data()) {
    clear_has_request_type();
      ::service::GetResponseRequest_GetResponseData* temp = request_type_.get_response_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.get_response_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseRequest_GetResponseData& GetResponseRequest::_internal_get_response_data() const {
  return _internal_has_get_response_data()
      ? *request_type_.get_response_data_
      : reinterpret_cast< ::service::GetResponseRequest_GetResponseData&>(::service::_GetResponseRequest_GetResponseData_default_instance_);
}
inline const ::service::GetResponseRequest_GetResponseData& GetResponseRequest::get_response_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequest.get_response_data)
  return _internal_get_response_data();
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::unsafe_arena_release_get_response_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseRequest.get_response_data)
  if (_internal_has_get_response_data()) {
    clear_has_request_type();
    ::service::GetResponseRequest_GetResponseData* temp = request_type_.get_response_data_;
    request_type_.get_response_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseRequest::unsafe_arena_set_allocated_get_response_data(::service::GetResponseRequest_GetResponseData* get_response_data) {
  clear_request_type();
  if (get_response_data) {
    set_has_get_response_data();
    request_type_.get_response_data_ = get_response_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequest.get_response_data)
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::_internal_mutable_get_response_data() {
  if (!_internal_has_get_response_data()) {
    clear_request_type();
    set_has_get_response_data();
    request_type_.get_response_data_ = CreateMaybeMessage< ::service::GetResponseRequest_GetResponseData >(GetArena());
  }
  return request_type_.get_response_data_;
}
inline ::service::GetResponseRequest_GetResponseData* GetResponseRequest::mutable_get_response_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequest.get_response_data)
  return _internal_mutable_get_response_data();
}

inline bool GetResponseRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void GetResponseRequest::clear_has_request_type() {
  _oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline GetResponseRequest::RequestTypeCase GetResponseRequest::request_type_case() const {
  return GetResponseRequest::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseRequestSingle

// .service.GetResponseRequest response_config = 1;
inline bool GetResponseRequestSingle::_internal_has_response_config() const {
  return this != internal_default_instance() && response_config_ != nullptr;
}
inline bool GetResponseRequestSingle::has_response_config() const {
  return _internal_has_response_config();
}
inline void GetResponseRequestSingle::clear_response_config() {
  if (GetArena() == nullptr && response_config_ != nullptr) {
    delete response_config_;
  }
  response_config_ = nullptr;
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::_internal_response_config() const {
  const ::service::GetResponseRequest* p = response_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::GetResponseRequest&>(
      ::service::_GetResponseRequest_default_instance_);
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::response_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequestSingle.response_config)
  return _internal_response_config();
}
inline void GetResponseRequestSingle::unsafe_arena_set_allocated_response_config(
    ::service::GetResponseRequest* response_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_config_);
  }
  response_config_ = response_config;
  if (response_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequestSingle.response_config)
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::release_response_config() {
  
  ::service::GetResponseRequest* temp = response_config_;
  response_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::unsafe_arena_release_response_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequestSingle.response_config)
  
  ::service::GetResponseRequest* temp = response_config_;
  response_config_ = nullptr;
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::_internal_mutable_response_config() {
  
  if (response_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::GetResponseRequest>(GetArena());
    response_config_ = p;
  }
  return response_config_;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::mutable_response_config() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequestSingle.response_config)
  return _internal_mutable_response_config();
}
inline void GetResponseRequestSingle::set_allocated_response_config(::service::GetResponseRequest* response_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete response_config_;
  }
  if (response_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(response_config);
    if (message_arena != submessage_arena) {
      response_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_config, submessage_arena);
    }
    
  } else {
    
  }
  response_config_ = response_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequestSingle.response_config)
}

// .service.GetResponseRequest response_data = 2;
inline bool GetResponseRequestSingle::_internal_has_response_data() const {
  return this != internal_default_instance() && response_data_ != nullptr;
}
inline bool GetResponseRequestSingle::has_response_data() const {
  return _internal_has_response_data();
}
inline void GetResponseRequestSingle::clear_response_data() {
  if (GetArena() == nullptr && response_data_ != nullptr) {
    delete response_data_;
  }
  response_data_ = nullptr;
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::_internal_response_data() const {
  const ::service::GetResponseRequest* p = response_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::GetResponseRequest&>(
      ::service::_GetResponseRequest_default_instance_);
}
inline const ::service::GetResponseRequest& GetResponseRequestSingle::response_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseRequestSingle.response_data)
  return _internal_response_data();
}
inline void GetResponseRequestSingle::unsafe_arena_set_allocated_response_data(
    ::service::GetResponseRequest* response_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_data_);
  }
  response_data_ = response_data;
  if (response_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseRequestSingle.response_data)
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::release_response_data() {
  
  ::service::GetResponseRequest* temp = response_data_;
  response_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::unsafe_arena_release_response_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseRequestSingle.response_data)
  
  ::service::GetResponseRequest* temp = response_data_;
  response_data_ = nullptr;
  return temp;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::_internal_mutable_response_data() {
  
  if (response_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::GetResponseRequest>(GetArena());
    response_data_ = p;
  }
  return response_data_;
}
inline ::service::GetResponseRequest* GetResponseRequestSingle::mutable_response_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseRequestSingle.response_data)
  return _internal_mutable_response_data();
}
inline void GetResponseRequestSingle::set_allocated_response_data(::service::GetResponseRequest* response_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete response_data_;
  }
  if (response_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(response_data);
    if (message_arena != submessage_arena) {
      response_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_data, submessage_arena);
    }
    
  } else {
    
  }
  response_data_ = response_data;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseRequestSingle.response_data)
}

// -------------------------------------------------------------------

// GetResponseResponse_AudioResponse

// bytes audio_data = 1;
inline void GetResponseResponse_AudioResponse::clear_audio_data() {
  audio_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::audio_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.audio_data)
  return _internal_audio_data();
}
inline void GetResponseResponse_AudioResponse::set_audio_data(const std::string& value) {
  _internal_set_audio_data(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.audio_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_audio_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.audio_data)
  return _internal_mutable_audio_data();
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_audio_data() const {
  return audio_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_audio_data(const std::string& value) {
  
  audio_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse_AudioResponse::set_audio_data(std::string&& value) {
  
  audio_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.AudioResponse.audio_data)
}
inline void GetResponseResponse_AudioResponse::set_audio_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  audio_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.AudioResponse.audio_data)
}
inline void GetResponseResponse_AudioResponse::set_audio_data(const void* value,
    size_t size) {
  
  audio_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.AudioResponse.audio_data)
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_audio_data() {
  
  return audio_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse_AudioResponse::release_audio_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.audio_data)
  return audio_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseResponse_AudioResponse::set_allocated_audio_data(std::string* audio_data) {
  if (audio_data != nullptr) {
    
  } else {
    
  }
  audio_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.audio_data)
}

// .service.AudioConfig audio_config = 2;
inline bool GetResponseResponse_AudioResponse::_internal_has_audio_config() const {
  return this != internal_default_instance() && audio_config_ != nullptr;
}
inline bool GetResponseResponse_AudioResponse::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void GetResponseResponse_AudioResponse::clear_audio_config() {
  if (GetArena() == nullptr && audio_config_ != nullptr) {
    delete audio_config_;
  }
  audio_config_ = nullptr;
}
inline const ::service::AudioConfig& GetResponseResponse_AudioResponse::_internal_audio_config() const {
  const ::service::AudioConfig* p = audio_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::AudioConfig&>(
      ::service::_AudioConfig_default_instance_);
}
inline const ::service::AudioConfig& GetResponseResponse_AudioResponse::audio_config() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.audio_config)
  return _internal_audio_config();
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_audio_config(
    ::service::AudioConfig* audio_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_config_);
  }
  audio_config_ = audio_config;
  if (audio_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.audio_config)
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::release_audio_config() {
  
  ::service::AudioConfig* temp = audio_config_;
  audio_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.audio_config)
  
  ::service::AudioConfig* temp = audio_config_;
  audio_config_ = nullptr;
  return temp;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::_internal_mutable_audio_config() {
  
  if (audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::AudioConfig>(GetArena());
    audio_config_ = p;
  }
  return audio_config_;
}
inline ::service::AudioConfig* GetResponseResponse_AudioResponse::mutable_audio_config() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.audio_config)
  return _internal_mutable_audio_config();
}
inline void GetResponseResponse_AudioResponse::set_allocated_audio_config(::service::AudioConfig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.audio_config)
}

// string text_data = 3;
inline void GetResponseResponse_AudioResponse::clear_text_data() {
  text_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::text_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.text_data)
  return _internal_text_data();
}
inline void GetResponseResponse_AudioResponse::set_text_data(const std::string& value) {
  _internal_set_text_data(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.text_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_text_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.text_data)
  return _internal_mutable_text_data();
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_text_data() const {
  return text_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_text_data(const std::string& value) {
  
  text_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse_AudioResponse::set_text_data(std::string&& value) {
  
  text_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.AudioResponse.text_data)
}
inline void GetResponseResponse_AudioResponse::set_text_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.AudioResponse.text_data)
}
inline void GetResponseResponse_AudioResponse::set_text_data(const char* value,
    size_t size) {
  
  text_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.AudioResponse.text_data)
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_text_data() {
  
  return text_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse_AudioResponse::release_text_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.text_data)
  return text_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseResponse_AudioResponse::set_allocated_text_data(std::string* text_data) {
  if (text_data != nullptr) {
    
  } else {
    
  }
  text_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.text_data)
}

// bool end_of_response = 4;
inline void GetResponseResponse_AudioResponse::clear_end_of_response() {
  end_of_response_ = false;
}
inline bool GetResponseResponse_AudioResponse::_internal_end_of_response() const {
  return end_of_response_;
}
inline bool GetResponseResponse_AudioResponse::end_of_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.end_of_response)
  return _internal_end_of_response();
}
inline void GetResponseResponse_AudioResponse::_internal_set_end_of_response(bool value) {
  
  end_of_response_ = value;
}
inline void GetResponseResponse_AudioResponse::set_end_of_response(bool value) {
  _internal_set_end_of_response(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.end_of_response)
}

// string face_data = 5;
inline void GetResponseResponse_AudioResponse::clear_face_data() {
  face_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_AudioResponse::face_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.face_data)
  return _internal_face_data();
}
inline void GetResponseResponse_AudioResponse::set_face_data(const std::string& value) {
  _internal_set_face_data(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.AudioResponse.face_data)
}
inline std::string* GetResponseResponse_AudioResponse::mutable_face_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.face_data)
  return _internal_mutable_face_data();
}
inline const std::string& GetResponseResponse_AudioResponse::_internal_face_data() const {
  return face_data_.Get();
}
inline void GetResponseResponse_AudioResponse::_internal_set_face_data(const std::string& value) {
  
  face_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse_AudioResponse::set_face_data(std::string&& value) {
  
  face_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.AudioResponse.face_data)
}
inline void GetResponseResponse_AudioResponse::set_face_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  face_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.AudioResponse.face_data)
}
inline void GetResponseResponse_AudioResponse::set_face_data(const char* value,
    size_t size) {
  
  face_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.AudioResponse.face_data)
}
inline std::string* GetResponseResponse_AudioResponse::_internal_mutable_face_data() {
  
  return face_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse_AudioResponse::release_face_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.face_data)
  return face_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseResponse_AudioResponse::set_allocated_face_data(std::string* face_data) {
  if (face_data != nullptr) {
    
  } else {
    
  }
  face_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), face_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.AudioResponse.face_data)
}

// .service.VisemesData visemes_data = 6;
inline bool GetResponseResponse_AudioResponse::_internal_has_visemes_data() const {
  return face_data_type_case() == kVisemesData;
}
inline bool GetResponseResponse_AudioResponse::has_visemes_data() const {
  return _internal_has_visemes_data();
}
inline void GetResponseResponse_AudioResponse::set_has_visemes_data() {
  _oneof_case_[0] = kVisemesData;
}
inline void GetResponseResponse_AudioResponse::clear_visemes_data() {
  if (_internal_has_visemes_data()) {
    if (GetArena() == nullptr) {
      delete face_data_type_.visemes_data_;
    }
    clear_has_face_data_type();
  }
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::release_visemes_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.visemes_data)
  if (_internal_has_visemes_data()) {
    clear_has_face_data_type();
      ::service::VisemesData* temp = face_data_type_.visemes_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    face_data_type_.visemes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::VisemesData& GetResponseResponse_AudioResponse::_internal_visemes_data() const {
  return _internal_has_visemes_data()
      ? *face_data_type_.visemes_data_
      : reinterpret_cast< ::service::VisemesData&>(::service::_VisemesData_default_instance_);
}
inline const ::service::VisemesData& GetResponseResponse_AudioResponse::visemes_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.visemes_data)
  return _internal_visemes_data();
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::unsafe_arena_release_visemes_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.AudioResponse.visemes_data)
  if (_internal_has_visemes_data()) {
    clear_has_face_data_type();
    ::service::VisemesData* temp = face_data_type_.visemes_data_;
    face_data_type_.visemes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_visemes_data(::service::VisemesData* visemes_data) {
  clear_face_data_type();
  if (visemes_data) {
    set_has_visemes_data();
    face_data_type_.visemes_data_ = visemes_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.visemes_data)
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::_internal_mutable_visemes_data() {
  if (!_internal_has_visemes_data()) {
    clear_face_data_type();
    set_has_visemes_data();
    face_data_type_.visemes_data_ = CreateMaybeMessage< ::service::VisemesData >(GetArena());
  }
  return face_data_type_.visemes_data_;
}
inline ::service::VisemesData* GetResponseResponse_AudioResponse::mutable_visemes_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.visemes_data)
  return _internal_mutable_visemes_data();
}

// .service.BlendShapesData blendshapes_data = 7;
inline bool GetResponseResponse_AudioResponse::_internal_has_blendshapes_data() const {
  return face_data_type_case() == kBlendshapesData;
}
inline bool GetResponseResponse_AudioResponse::has_blendshapes_data() const {
  return _internal_has_blendshapes_data();
}
inline void GetResponseResponse_AudioResponse::set_has_blendshapes_data() {
  _oneof_case_[0] = kBlendshapesData;
}
inline void GetResponseResponse_AudioResponse::clear_blendshapes_data() {
  if (_internal_has_blendshapes_data()) {
    if (GetArena() == nullptr) {
      delete face_data_type_.blendshapes_data_;
    }
    clear_has_face_data_type();
  }
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::release_blendshapes_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.AudioResponse.blendshapes_data)
  if (_internal_has_blendshapes_data()) {
    clear_has_face_data_type();
      ::service::BlendShapesData* temp = face_data_type_.blendshapes_data_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    face_data_type_.blendshapes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::BlendShapesData& GetResponseResponse_AudioResponse::_internal_blendshapes_data() const {
  return _internal_has_blendshapes_data()
      ? *face_data_type_.blendshapes_data_
      : reinterpret_cast< ::service::BlendShapesData&>(::service::_BlendShapesData_default_instance_);
}
inline const ::service::BlendShapesData& GetResponseResponse_AudioResponse::blendshapes_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.AudioResponse.blendshapes_data)
  return _internal_blendshapes_data();
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::unsafe_arena_release_blendshapes_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.AudioResponse.blendshapes_data)
  if (_internal_has_blendshapes_data()) {
    clear_has_face_data_type();
    ::service::BlendShapesData* temp = face_data_type_.blendshapes_data_;
    face_data_type_.blendshapes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse_AudioResponse::unsafe_arena_set_allocated_blendshapes_data(::service::BlendShapesData* blendshapes_data) {
  clear_face_data_type();
  if (blendshapes_data) {
    set_has_blendshapes_data();
    face_data_type_.blendshapes_data_ = blendshapes_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.AudioResponse.blendshapes_data)
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::_internal_mutable_blendshapes_data() {
  if (!_internal_has_blendshapes_data()) {
    clear_face_data_type();
    set_has_blendshapes_data();
    face_data_type_.blendshapes_data_ = CreateMaybeMessage< ::service::BlendShapesData >(GetArena());
  }
  return face_data_type_.blendshapes_data_;
}
inline ::service::BlendShapesData* GetResponseResponse_AudioResponse::mutable_blendshapes_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.AudioResponse.blendshapes_data)
  return _internal_mutable_blendshapes_data();
}

inline bool GetResponseResponse_AudioResponse::has_face_data_type() const {
  return face_data_type_case() != FACE_DATA_TYPE_NOT_SET;
}
inline void GetResponseResponse_AudioResponse::clear_has_face_data_type() {
  _oneof_case_[0] = FACE_DATA_TYPE_NOT_SET;
}
inline GetResponseResponse_AudioResponse::FaceDataTypeCase GetResponseResponse_AudioResponse::face_data_type_case() const {
  return GetResponseResponse_AudioResponse::FaceDataTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetResponseResponse_ActionResponse

// string action = 1;
inline void GetResponseResponse_ActionResponse::clear_action() {
  action_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_ActionResponse::action() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.ActionResponse.action)
  return _internal_action();
}
inline void GetResponseResponse_ActionResponse::set_action(const std::string& value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.ActionResponse.action)
}
inline std::string* GetResponseResponse_ActionResponse::mutable_action() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.ActionResponse.action)
  return _internal_mutable_action();
}
inline const std::string& GetResponseResponse_ActionResponse::_internal_action() const {
  return action_.Get();
}
inline void GetResponseResponse_ActionResponse::_internal_set_action(const std::string& value) {
  
  action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse_ActionResponse::set_action(std::string&& value) {
  
  action_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.ActionResponse.action)
}
inline void GetResponseResponse_ActionResponse::set_action(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.ActionResponse.action)
}
inline void GetResponseResponse_ActionResponse::set_action(const char* value,
    size_t size) {
  
  action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.ActionResponse.action)
}
inline std::string* GetResponseResponse_ActionResponse::_internal_mutable_action() {
  
  return action_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse_ActionResponse::release_action() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.ActionResponse.action)
  return action_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseResponse_ActionResponse::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.ActionResponse.action)
}

// -------------------------------------------------------------------

// GetResponseResponse_BehaviorTreeResponse

// string bt_code = 1;
inline void GetResponseResponse_BehaviorTreeResponse::clear_bt_code() {
  bt_code_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::bt_code() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _internal_bt_code();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_bt_code(const std::string& value) {
  _internal_set_bt_code(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_bt_code() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return _internal_mutable_bt_code();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_bt_code() const {
  return bt_code_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_bt_code(const std::string& value) {
  
  bt_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse_BehaviorTreeResponse::set_bt_code(std::string&& value) {
  
  bt_code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}
inline void GetResponseResponse_BehaviorTreeResponse::set_bt_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bt_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}
inline void GetResponseResponse_BehaviorTreeResponse::set_bt_code(const char* value,
    size_t size) {
  
  bt_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_bt_code() {
  
  return bt_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_bt_code() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
  return bt_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_bt_code(std::string* bt_code) {
  if (bt_code != nullptr) {
    
  } else {
    
  }
  bt_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bt_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.bt_code)
}

// string bt_constants = 2;
inline void GetResponseResponse_BehaviorTreeResponse::clear_bt_constants() {
  bt_constants_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::bt_constants() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _internal_bt_constants();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_bt_constants(const std::string& value) {
  _internal_set_bt_constants(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_bt_constants() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return _internal_mutable_bt_constants();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_bt_constants() const {
  return bt_constants_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_bt_constants(const std::string& value) {
  
  bt_constants_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse_BehaviorTreeResponse::set_bt_constants(std::string&& value) {
  
  bt_constants_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}
inline void GetResponseResponse_BehaviorTreeResponse::set_bt_constants(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bt_constants_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}
inline void GetResponseResponse_BehaviorTreeResponse::set_bt_constants(const char* value,
    size_t size) {
  
  bt_constants_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_bt_constants() {
  
  return bt_constants_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_bt_constants() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
  return bt_constants_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_bt_constants(std::string* bt_constants) {
  if (bt_constants != nullptr) {
    
  } else {
    
  }
  bt_constants_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bt_constants,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.bt_constants)
}

// string narrative_section_id = 3;
inline void GetResponseResponse_BehaviorTreeResponse::clear_narrative_section_id() {
  narrative_section_id_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::narrative_section_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _internal_narrative_section_id();
}
inline void GetResponseResponse_BehaviorTreeResponse::set_narrative_section_id(const std::string& value) {
  _internal_set_narrative_section_id(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::mutable_narrative_section_id() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return _internal_mutable_narrative_section_id();
}
inline const std::string& GetResponseResponse_BehaviorTreeResponse::_internal_narrative_section_id() const {
  return narrative_section_id_.Get();
}
inline void GetResponseResponse_BehaviorTreeResponse::_internal_set_narrative_section_id(const std::string& value) {
  
  narrative_section_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse_BehaviorTreeResponse::set_narrative_section_id(std::string&& value) {
  
  narrative_section_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}
inline void GetResponseResponse_BehaviorTreeResponse::set_narrative_section_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  narrative_section_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}
inline void GetResponseResponse_BehaviorTreeResponse::set_narrative_section_id(const char* value,
    size_t size) {
  
  narrative_section_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::_internal_mutable_narrative_section_id() {
  
  return narrative_section_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse_BehaviorTreeResponse::release_narrative_section_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
  return narrative_section_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseResponse_BehaviorTreeResponse::set_allocated_narrative_section_id(std::string* narrative_section_id) {
  if (narrative_section_id != nullptr) {
    
  } else {
    
  }
  narrative_section_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), narrative_section_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.BehaviorTreeResponse.narrative_section_id)
}

// -------------------------------------------------------------------

// GetResponseResponse_UserTranscript

// string text_data = 1;
inline void GetResponseResponse_UserTranscript::clear_text_data() {
  text_data_.ClearToEmpty();
}
inline const std::string& GetResponseResponse_UserTranscript::text_data() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.text_data)
  return _internal_text_data();
}
inline void GetResponseResponse_UserTranscript::set_text_data(const std::string& value) {
  _internal_set_text_data(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.text_data)
}
inline std::string* GetResponseResponse_UserTranscript::mutable_text_data() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.UserTranscript.text_data)
  return _internal_mutable_text_data();
}
inline const std::string& GetResponseResponse_UserTranscript::_internal_text_data() const {
  return text_data_.Get();
}
inline void GetResponseResponse_UserTranscript::_internal_set_text_data(const std::string& value) {
  
  text_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse_UserTranscript::set_text_data(std::string&& value) {
  
  text_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.UserTranscript.text_data)
}
inline void GetResponseResponse_UserTranscript::set_text_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.UserTranscript.text_data)
}
inline void GetResponseResponse_UserTranscript::set_text_data(const char* value,
    size_t size) {
  
  text_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.UserTranscript.text_data)
}
inline std::string* GetResponseResponse_UserTranscript::_internal_mutable_text_data() {
  
  return text_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse_UserTranscript::release_text_data() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.UserTranscript.text_data)
  return text_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseResponse_UserTranscript::set_allocated_text_data(std::string* text_data) {
  if (text_data != nullptr) {
    
  } else {
    
  }
  text_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.UserTranscript.text_data)
}

// bool is_final = 2;
inline void GetResponseResponse_UserTranscript::clear_is_final() {
  is_final_ = false;
}
inline bool GetResponseResponse_UserTranscript::_internal_is_final() const {
  return is_final_;
}
inline bool GetResponseResponse_UserTranscript::is_final() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.is_final)
  return _internal_is_final();
}
inline void GetResponseResponse_UserTranscript::_internal_set_is_final(bool value) {
  
  is_final_ = value;
}
inline void GetResponseResponse_UserTranscript::set_is_final(bool value) {
  _internal_set_is_final(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.is_final)
}

// bool end_of_response = 3;
inline void GetResponseResponse_UserTranscript::clear_end_of_response() {
  end_of_response_ = false;
}
inline bool GetResponseResponse_UserTranscript::_internal_end_of_response() const {
  return end_of_response_;
}
inline bool GetResponseResponse_UserTranscript::end_of_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.UserTranscript.end_of_response)
  return _internal_end_of_response();
}
inline void GetResponseResponse_UserTranscript::_internal_set_end_of_response(bool value) {
  
  end_of_response_ = value;
}
inline void GetResponseResponse_UserTranscript::set_end_of_response(bool value) {
  _internal_set_end_of_response(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.UserTranscript.end_of_response)
}

// -------------------------------------------------------------------

// GetResponseResponse

// string session_id = 1;
inline void GetResponseResponse::clear_session_id() {
  session_id_.ClearToEmpty();
}
inline const std::string& GetResponseResponse::session_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.session_id)
  return _internal_session_id();
}
inline void GetResponseResponse::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.session_id)
}
inline std::string* GetResponseResponse::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& GetResponseResponse::_internal_session_id() const {
  return session_id_.Get();
}
inline void GetResponseResponse::_internal_set_session_id(const std::string& value) {
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse::set_session_id(std::string&& value) {
  
  session_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.session_id)
}
inline void GetResponseResponse::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.session_id)
}
inline void GetResponseResponse::set_session_id(const char* value,
    size_t size) {
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.session_id)
}
inline std::string* GetResponseResponse::_internal_mutable_session_id() {
  
  return session_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.session_id)
  return session_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetResponseResponse::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.session_id)
}

// .service.GetResponseResponse.ActionResponse action_response = 2;
inline bool GetResponseResponse::_internal_has_action_response() const {
  return response_type_case() == kActionResponse;
}
inline bool GetResponseResponse::has_action_response() const {
  return _internal_has_action_response();
}
inline void GetResponseResponse::set_has_action_response() {
  _oneof_case_[0] = kActionResponse;
}
inline void GetResponseResponse::clear_action_response() {
  if (_internal_has_action_response()) {
    if (GetArena() == nullptr) {
      delete response_type_.action_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::release_action_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.action_response)
  if (_internal_has_action_response()) {
    clear_has_response_type();
      ::service::GetResponseResponse_ActionResponse* temp = response_type_.action_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_type_.action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_ActionResponse& GetResponseResponse::_internal_action_response() const {
  return _internal_has_action_response()
      ? *response_type_.action_response_
      : reinterpret_cast< ::service::GetResponseResponse_ActionResponse&>(::service::_GetResponseResponse_ActionResponse_default_instance_);
}
inline const ::service::GetResponseResponse_ActionResponse& GetResponseResponse::action_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.action_response)
  return _internal_action_response();
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::unsafe_arena_release_action_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.action_response)
  if (_internal_has_action_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_ActionResponse* temp = response_type_.action_response_;
    response_type_.action_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_action_response(::service::GetResponseResponse_ActionResponse* action_response) {
  clear_response_type();
  if (action_response) {
    set_has_action_response();
    response_type_.action_response_ = action_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.action_response)
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::_internal_mutable_action_response() {
  if (!_internal_has_action_response()) {
    clear_response_type();
    set_has_action_response();
    response_type_.action_response_ = CreateMaybeMessage< ::service::GetResponseResponse_ActionResponse >(GetArena());
  }
  return response_type_.action_response_;
}
inline ::service::GetResponseResponse_ActionResponse* GetResponseResponse::mutable_action_response() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.action_response)
  return _internal_mutable_action_response();
}

// .service.GetResponseResponse.AudioResponse audio_response = 3;
inline bool GetResponseResponse::_internal_has_audio_response() const {
  return response_type_case() == kAudioResponse;
}
inline bool GetResponseResponse::has_audio_response() const {
  return _internal_has_audio_response();
}
inline void GetResponseResponse::set_has_audio_response() {
  _oneof_case_[0] = kAudioResponse;
}
inline void GetResponseResponse::clear_audio_response() {
  if (_internal_has_audio_response()) {
    if (GetArena() == nullptr) {
      delete response_type_.audio_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::release_audio_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.audio_response)
  if (_internal_has_audio_response()) {
    clear_has_response_type();
      ::service::GetResponseResponse_AudioResponse* temp = response_type_.audio_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_type_.audio_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_AudioResponse& GetResponseResponse::_internal_audio_response() const {
  return _internal_has_audio_response()
      ? *response_type_.audio_response_
      : reinterpret_cast< ::service::GetResponseResponse_AudioResponse&>(::service::_GetResponseResponse_AudioResponse_default_instance_);
}
inline const ::service::GetResponseResponse_AudioResponse& GetResponseResponse::audio_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.audio_response)
  return _internal_audio_response();
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::unsafe_arena_release_audio_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.audio_response)
  if (_internal_has_audio_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_AudioResponse* temp = response_type_.audio_response_;
    response_type_.audio_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_audio_response(::service::GetResponseResponse_AudioResponse* audio_response) {
  clear_response_type();
  if (audio_response) {
    set_has_audio_response();
    response_type_.audio_response_ = audio_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.audio_response)
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::_internal_mutable_audio_response() {
  if (!_internal_has_audio_response()) {
    clear_response_type();
    set_has_audio_response();
    response_type_.audio_response_ = CreateMaybeMessage< ::service::GetResponseResponse_AudioResponse >(GetArena());
  }
  return response_type_.audio_response_;
}
inline ::service::GetResponseResponse_AudioResponse* GetResponseResponse::mutable_audio_response() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.audio_response)
  return _internal_mutable_audio_response();
}

// string debug_log = 4;
inline bool GetResponseResponse::_internal_has_debug_log() const {
  return response_type_case() == kDebugLog;
}
inline void GetResponseResponse::set_has_debug_log() {
  _oneof_case_[0] = kDebugLog;
}
inline void GetResponseResponse::clear_debug_log() {
  if (_internal_has_debug_log()) {
    response_type_.debug_log_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::debug_log() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.debug_log)
  return _internal_debug_log();
}
inline void GetResponseResponse::set_debug_log(const std::string& value) {
  _internal_set_debug_log(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.debug_log)
}
inline std::string* GetResponseResponse::mutable_debug_log() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.debug_log)
  return _internal_mutable_debug_log();
}
inline const std::string& GetResponseResponse::_internal_debug_log() const {
  if (_internal_has_debug_log()) {
    return response_type_.debug_log_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseResponse::_internal_set_debug_log(const std::string& value) {
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    response_type_.debug_log_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.debug_log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse::set_debug_log(std::string&& value) {
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.debug_log)
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    response_type_.debug_log_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.debug_log_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.debug_log)
}
inline void GetResponseResponse::set_debug_log(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    response_type_.debug_log_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.debug_log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.debug_log)
}
inline void GetResponseResponse::set_debug_log(const char* value,
                             size_t size) {
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    response_type_.debug_log_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.debug_log_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.debug_log)
}
inline std::string* GetResponseResponse::_internal_mutable_debug_log() {
  if (!_internal_has_debug_log()) {
    clear_response_type();
    set_has_debug_log();
    response_type_.debug_log_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return response_type_.debug_log_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse::release_debug_log() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.debug_log)
  if (_internal_has_debug_log()) {
    clear_has_response_type();
    return response_type_.debug_log_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::set_allocated_debug_log(std::string* debug_log) {
  if (has_response_type()) {
    clear_response_type();
  }
  if (debug_log != nullptr) {
    set_has_debug_log();
    response_type_.debug_log_.UnsafeSetDefault(debug_log);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(debug_log);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.debug_log)
}

// .service.GetResponseResponse.UserTranscript user_query = 5;
inline bool GetResponseResponse::_internal_has_user_query() const {
  return response_type_case() == kUserQuery;
}
inline bool GetResponseResponse::has_user_query() const {
  return _internal_has_user_query();
}
inline void GetResponseResponse::set_has_user_query() {
  _oneof_case_[0] = kUserQuery;
}
inline void GetResponseResponse::clear_user_query() {
  if (_internal_has_user_query()) {
    if (GetArena() == nullptr) {
      delete response_type_.user_query_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::release_user_query() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.user_query)
  if (_internal_has_user_query()) {
    clear_has_response_type();
      ::service::GetResponseResponse_UserTranscript* temp = response_type_.user_query_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_type_.user_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_UserTranscript& GetResponseResponse::_internal_user_query() const {
  return _internal_has_user_query()
      ? *response_type_.user_query_
      : reinterpret_cast< ::service::GetResponseResponse_UserTranscript&>(::service::_GetResponseResponse_UserTranscript_default_instance_);
}
inline const ::service::GetResponseResponse_UserTranscript& GetResponseResponse::user_query() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.user_query)
  return _internal_user_query();
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::unsafe_arena_release_user_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.user_query)
  if (_internal_has_user_query()) {
    clear_has_response_type();
    ::service::GetResponseResponse_UserTranscript* temp = response_type_.user_query_;
    response_type_.user_query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_user_query(::service::GetResponseResponse_UserTranscript* user_query) {
  clear_response_type();
  if (user_query) {
    set_has_user_query();
    response_type_.user_query_ = user_query;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.user_query)
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::_internal_mutable_user_query() {
  if (!_internal_has_user_query()) {
    clear_response_type();
    set_has_user_query();
    response_type_.user_query_ = CreateMaybeMessage< ::service::GetResponseResponse_UserTranscript >(GetArena());
  }
  return response_type_.user_query_;
}
inline ::service::GetResponseResponse_UserTranscript* GetResponseResponse::mutable_user_query() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.user_query)
  return _internal_mutable_user_query();
}

// .service.GetResponseResponse.BehaviorTreeResponse bt_response = 6;
inline bool GetResponseResponse::_internal_has_bt_response() const {
  return response_type_case() == kBtResponse;
}
inline bool GetResponseResponse::has_bt_response() const {
  return _internal_has_bt_response();
}
inline void GetResponseResponse::set_has_bt_response() {
  _oneof_case_[0] = kBtResponse;
}
inline void GetResponseResponse::clear_bt_response() {
  if (_internal_has_bt_response()) {
    if (GetArena() == nullptr) {
      delete response_type_.bt_response_;
    }
    clear_has_response_type();
  }
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::release_bt_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.bt_response)
  if (_internal_has_bt_response()) {
    clear_has_response_type();
      ::service::GetResponseResponse_BehaviorTreeResponse* temp = response_type_.bt_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_type_.bt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::service::GetResponseResponse_BehaviorTreeResponse& GetResponseResponse::_internal_bt_response() const {
  return _internal_has_bt_response()
      ? *response_type_.bt_response_
      : reinterpret_cast< ::service::GetResponseResponse_BehaviorTreeResponse&>(::service::_GetResponseResponse_BehaviorTreeResponse_default_instance_);
}
inline const ::service::GetResponseResponse_BehaviorTreeResponse& GetResponseResponse::bt_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.bt_response)
  return _internal_bt_response();
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::unsafe_arena_release_bt_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:service.GetResponseResponse.bt_response)
  if (_internal_has_bt_response()) {
    clear_has_response_type();
    ::service::GetResponseResponse_BehaviorTreeResponse* temp = response_type_.bt_response_;
    response_type_.bt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::unsafe_arena_set_allocated_bt_response(::service::GetResponseResponse_BehaviorTreeResponse* bt_response) {
  clear_response_type();
  if (bt_response) {
    set_has_bt_response();
    response_type_.bt_response_ = bt_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.GetResponseResponse.bt_response)
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::_internal_mutable_bt_response() {
  if (!_internal_has_bt_response()) {
    clear_response_type();
    set_has_bt_response();
    response_type_.bt_response_ = CreateMaybeMessage< ::service::GetResponseResponse_BehaviorTreeResponse >(GetArena());
  }
  return response_type_.bt_response_;
}
inline ::service::GetResponseResponse_BehaviorTreeResponse* GetResponseResponse::mutable_bt_response() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.bt_response)
  return _internal_mutable_bt_response();
}

// string emotion_response = 7;
inline bool GetResponseResponse::_internal_has_emotion_response() const {
  return response_type_case() == kEmotionResponse;
}
inline void GetResponseResponse::set_has_emotion_response() {
  _oneof_case_[0] = kEmotionResponse;
}
inline void GetResponseResponse::clear_emotion_response() {
  if (_internal_has_emotion_response()) {
    response_type_.emotion_response_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::emotion_response() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.emotion_response)
  return _internal_emotion_response();
}
inline void GetResponseResponse::set_emotion_response(const std::string& value) {
  _internal_set_emotion_response(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.emotion_response)
}
inline std::string* GetResponseResponse::mutable_emotion_response() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.emotion_response)
  return _internal_mutable_emotion_response();
}
inline const std::string& GetResponseResponse::_internal_emotion_response() const {
  if (_internal_has_emotion_response()) {
    return response_type_.emotion_response_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseResponse::_internal_set_emotion_response(const std::string& value) {
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    response_type_.emotion_response_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.emotion_response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse::set_emotion_response(std::string&& value) {
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.emotion_response)
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    response_type_.emotion_response_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.emotion_response_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.emotion_response)
}
inline void GetResponseResponse::set_emotion_response(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    response_type_.emotion_response_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.emotion_response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.emotion_response)
}
inline void GetResponseResponse::set_emotion_response(const char* value,
                             size_t size) {
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    response_type_.emotion_response_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.emotion_response_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.emotion_response)
}
inline std::string* GetResponseResponse::_internal_mutable_emotion_response() {
  if (!_internal_has_emotion_response()) {
    clear_response_type();
    set_has_emotion_response();
    response_type_.emotion_response_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return response_type_.emotion_response_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse::release_emotion_response() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.emotion_response)
  if (_internal_has_emotion_response()) {
    clear_has_response_type();
    return response_type_.emotion_response_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::set_allocated_emotion_response(std::string* emotion_response) {
  if (has_response_type()) {
    clear_response_type();
  }
  if (emotion_response != nullptr) {
    set_has_emotion_response();
    response_type_.emotion_response_.UnsafeSetDefault(emotion_response);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(emotion_response);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.emotion_response)
}

// string interaction_id = 8;
inline bool GetResponseResponse::_internal_has_interaction_id() const {
  return response_type_case() == kInteractionId;
}
inline void GetResponseResponse::set_has_interaction_id() {
  _oneof_case_[0] = kInteractionId;
}
inline void GetResponseResponse::clear_interaction_id() {
  if (_internal_has_interaction_id()) {
    response_type_.interaction_id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_response_type();
  }
}
inline const std::string& GetResponseResponse::interaction_id() const {
  // @@protoc_insertion_point(field_get:service.GetResponseResponse.interaction_id)
  return _internal_interaction_id();
}
inline void GetResponseResponse::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.interaction_id)
}
inline std::string* GetResponseResponse::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:service.GetResponseResponse.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& GetResponseResponse::_internal_interaction_id() const {
  if (_internal_has_interaction_id()) {
    return response_type_.interaction_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetResponseResponse::_internal_set_interaction_id(const std::string& value) {
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    response_type_.interaction_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetResponseResponse::set_interaction_id(std::string&& value) {
  // @@protoc_insertion_point(field_set:service.GetResponseResponse.interaction_id)
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    response_type_.interaction_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.GetResponseResponse.interaction_id)
}
inline void GetResponseResponse::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    response_type_.interaction_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.GetResponseResponse.interaction_id)
}
inline void GetResponseResponse::set_interaction_id(const char* value,
                             size_t size) {
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    response_type_.interaction_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  response_type_.interaction_id_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.GetResponseResponse.interaction_id)
}
inline std::string* GetResponseResponse::_internal_mutable_interaction_id() {
  if (!_internal_has_interaction_id()) {
    clear_response_type();
    set_has_interaction_id();
    response_type_.interaction_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return response_type_.interaction_id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetResponseResponse::release_interaction_id() {
  // @@protoc_insertion_point(field_release:service.GetResponseResponse.interaction_id)
  if (_internal_has_interaction_id()) {
    clear_has_response_type();
    return response_type_.interaction_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void GetResponseResponse::set_allocated_interaction_id(std::string* interaction_id) {
  if (has_response_type()) {
    clear_response_type();
  }
  if (interaction_id != nullptr) {
    set_has_interaction_id();
    response_type_.interaction_id_.UnsafeSetDefault(interaction_id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(interaction_id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:service.GetResponseResponse.interaction_id)
}

inline bool GetResponseResponse::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void GetResponseResponse::clear_has_response_type() {
  _oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline GetResponseResponse::ResponseTypeCase GetResponseResponse::response_type_case() const {
  return GetResponseResponse::ResponseTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VisemesData

// .service.Viseme visemes = 1;
inline bool VisemesData::_internal_has_visemes() const {
  return this != internal_default_instance() && visemes_ != nullptr;
}
inline bool VisemesData::has_visemes() const {
  return _internal_has_visemes();
}
inline void VisemesData::clear_visemes() {
  if (GetArena() == nullptr && visemes_ != nullptr) {
    delete visemes_;
  }
  visemes_ = nullptr;
}
inline const ::service::Viseme& VisemesData::_internal_visemes() const {
  const ::service::Viseme* p = visemes_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::Viseme&>(
      ::service::_Viseme_default_instance_);
}
inline const ::service::Viseme& VisemesData::visemes() const {
  // @@protoc_insertion_point(field_get:service.VisemesData.visemes)
  return _internal_visemes();
}
inline void VisemesData::unsafe_arena_set_allocated_visemes(
    ::service::Viseme* visemes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visemes_);
  }
  visemes_ = visemes;
  if (visemes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.VisemesData.visemes)
}
inline ::service::Viseme* VisemesData::release_visemes() {
  
  ::service::Viseme* temp = visemes_;
  visemes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::service::Viseme* VisemesData::unsafe_arena_release_visemes() {
  // @@protoc_insertion_point(field_release:service.VisemesData.visemes)
  
  ::service::Viseme* temp = visemes_;
  visemes_ = nullptr;
  return temp;
}
inline ::service::Viseme* VisemesData::_internal_mutable_visemes() {
  
  if (visemes_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::Viseme>(GetArena());
    visemes_ = p;
  }
  return visemes_;
}
inline ::service::Viseme* VisemesData::mutable_visemes() {
  // @@protoc_insertion_point(field_mutable:service.VisemesData.visemes)
  return _internal_mutable_visemes();
}
inline void VisemesData::set_allocated_visemes(::service::Viseme* visemes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete visemes_;
  }
  if (visemes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(visemes);
    if (message_arena != submessage_arena) {
      visemes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visemes, submessage_arena);
    }
    
  } else {
    
  }
  visemes_ = visemes;
  // @@protoc_insertion_point(field_set_allocated:service.VisemesData.visemes)
}

// -------------------------------------------------------------------

// Viseme

// float sil = 1;
inline void Viseme::clear_sil() {
  sil_ = 0;
}
inline float Viseme::_internal_sil() const {
  return sil_;
}
inline float Viseme::sil() const {
  // @@protoc_insertion_point(field_get:service.Viseme.sil)
  return _internal_sil();
}
inline void Viseme::_internal_set_sil(float value) {
  
  sil_ = value;
}
inline void Viseme::set_sil(float value) {
  _internal_set_sil(value);
  // @@protoc_insertion_point(field_set:service.Viseme.sil)
}

// float pp = 2;
inline void Viseme::clear_pp() {
  pp_ = 0;
}
inline float Viseme::_internal_pp() const {
  return pp_;
}
inline float Viseme::pp() const {
  // @@protoc_insertion_point(field_get:service.Viseme.pp)
  return _internal_pp();
}
inline void Viseme::_internal_set_pp(float value) {
  
  pp_ = value;
}
inline void Viseme::set_pp(float value) {
  _internal_set_pp(value);
  // @@protoc_insertion_point(field_set:service.Viseme.pp)
}

// float ff = 3;
inline void Viseme::clear_ff() {
  ff_ = 0;
}
inline float Viseme::_internal_ff() const {
  return ff_;
}
inline float Viseme::ff() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ff)
  return _internal_ff();
}
inline void Viseme::_internal_set_ff(float value) {
  
  ff_ = value;
}
inline void Viseme::set_ff(float value) {
  _internal_set_ff(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ff)
}

// float th = 4;
inline void Viseme::clear_th() {
  th_ = 0;
}
inline float Viseme::_internal_th() const {
  return th_;
}
inline float Viseme::th() const {
  // @@protoc_insertion_point(field_get:service.Viseme.th)
  return _internal_th();
}
inline void Viseme::_internal_set_th(float value) {
  
  th_ = value;
}
inline void Viseme::set_th(float value) {
  _internal_set_th(value);
  // @@protoc_insertion_point(field_set:service.Viseme.th)
}

// float dd = 5;
inline void Viseme::clear_dd() {
  dd_ = 0;
}
inline float Viseme::_internal_dd() const {
  return dd_;
}
inline float Viseme::dd() const {
  // @@protoc_insertion_point(field_get:service.Viseme.dd)
  return _internal_dd();
}
inline void Viseme::_internal_set_dd(float value) {
  
  dd_ = value;
}
inline void Viseme::set_dd(float value) {
  _internal_set_dd(value);
  // @@protoc_insertion_point(field_set:service.Viseme.dd)
}

// float kk = 6;
inline void Viseme::clear_kk() {
  kk_ = 0;
}
inline float Viseme::_internal_kk() const {
  return kk_;
}
inline float Viseme::kk() const {
  // @@protoc_insertion_point(field_get:service.Viseme.kk)
  return _internal_kk();
}
inline void Viseme::_internal_set_kk(float value) {
  
  kk_ = value;
}
inline void Viseme::set_kk(float value) {
  _internal_set_kk(value);
  // @@protoc_insertion_point(field_set:service.Viseme.kk)
}

// float ch = 7;
inline void Viseme::clear_ch() {
  ch_ = 0;
}
inline float Viseme::_internal_ch() const {
  return ch_;
}
inline float Viseme::ch() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ch)
  return _internal_ch();
}
inline void Viseme::_internal_set_ch(float value) {
  
  ch_ = value;
}
inline void Viseme::set_ch(float value) {
  _internal_set_ch(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ch)
}

// float ss = 8;
inline void Viseme::clear_ss() {
  ss_ = 0;
}
inline float Viseme::_internal_ss() const {
  return ss_;
}
inline float Viseme::ss() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ss)
  return _internal_ss();
}
inline void Viseme::_internal_set_ss(float value) {
  
  ss_ = value;
}
inline void Viseme::set_ss(float value) {
  _internal_set_ss(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ss)
}

// float nn = 9;
inline void Viseme::clear_nn() {
  nn_ = 0;
}
inline float Viseme::_internal_nn() const {
  return nn_;
}
inline float Viseme::nn() const {
  // @@protoc_insertion_point(field_get:service.Viseme.nn)
  return _internal_nn();
}
inline void Viseme::_internal_set_nn(float value) {
  
  nn_ = value;
}
inline void Viseme::set_nn(float value) {
  _internal_set_nn(value);
  // @@protoc_insertion_point(field_set:service.Viseme.nn)
}

// float rr = 10;
inline void Viseme::clear_rr() {
  rr_ = 0;
}
inline float Viseme::_internal_rr() const {
  return rr_;
}
inline float Viseme::rr() const {
  // @@protoc_insertion_point(field_get:service.Viseme.rr)
  return _internal_rr();
}
inline void Viseme::_internal_set_rr(float value) {
  
  rr_ = value;
}
inline void Viseme::set_rr(float value) {
  _internal_set_rr(value);
  // @@protoc_insertion_point(field_set:service.Viseme.rr)
}

// float aa = 11;
inline void Viseme::clear_aa() {
  aa_ = 0;
}
inline float Viseme::_internal_aa() const {
  return aa_;
}
inline float Viseme::aa() const {
  // @@protoc_insertion_point(field_get:service.Viseme.aa)
  return _internal_aa();
}
inline void Viseme::_internal_set_aa(float value) {
  
  aa_ = value;
}
inline void Viseme::set_aa(float value) {
  _internal_set_aa(value);
  // @@protoc_insertion_point(field_set:service.Viseme.aa)
}

// float e = 12;
inline void Viseme::clear_e() {
  e_ = 0;
}
inline float Viseme::_internal_e() const {
  return e_;
}
inline float Viseme::e() const {
  // @@protoc_insertion_point(field_get:service.Viseme.e)
  return _internal_e();
}
inline void Viseme::_internal_set_e(float value) {
  
  e_ = value;
}
inline void Viseme::set_e(float value) {
  _internal_set_e(value);
  // @@protoc_insertion_point(field_set:service.Viseme.e)
}

// float ih = 13;
inline void Viseme::clear_ih() {
  ih_ = 0;
}
inline float Viseme::_internal_ih() const {
  return ih_;
}
inline float Viseme::ih() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ih)
  return _internal_ih();
}
inline void Viseme::_internal_set_ih(float value) {
  
  ih_ = value;
}
inline void Viseme::set_ih(float value) {
  _internal_set_ih(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ih)
}

// float oh = 14;
inline void Viseme::clear_oh() {
  oh_ = 0;
}
inline float Viseme::_internal_oh() const {
  return oh_;
}
inline float Viseme::oh() const {
  // @@protoc_insertion_point(field_get:service.Viseme.oh)
  return _internal_oh();
}
inline void Viseme::_internal_set_oh(float value) {
  
  oh_ = value;
}
inline void Viseme::set_oh(float value) {
  _internal_set_oh(value);
  // @@protoc_insertion_point(field_set:service.Viseme.oh)
}

// float ou = 15;
inline void Viseme::clear_ou() {
  ou_ = 0;
}
inline float Viseme::_internal_ou() const {
  return ou_;
}
inline float Viseme::ou() const {
  // @@protoc_insertion_point(field_get:service.Viseme.ou)
  return _internal_ou();
}
inline void Viseme::_internal_set_ou(float value) {
  
  ou_ = value;
}
inline void Viseme::set_ou(float value) {
  _internal_set_ou(value);
  // @@protoc_insertion_point(field_set:service.Viseme.ou)
}

// -------------------------------------------------------------------

// BlendShapesData

// string blendshape_data = 1;
inline void BlendShapesData::clear_blendshape_data() {
  blendshape_data_.ClearToEmpty();
}
inline const std::string& BlendShapesData::blendshape_data() const {
  // @@protoc_insertion_point(field_get:service.BlendShapesData.blendshape_data)
  return _internal_blendshape_data();
}
inline void BlendShapesData::set_blendshape_data(const std::string& value) {
  _internal_set_blendshape_data(value);
  // @@protoc_insertion_point(field_set:service.BlendShapesData.blendshape_data)
}
inline std::string* BlendShapesData::mutable_blendshape_data() {
  // @@protoc_insertion_point(field_mutable:service.BlendShapesData.blendshape_data)
  return _internal_mutable_blendshape_data();
}
inline const std::string& BlendShapesData::_internal_blendshape_data() const {
  return blendshape_data_.Get();
}
inline void BlendShapesData::_internal_set_blendshape_data(const std::string& value) {
  
  blendshape_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BlendShapesData::set_blendshape_data(std::string&& value) {
  
  blendshape_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.BlendShapesData.blendshape_data)
}
inline void BlendShapesData::set_blendshape_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  blendshape_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.BlendShapesData.blendshape_data)
}
inline void BlendShapesData::set_blendshape_data(const char* value,
    size_t size) {
  
  blendshape_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.BlendShapesData.blendshape_data)
}
inline std::string* BlendShapesData::_internal_mutable_blendshape_data() {
  
  return blendshape_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BlendShapesData::release_blendshape_data() {
  // @@protoc_insertion_point(field_release:service.BlendShapesData.blendshape_data)
  return blendshape_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlendShapesData::set_allocated_blendshape_data(std::string* blendshape_data) {
  if (blendshape_data != nullptr) {
    
  } else {
    
  }
  blendshape_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blendshape_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.BlendShapesData.blendshape_data)
}

// -------------------------------------------------------------------

// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:service.HelloRequest.name)
  return _internal_name();
}
inline void HelloRequest::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:service.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  // @@protoc_insertion_point(field_mutable:service.HelloRequest.name)
  return _internal_mutable_name();
}
inline const std::string& HelloRequest::_internal_name() const {
  return name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HelloRequest::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.HelloRequest.name)
}
inline void HelloRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.HelloRequest.name)
}
inline void HelloRequest::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.HelloRequest.name)
}
inline std::string* HelloRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:service.HelloRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloResponse

// string message = 1;
inline void HelloResponse::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& HelloResponse::message() const {
  // @@protoc_insertion_point(field_get:service.HelloResponse.message)
  return _internal_message();
}
inline void HelloResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:service.HelloResponse.message)
}
inline std::string* HelloResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:service.HelloResponse.message)
  return _internal_mutable_message();
}
inline const std::string& HelloResponse::_internal_message() const {
  return message_.Get();
}
inline void HelloResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HelloResponse::set_message(std::string&& value) {
  
  message_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.HelloResponse.message)
}
inline void HelloResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.HelloResponse.message)
}
inline void HelloResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.HelloResponse.message)
}
inline std::string* HelloResponse::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HelloResponse::release_message() {
  // @@protoc_insertion_point(field_release:service.HelloResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HelloResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.HelloResponse.message)
}

// -------------------------------------------------------------------

// FeedbackRequest_Feedback

// bool thumbs_up = 1;
inline void FeedbackRequest_Feedback::clear_thumbs_up() {
  thumbs_up_ = false;
}
inline bool FeedbackRequest_Feedback::_internal_thumbs_up() const {
  return thumbs_up_;
}
inline bool FeedbackRequest_Feedback::thumbs_up() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.thumbs_up)
  return _internal_thumbs_up();
}
inline void FeedbackRequest_Feedback::_internal_set_thumbs_up(bool value) {
  
  thumbs_up_ = value;
}
inline void FeedbackRequest_Feedback::set_thumbs_up(bool value) {
  _internal_set_thumbs_up(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.thumbs_up)
}

// string feedback_text = 2;
inline void FeedbackRequest_Feedback::clear_feedback_text() {
  feedback_text_.ClearToEmpty();
}
inline const std::string& FeedbackRequest_Feedback::feedback_text() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.Feedback.feedback_text)
  return _internal_feedback_text();
}
inline void FeedbackRequest_Feedback::set_feedback_text(const std::string& value) {
  _internal_set_feedback_text(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.Feedback.feedback_text)
}
inline std::string* FeedbackRequest_Feedback::mutable_feedback_text() {
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.Feedback.feedback_text)
  return _internal_mutable_feedback_text();
}
inline const std::string& FeedbackRequest_Feedback::_internal_feedback_text() const {
  return feedback_text_.Get();
}
inline void FeedbackRequest_Feedback::_internal_set_feedback_text(const std::string& value) {
  
  feedback_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeedbackRequest_Feedback::set_feedback_text(std::string&& value) {
  
  feedback_text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.FeedbackRequest.Feedback.feedback_text)
}
inline void FeedbackRequest_Feedback::set_feedback_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  feedback_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.FeedbackRequest.Feedback.feedback_text)
}
inline void FeedbackRequest_Feedback::set_feedback_text(const char* value,
    size_t size) {
  
  feedback_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.FeedbackRequest.Feedback.feedback_text)
}
inline std::string* FeedbackRequest_Feedback::_internal_mutable_feedback_text() {
  
  return feedback_text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeedbackRequest_Feedback::release_feedback_text() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.Feedback.feedback_text)
  return feedback_text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeedbackRequest_Feedback::set_allocated_feedback_text(std::string* feedback_text) {
  if (feedback_text != nullptr) {
    
  } else {
    
  }
  feedback_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), feedback_text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.Feedback.feedback_text)
}

// -------------------------------------------------------------------

// FeedbackRequest

// string interaction_id = 1;
inline void FeedbackRequest::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::interaction_id() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.interaction_id)
  return _internal_interaction_id();
}
inline void FeedbackRequest::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.interaction_id)
}
inline std::string* FeedbackRequest::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& FeedbackRequest::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void FeedbackRequest::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeedbackRequest::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.FeedbackRequest.interaction_id)
}
inline void FeedbackRequest::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.FeedbackRequest.interaction_id)
}
inline void FeedbackRequest::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.FeedbackRequest.interaction_id)
}
inline std::string* FeedbackRequest::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeedbackRequest::release_interaction_id() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeedbackRequest::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.interaction_id)
}

// string character_id = 2;
inline void FeedbackRequest::clear_character_id() {
  character_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::character_id() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.character_id)
  return _internal_character_id();
}
inline void FeedbackRequest::set_character_id(const std::string& value) {
  _internal_set_character_id(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.character_id)
}
inline std::string* FeedbackRequest::mutable_character_id() {
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.character_id)
  return _internal_mutable_character_id();
}
inline const std::string& FeedbackRequest::_internal_character_id() const {
  return character_id_.Get();
}
inline void FeedbackRequest::_internal_set_character_id(const std::string& value) {
  
  character_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeedbackRequest::set_character_id(std::string&& value) {
  
  character_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.FeedbackRequest.character_id)
}
inline void FeedbackRequest::set_character_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  character_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.FeedbackRequest.character_id)
}
inline void FeedbackRequest::set_character_id(const char* value,
    size_t size) {
  
  character_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.FeedbackRequest.character_id)
}
inline std::string* FeedbackRequest::_internal_mutable_character_id() {
  
  return character_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeedbackRequest::release_character_id() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.character_id)
  return character_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeedbackRequest::set_allocated_character_id(std::string* character_id) {
  if (character_id != nullptr) {
    
  } else {
    
  }
  character_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), character_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.character_id)
}

// string session_id = 3;
inline void FeedbackRequest::clear_session_id() {
  session_id_.ClearToEmpty();
}
inline const std::string& FeedbackRequest::session_id() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.session_id)
  return _internal_session_id();
}
inline void FeedbackRequest::set_session_id(const std::string& value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:service.FeedbackRequest.session_id)
}
inline std::string* FeedbackRequest::mutable_session_id() {
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.session_id)
  return _internal_mutable_session_id();
}
inline const std::string& FeedbackRequest::_internal_session_id() const {
  return session_id_.Get();
}
inline void FeedbackRequest::_internal_set_session_id(const std::string& value) {
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeedbackRequest::set_session_id(std::string&& value) {
  
  session_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.FeedbackRequest.session_id)
}
inline void FeedbackRequest::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.FeedbackRequest.session_id)
}
inline void FeedbackRequest::set_session_id(const char* value,
    size_t size) {
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.FeedbackRequest.session_id)
}
inline std::string* FeedbackRequest::_internal_mutable_session_id() {
  
  return session_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeedbackRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.session_id)
  return session_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeedbackRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.session_id)
}

// .service.FeedbackRequest.Feedback text_feedback = 5;
inline bool FeedbackRequest::_internal_has_text_feedback() const {
  return this != internal_default_instance() && text_feedback_ != nullptr;
}
inline bool FeedbackRequest::has_text_feedback() const {
  return _internal_has_text_feedback();
}
inline void FeedbackRequest::clear_text_feedback() {
  if (GetArena() == nullptr && text_feedback_ != nullptr) {
    delete text_feedback_;
  }
  text_feedback_ = nullptr;
}
inline const ::service::FeedbackRequest_Feedback& FeedbackRequest::_internal_text_feedback() const {
  const ::service::FeedbackRequest_Feedback* p = text_feedback_;
  return p != nullptr ? *p : reinterpret_cast<const ::service::FeedbackRequest_Feedback&>(
      ::service::_FeedbackRequest_Feedback_default_instance_);
}
inline const ::service::FeedbackRequest_Feedback& FeedbackRequest::text_feedback() const {
  // @@protoc_insertion_point(field_get:service.FeedbackRequest.text_feedback)
  return _internal_text_feedback();
}
inline void FeedbackRequest::unsafe_arena_set_allocated_text_feedback(
    ::service::FeedbackRequest_Feedback* text_feedback) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_feedback_);
  }
  text_feedback_ = text_feedback;
  if (text_feedback) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:service.FeedbackRequest.text_feedback)
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::release_text_feedback() {
  
  ::service::FeedbackRequest_Feedback* temp = text_feedback_;
  text_feedback_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::unsafe_arena_release_text_feedback() {
  // @@protoc_insertion_point(field_release:service.FeedbackRequest.text_feedback)
  
  ::service::FeedbackRequest_Feedback* temp = text_feedback_;
  text_feedback_ = nullptr;
  return temp;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::_internal_mutable_text_feedback() {
  
  if (text_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::service::FeedbackRequest_Feedback>(GetArena());
    text_feedback_ = p;
  }
  return text_feedback_;
}
inline ::service::FeedbackRequest_Feedback* FeedbackRequest::mutable_text_feedback() {
  // @@protoc_insertion_point(field_mutable:service.FeedbackRequest.text_feedback)
  return _internal_mutable_text_feedback();
}
inline void FeedbackRequest::set_allocated_text_feedback(::service::FeedbackRequest_Feedback* text_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete text_feedback_;
  }
  if (text_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(text_feedback);
    if (message_arena != submessage_arena) {
      text_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_feedback, submessage_arena);
    }
    
  } else {
    
  }
  text_feedback_ = text_feedback;
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackRequest.text_feedback)
}

// -------------------------------------------------------------------

// FeedbackResponse

// string feedback_response = 1;
inline void FeedbackResponse::clear_feedback_response() {
  feedback_response_.ClearToEmpty();
}
inline const std::string& FeedbackResponse::feedback_response() const {
  // @@protoc_insertion_point(field_get:service.FeedbackResponse.feedback_response)
  return _internal_feedback_response();
}
inline void FeedbackResponse::set_feedback_response(const std::string& value) {
  _internal_set_feedback_response(value);
  // @@protoc_insertion_point(field_set:service.FeedbackResponse.feedback_response)
}
inline std::string* FeedbackResponse::mutable_feedback_response() {
  // @@protoc_insertion_point(field_mutable:service.FeedbackResponse.feedback_response)
  return _internal_mutable_feedback_response();
}
inline const std::string& FeedbackResponse::_internal_feedback_response() const {
  return feedback_response_.Get();
}
inline void FeedbackResponse::_internal_set_feedback_response(const std::string& value) {
  
  feedback_response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeedbackResponse::set_feedback_response(std::string&& value) {
  
  feedback_response_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:service.FeedbackResponse.feedback_response)
}
inline void FeedbackResponse::set_feedback_response(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  feedback_response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:service.FeedbackResponse.feedback_response)
}
inline void FeedbackResponse::set_feedback_response(const char* value,
    size_t size) {
  
  feedback_response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:service.FeedbackResponse.feedback_response)
}
inline std::string* FeedbackResponse::_internal_mutable_feedback_response() {
  
  return feedback_response_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeedbackResponse::release_feedback_response() {
  // @@protoc_insertion_point(field_release:service.FeedbackResponse.feedback_response)
  return feedback_response_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeedbackResponse::set_allocated_feedback_response(std::string* feedback_response) {
  if (feedback_response != nullptr) {
    
  } else {
    
  }
  feedback_response_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), feedback_response,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:service.FeedbackResponse.feedback_response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::service::FaceModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::service::FaceModel>() {
  return ::service::FaceModel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_service_2eproto

#endif